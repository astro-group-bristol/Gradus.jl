<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Adaptive tracing · Gradus.jl Documentation</title><meta name="title" content="Adaptive tracing · Gradus.jl Documentation"/><meta property="og:title" content="Adaptive tracing · Gradus.jl Documentation"/><meta property="twitter:title" content="Adaptive tracing · Gradus.jl Documentation"/><meta name="description" content="Documentation for Gradus.jl Documentation."/><meta property="og:description" content="Documentation for Gradus.jl Documentation."/><meta property="twitter:description" content="Documentation for Gradus.jl Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Gradus.jl Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Gradus.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting started</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">Reference &amp; walkthroughs</span><ul><li><a class="tocitem" href="../metrics/">Catalogue of metrics</a></li><li><a class="tocitem" href="../accretion-geometry/">Accretion geometry</a></li><li><a class="tocitem" href="../problems-and-solvers/">Problems and solvers</a></li><li><a class="tocitem" href="../point-functions/">Point functions</a></li><li><a class="tocitem" href="../emissivity/">Disc emissivity</a></li><li><a class="tocitem" href="../lineprofiles/">Line profiles</a></li><li class="is-active"><a class="tocitem" href>Adaptive tracing</a><ul class="internal"><li><a class="tocitem" href="#Custom-adaptive-refinement"><span>Custom adaptive refinement</span></a></li></ul></li></ul></li><li><span class="tocitem">Geodesics and integration</span><ul><li><a class="tocitem" href="../custom-metrics/">Implementing new metrics</a></li><li><a class="tocitem" href="../geodesic-integration/">Geodesic integration</a></li><li><a class="tocitem" href="../parallelism/">Parallelism and ensembles</a></li><li><a class="tocitem" href="../special-radii/">Special radii</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../api-documentation/Gradus/">Gradus</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference &amp; walkthroughs</a></li><li class="is-active"><a href>Adaptive tracing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Adaptive tracing</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/astro-group-bristol/Gradus.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/astro-group-bristol/Gradus.jl/blob/main/docs/src/adaptive-tracing.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Adaptive-tracing"><a class="docs-heading-anchor" href="#Adaptive-tracing">Adaptive tracing</a><a id="Adaptive-tracing-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-tracing" title="Permalink"></a></h1><p>Gradus.jl has a variety of skies and image planes that it supports, which act as a method for representing the view of a particular observer in the system. The difference in definition that Gradus uses is that a <em>sky</em> represents either a full sphere (or hemisphere) of possible trajectories, whereas a <em>image plane</em> is a subset of the sphere that projects onto a two-dimensional plane. Image planes are only really used in the context of calculating observational signatures from the perspective of telescopes, whereas skies are used as intermediary representations to calculate e.g. illumination patterns or visibilities.</p><p>To integrate over a sky, each angle pair <span>$(\theta, \phi)$</span> is used to calculate a direction vector, which is transformed by the local basis into an initial velocity vector that is sensitive to the motion of the emitter. These trajectories can be heavily distorted due to relativistic beaming if the emitter is moving at relativistic speeds.</p><p>One of the main problem with integrating over a sky in any kind of numerically meaningful way is that the angles, if sampled uniformly over <span>$\theta \sim \mathcal{U}(0, \pi)$</span> and <span>$\phi \sim \mathcal{U}(0, 2\pi)$</span>, then the majority of trajectories will be scrunched near the poles. To avoid this issue, one can instead sample <span>$\cos \theta \sim \mathcal{U}(-1, 1)$</span>, which acts to impose the <span>$\sin \theta$</span> probability density term.</p><p>This however still has the problem that often very few regions of the sky actually represent something interesting. For example, say we were calculating the illumination pattern of the disc for an emitter close the black hole – we do not care about those trajectories that fall into the black hole or escape to infinity, only those that hit the disc. However, a hand-wavey 50% of the sky will be either the black hole or infinity, so it is wasting precious CPU cycles calculating those trajectories when we know they are not relevant to our result.</p><p>This is where <em>adaptive tracing</em> is useful. It traces an initial coarse grid of <em>pilot geodesics</em> that can be used to work out where information of interest is in the sky.</p><p>To illustrate this, we&#39;ll use a pre-defined adaptive sky implementation, but at the end of these instructions will be a section on <a href="@ref">Custom refinement criteria</a>.</p><pre><code class="language-julia hljs">using Gradus, Makie, CairoMakie

m = KerrMetric(1.0, 0.998)
# the ring-corona can also be used to represent any off-axis point
corona = RingCorona(; r = 10.0, h = 4.0)
d = ThinDisc(0.0, Inf)

sky = AdaptiveSky(m, corona, d)</code></pre><p>The <a href="#Gradus.AdaptiveSky"><code>AdaptiveSky</code></a> uses a grid of 3x3 cells, where each cell can be continuously refined to smaller 3x3 cells. It refers to each refinement as a <code>level</code>, where <code>level == 1</code> are the top 9 cells.</p><p>We need to prime the refined grid, so we trace three levels, corresponding to <span>$9^3 = 729$</span> trajectories.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gradus.trace_initial!" href="#Gradus.trace_initial!"><code>Gradus.trace_initial!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trace_initial!(sky::AdaptiveSky; level = 3)</code></pre><p>Initialise the sky to a given level of refinement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/astro-group-bristol/Gradus.jl/blob/8460f8f24520b420264fc6c578bf1b3603fbfce3/src/image-planes/adaptive-sky.jl#L101-L105">source</a></section></article><pre><code class="language-julia hljs"># trace an initial grid of points
trace_initial!(sky)</code></pre><p>The printout may record a greater number of values than you expect. This is because it is recording the number of values it has stored, and some cells double up in the implementation (though they are not traced, their memory is duplicated currently).</p><p>We can visualise the sky using one of the unpacking functions</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gradus.unpack_sky" href="#Gradus.unpack_sky"><code>Gradus.unpack_sky</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unpack_sky(sky::AdaptiveSky)</code></pre><p>Return three arrays, representing the <code>x</code>, <code>y</code> coordinates of each point, and it&#39;s associated value <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/astro-group-bristol/Gradus.jl/blob/8460f8f24520b420264fc6c578bf1b3603fbfce3/src/image-planes/adaptive-sky.jl#L289-L294">source</a></section></article><p>The <code>V</code> type of the sky we have constructed is <a href="@ref"><code>CoronaGridValues</code></a>.</p><pre><code class="language-julia hljs">function plot_sky(sky; kwargs...)
    phi, cos_theta, values = unpack_sky(sky)
    theta = acos.(cos_theta)
    # get the radius that each geodesic hit
    Rs = [v.r for v in values]

    fig, ax, _ = scatter(phi, theta; color = log10.(Rs), kwargs...)
    ax.xlabel = &quot;ϕ&quot;
    ax.ylabel = &quot;θ&quot;
    fig
end

plot_sky(sky)</code></pre><p><img src="../figs/adaptive.initial.png" alt/></p><p>Not all of the points have been drawn, since those that either fell into the black hole or went to inifinity had their radius set to <code>NaN</code>. This is a feature of the particular <a href="#Gradus.AdaptiveSky"><code>AdaptiveSky</code></a> we have used, but you can handle this however you like in your own implementation.</p><p>Lets say we are now interested in the edges of the disc, and want to refine those points. We can define a <em>refine</em> condition that is given pairs of neighbouring points and asks whether the cells they are in need to be refined.</p><p>In our case, if one or the other is <code>NaN</code> (but not both), we want to refine those cells. We&#39;ll implement the full function, but there are utilities to help as well like <a href="#Gradus.refine_function"><code>Gradus.refine_function</code></a>.</p><pre><code class="language-julia hljs">function refine_edges(sky::AdaptiveSky, i1::Int, i2::Int)
    v1 = sky.values[i1]
    v2 = sky.values[i2]
    if isnan(v1.r) &amp;&amp; isnan(v2.r)
        false # do not refine
    else
        isnan(v1.r) || isnan(v2.r)
    end
end

trace_step!(sky; check_refine = refine_edges, verbose = true)</code></pre><p>Plotting the sky again</p><pre><code class="language-julia hljs">plot_sky(sky; markersize = 6)</code></pre><div class="admonition is-info" id="Note-5efe04af4dda0c2"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-5efe04af4dda0c2" title="Permalink"></a></header><div class="admonition-body"><p>There is currently a bug where the bottom row of cells are always refined when checking <code>NaN</code>. This will be fixed in future versions.</p></div></div><p><img src="../figs/adaptive.step-1.png" alt/></p><p>We can run this step a couple more times:</p><pre><code class="language-julia hljs">for i in 1:2
    trace_step!(sky; check_refine = refine_edges, verbose = true)
end

plot_sky(sky; markersize = 2)</code></pre><p><img src="../figs/adaptive.step-3.png" alt/></p><p>Cool, now let&#39;s inpaint the rest using an interpolation scheme:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gradus.fill_sky_values" href="#Gradus.fill_sky_values"><code>Gradus.fill_sky_values</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fill_sky_values(sky::AdaptiveSky{T,&lt;:CoronaGridValues}, N)</code></pre><p>Returns three dense arrays, two vectors representing the θ and ϕ, and a grid with the averaged <a href="@ref"><code>CoronaGridValues</code></a> at that point, computed using <a href="@ref"><code>vector_average</code></a>. This effectively acts to fill in the sky with <code>N x N</code> points using the information calculated by the adaptive sky.</p><pre><code class="nohighlight hljs">fill_sky_values(
    sky::AdaptiveSky{T,&lt;:CoronaGridValues},
    phi_grid::AbstractVector,
    theta_grid::AbstractVector
)</code></pre><p>Returns only the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/astro-group-bristol/Gradus.jl/blob/8460f8f24520b420264fc6c578bf1b3603fbfce3/src/corona/adaptive-sample.jl#L180-L195">source</a></section></article><div class="admonition is-warning" id="Warning-55dc6fc911ec5407"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-55dc6fc911ec5407" title="Permalink"></a></header><div class="admonition-body"><p>The interpolation scheme used is very poor at the moment, and effectively does column-wise interpolation, without considering other surrounding neighbours. This will also be fixed in future versions.</p></div></div><pre><code class="language-julia hljs">phi, theta, grid = fill_sky_values(sky, 1080)
Rs = [v.r for v in grid]

fig, ax, _ = heatmap(phi, theta, log10.(Rs)&#39;)
ax.xlabel = &quot;ϕ&quot;
ax.ylabel = &quot;θ&quot;
fig</code></pre><p><img src="../figs/adaptive.approx-inpaint.png" alt/></p><p>What if we had a refinemenet criteria based on the relative values of neighbours?</p><pre><code class="language-julia hljs">function refine_distant(sky::AdaptiveSky, i1::Int, i2::Int)
    v1 = sky.values[i1]
    v2 = sky.values[i2]
    if isnan(v1.r) &amp;&amp; isnan(v2.r)
        false # do not refine
    else
        # refine if they are more than 10% different
        !isapprox(v1.r, v2.r, rtol = 0.1)
    end
end

# create a fresh sky
sky = AdaptiveSky(m, corona, d)
trace_initial!(sky)
for i in 1:3
    trace_step!(sky; check_refine = refine_distant, verbose = true)
end

plot_sky(sky; markersize = 2)</code></pre><p><img src="../figs/adaptive.refine-distance.png" alt/></p><p>Now our inpainting should look more convincing</p><pre><code class="language-julia hljs">phi, theta, grid = fill_sky_values(sky, 1080)
Rs = [v.r for v in grid]

fig, ax, _ = heatmap(phi, theta, log10.(Rs)&#39;)
ax.xlabel = &quot;ϕ&quot;
ax.ylabel = &quot;θ&quot;
fig</code></pre><p><img src="../figs/adaptive.better-inpaint.png" alt/></p><h2 id="Custom-adaptive-refinement"><a class="docs-heading-anchor" href="#Custom-adaptive-refinement">Custom adaptive refinement</a><a id="Custom-adaptive-refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-adaptive-refinement" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gradus.AdaptiveSky" href="#Gradus.AdaptiveSky"><code>Gradus.AdaptiveSky</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdaptiveSky(V::Type, calc_v::Function, check_refine::Function)</code></pre><p>Create an adaptive grid for the local sky, where each point is assigned a value <code>V</code>. Must also provide two functions with the following prototypes:</p><pre><code class="language-julia hljs"># Calculate the new grid value at `(theta, phi)`
calculate_value(theta, phi)::V

# Return true if the cells being compared need to be refined.
check_refine(sky::AdaptiveSky, i1::Int, i2::Int)::Bool</code></pre><p>The values for a given cell can be access with <code>sky.values[i]</code>.</p><p>For the interpolation schemes to work, the following function must also be defined for the value type:</p><pre><code class="language-julia hljs">vector_average(weight::AbstractVector{&lt;:Number}, values::AbstractVector{V})::V where{V}
# Return something that represents a null / NaN of the given type
make_null(V::Type)::V</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/astro-group-bristol/Gradus.jl/blob/8460f8f24520b420264fc6c578bf1b3603fbfce3/src/image-planes/adaptive-sky.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gradus.trace_step!" href="#Gradus.trace_step!"><code>Gradus.trace_step!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trace_step!(sky::AdaptiveSky; check_refine = sky.check_refine, verbose = false)</code></pre><p>Apply the refinement metric across each cell boundary and refine the cells where the metric is <code>true</code>.</p><p>A different refinemenet metric from the default can be used by passing the <code>check_refine</code> kwarg, using the same function signature as documented in <a href="#Gradus.AdaptiveSky"><code>AdaptiveSky</code></a>.</p><p>If <code>verbose</code> is true, a progress bar will be displayed during refinement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/astro-group-bristol/Gradus.jl/blob/8460f8f24520b420264fc6c578bf1b3603fbfce3/src/image-planes/adaptive-sky.jl#L198-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gradus.refine_function" href="#Gradus.refine_function"><code>Gradus.refine_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refine_function(f)</code></pre><p>Used to define a new <code>check_refine</code> function for an <a href="#Gradus.AdaptiveSky"><code>AdaptiveSky</code></a>. This can be passed e.g. to <a href="@ref"><code>find_need_refine</code></a> or <a href="@ref"><code>refine_and_trace!</code></a>.</p><p>The function <code>f</code> is given each cell&#39;s value and should return <code>true</code> if the cell should be refined, else <code>false</code>.</p><p><strong>Warning</strong></p><p>This function currently only works with <code>AdaptiveSky</code> when the value type is <a href="@ref"><code>CoronaGridValues</code></a>, as it first checks if the radii are <code>NaN</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/astro-group-bristol/Gradus.jl/blob/8460f8f24520b420264fc6c578bf1b3603fbfce3/src/corona/adaptive-sample.jl#L667-L681">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gradus.fine_refine_function" href="#Gradus.fine_refine_function"><code>Gradus.fine_refine_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fine_refine_function(f)</code></pre><p>Like <a href="#Gradus.refine_function"><code>refine_function</code></a> but calls the original refine function in <a href="#Gradus.AdaptiveSky"><code>AdaptiveSky</code></a> first. This is &quot;fine&quot; in the sense that it applies fine-grained refinement criteria.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/astro-group-bristol/Gradus.jl/blob/8460f8f24520b420264fc6c578bf1b3603fbfce3/src/corona/adaptive-sample.jl#L693-L699">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gradus.Grids.AdaptiveCell" href="#Gradus.Grids.AdaptiveCell"><code>Gradus.Grids.AdaptiveCell</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdaptiveCell{P}</code></pre><p>A cell in the <a href="#Gradus.Grids.AdaptiveGrid"><code>AdaptiveGrid</code></a>. <code>P</code> is the point type (conventionally an SVector).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/astro-group-bristol/Gradus.jl/blob/8460f8f24520b420264fc6c578bf1b3603fbfce3/src/image-planes/adaptive-grid.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gradus.Grids.AdaptiveGrid" href="#Gradus.Grids.AdaptiveGrid"><code>Gradus.Grids.AdaptiveGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdaptiveGrid{P}(x1, x2, y1, y2; x_periodic = true)</code></pre><p>Constructs an <code>AdaptiveGrid</code> with domain <code>x1</code> to <code>x2</code>, and <code>y1</code> to <code>y2</code>. If <code>periodic = true</code> then the grid is periodic in the <code>x</code> direction.</p><p>An <code>AdaptiveGrid</code> is an implementation of a grid refinement structure, which splits the domain into 3x3 cells which can be refined into 3x3 child cells and so forth.</p><p>Each refinement is referred to as a <code>level</code>, with <code>level == 1</code> being the top level (i.e. initial 9 cells). The indexing scheme for (child) cells is column orientated:</p><pre><code class="nohighlight hljs"> 1 | 4 | 7
---+---+---
 2 | 5 | 8
---+---+---
 3 | 6 | 9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/astro-group-bristol/Gradus.jl/blob/8460f8f24520b420264fc6c578bf1b3603fbfce3/src/image-planes/adaptive-grid.jl#L44-L64">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lineprofiles/">« Line profiles</a><a class="docs-footer-nextpage" href="../custom-metrics/">Implementing new metrics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 17 October 2025 07:37">Friday 17 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
