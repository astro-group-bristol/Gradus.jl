<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · Gradus.jl Documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Gradus.jl Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Gradus.jl Documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Overview</span><ul><li class="is-active"><a class="tocitem" href>Getting started</a><ul class="internal"><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Defining-a-spacetime"><span>1 Defining a spacetime</span></a></li><li><a class="tocitem" href="#Photon-trajectories"><span>2 Photon trajectories</span></a></li><li><a class="tocitem" href="#Rendering-an-image"><span>3 Rendering an image</span></a></li><li><a class="tocitem" href="#Defining-and-using-PointFunctions"><span>4 Defining and using <code>PointFunction</code>s</span></a></li><li><a class="tocitem" href="#Adding-geometry"><span>5 Adding geometry</span></a></li><li><a class="tocitem" href="#Calculating-physical-quantities"><span>6 Calculating physical quantities</span></a></li><li><a class="tocitem" href="#Changing-metric"><span>7 Changing metric</span></a></li><li><a class="tocitem" href="#Calculating-line-profiles"><span>8 Calculating line profiles</span></a></li><li><a class="tocitem" href="#Where-to-go-from-here?"><span>Where to go from here?</span></a></li></ul></li><li><a class="tocitem" href="../problems-and-solvers/">Problems and solvers</a></li><li><a class="tocitem" href="../overview/point-functions/">Point functions</a></li><li><a class="tocitem" href="../overview/metrics/">Catalogue of metrics</a></li><li><a class="tocitem" href="../overview/accretion-geometry/">Accretion geometry</a></li><li><a class="tocitem" href="../internals/custom-metrics/">Implementing new metrics</a></li><li><a class="tocitem" href="../examples/examples/">Examples</a></li></ul></li><li><span class="tocitem">Advanced</span><ul><li><a class="tocitem" href="../overview/geodesic-integration/">Geodesic integration</a></li><li><a class="tocitem" href="../internals/parallelism/">Parallelism and ensembles</a></li><li><a class="tocitem" href="../internals/special-radii/">Special radii</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../api-documentation/Gradus/">Gradus</a></li><li><a class="tocitem" href="../api-documentation/GradusBase/">GradusBase</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Overview</a></li><li class="is-active"><a href>Getting started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/astro-group-bristol/Gradus.jl/blob/main/docs/src/getting-started.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p>Unlike conventional <a href="https://en.wikipedia.org/wiki/Ray_tracing_(graphics)">ray-tracing</a>, ray-tracing in general relativity (GR) has the added complication that the trajectory of light is altered by the curvature of space. In particular, the spacetime around compact singularities, such as black holes, may be significantly curved in weird and wonderful ways, depending on the nature of the object being studied. When attempting to visualise or calculate observational signatures related to these objects, is important to account for so-called <em>GR effects</em>: these effects not only alter how things <em>look</em>, but also the <em>energetics</em> of the system itself.</p><p>This short getting-started guide should hopefully tour you through some of the features of Gradus.jl, and how it can be used to study accretion processes, and different spacetimes.</p><h2 id="Defining-a-spacetime"><a class="docs-heading-anchor" href="#Defining-a-spacetime">1 Defining a spacetime</a><a id="Defining-a-spacetime-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-spacetime" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Gradus.GradusBase.geodesic_equation" href="#Gradus.GradusBase.geodesic_equation"><code>Gradus.GradusBase.geodesic_equation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">geodesic_equation(m::AbstractMetric, x, v)</code></pre><p>Calculate the four-acceleration of the geodesic equation for a spacetime given by the metric <code>m</code>, four-position <code>x</code> and four-velocity <code>v</code>.</p><p>A geodesic is the shortest path connecting two points in space. For flat space, this is just a straight line. In curved space, geodesics are analogous to straight lines between points (e.g. the great circle on a sphere).</p><p>The geodesic equation calculates the acceleration experienced by a particle at position <span>$x^\mu = (t, r, \theta, \phi)$</span> travelling with tangential velocity <span>$v^\nu = \text{d} x / \text{d} \lambda$</span> due to the curvature of spacetime. The curvature is calculated from the metric, encoded in the  <a href="https://en.wikipedia.org/wiki/Christoffel_symbols">Christoffel symbols</a>. The acceleration is then calculated via</p><p class="math-container">\[\frac{\text{d}^2 x^\mu}{\text{d} \lambda^2}
    = - \Gamma^{\mu}_{\phantom{\mu}\nu\sigma}
    \frac{\text{d}x^\nu}{\text{d} \lambda}
    \frac{\text{d}x^\sigma}{\text{d} \lambda}\]</p><p>where <span>$\Gamma^{\mu}_{\phantom{\mu}\nu\sigma}$</span> are the Christoffel symbols (of the second kind), and <span>$\lambda$</span> is an affine parameter that parameterizes the solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/astro-group-bristol/Gradus.jl/blob/137e75215d60b67d5758a5e541bf2a529da81326/src/GradusBase/abstract-metric.jl#L30-L52">source</a></section></article><p>The workhorse of Gradus.jl is <a href="../api-documentation/Gradus/#Gradus.tracegeodesics"><code>tracegeodesics</code></a>. This function is responsible to setting up ordinary differential equation and solving them, either sequentially, in parallel, or on different hardware. To get started, we must minimally choose a spacetime to trace in, an initial position and an initial velocity for our test photon. </p><p>To demonstrate of the features in the library, we will choose the simplest <a href="https://en.wikipedia.org/wiki/Schwarzschild_metric">Schwarzschild spacetime</a>, which describes a spherically symmetric black hole with mass <span>$M$</span>. We will implement this metric ourselves.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Many metrics have already been implemented in Gradus.jl; for a comprehensive list, see <a href="../overview/metrics/#Catalogue-of-metrics">Catalogue of metrics</a>.</p></div></div><pre><code class="language-julia hljs">using Gradus

struct Schwarzschild{T} &lt;: AbstractStaticAxisSymmetric{T}
    M::T
end

function Gradus.metric_components(m::Schwarzschild, x)
    r, θ = x
    M = m.M

    dt2 = -(1 - (2M / r))
    dr2 = -inv(dt2)
    dθ2 = r^2
    dϕ2 = r^2 * sin(θ)^2
    dtdϕ = zero(r)

    SVector(dt2, dr2, dθ2, dϕ2, dtdϕ)
end

Gradus.inner_radius(m::Schwarzschild) = 2 * m.M</code></pre><p>Going through this line by line:</p><pre><code class="language-julia hljs">struct Schwarzschild{T} &lt;: AbstractStaticAxisSymmetric{T}
    M::T
end</code></pre><ul><li>First we define a <code>struct</code> that will parameterise our spacetime. In this case, the mass <span>$M$</span>. We declare our struct to be a <em>subtype</em> of <a href="../internals/custom-metrics/#Gradus.GradusBase.AbstractStaticAxisSymmetric"><code>AbstractStaticAxisSymmetric</code></a> since we know our metric will be static (no time dependence) and axis-symmetric (no <span>$\phi$</span> dependence). This describes the more general <a href="https://en.wikipedia.org/wiki/Petrov_classification">Petrov type D</a> class of spacetimes, and allows Gradus.jl to make a number of simplifying assumptions under the hood about how this spacetime will behave. </li><li>The <code>T</code> parameter is the number type of this metric, and dictates the precision of all numerics in the trace. Therefore, if <code>M</code> is a <code>Float32</code>, Gradus.jl will raise errors if you attempt 64-bit floating point operations when tracing. This is <em>by design</em>, since many GPU architectures prefer <code>Float32</code> for speed, especially when precision is less important, and throwing errors is preferable to debugging type coercions. </li></ul><pre><code class="language-julia hljs">function Gradus.metric_components(m::Schwarzschild, x)
    r, θ = x
    M = m.M

    dt2 = -(1 - (2M / r))
    dr2 = -inv(dt2)
    dθ2 = r^2
    dϕ2 = r^2 * sin(θ)^2
    dtdϕ = zero(r)

    SVector(dt2, dr2, dθ2, dϕ2, dtdϕ)
end</code></pre><ul><li>Here we have given the actual implementation of our metric. Since the metric is static, axis-symmetric, the position vector <code>x</code> only contains the radial and poloidal coordinates, and expects the <code>metric_components</code> function to return the five matrix elements of the metric. For the Schwarzschild metric, the <span>$\text{d}t \text{d}\phi$</span> component is zero everywhere. We set this to <code>zero(r)</code>, which is a Julia function that returns 0 but of the same type as <code>r</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Currently, Gradus.jl uses exclusively Boyer-Lindquist coordinates for its metrics. However, new coordinates can be implemented, and documentation for this will come soon.</p></div></div><pre><code class="language-julia hljs">GradusBase.inner_radius(m::KerrMetric) = 2 * m.M</code></pre><ul><li>Finally, we specify some inner radius for the integration. This is the cutoff around the origin at which radius the geodesic integration will stop to avoid numerical errors. Here, it is just the Schwarzschild radius, or the outer event horizon. Gradus.jl can calculate different horizons from the metric automatically, which can be useful if you don&#39;t know the solution ahead of time, or if the solution is non-symmetric in <span>$\theta$</span>. But if we know it, we can benefit from a small performance boost by implementing it directly.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For a full description of implementing a metric, see <a href="../internals/custom-metrics/#Implementing-a-new-metric">Implementing a new metric</a>.</p></div></div><p>If you&#39;re familiar with other GRRT softwares, you might be wondering &quot;where do we define the Christoffel symbols?&quot;, or &quot;do I not need a prescription for Carter&#39;s constant?&quot;. Thanks to <a href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation (AD)</a>, we can calculate the Christoffel symbols <em>on the fly</em>! We determine the metric Jacobian with respect to coordinates of interest, and then sparsely compute the Christoffel symbols for the given spacetime class. For full details, see <a href="../overview/geodesic-integration/#Geodesic-integration-strategies">Geodesic integration strategies</a>.</p><h2 id="Photon-trajectories"><a class="docs-heading-anchor" href="#Photon-trajectories">2 Photon trajectories</a><a id="Photon-trajectories-1"></a><a class="docs-heading-anchor-permalink" href="#Photon-trajectories" title="Permalink"></a></h2><p>The metric parameters and position can be easily and arbitrarily chosen, however the velocity has a precondition which must be satisfied.</p><article class="docstring"><header><a class="docstring-binding" id="Gradus.GradusBase.constrain" href="#Gradus.GradusBase.constrain"><code>Gradus.GradusBase.constrain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">constrain(m::AbstractMetric, x, v; μ=0)</code></pre><p>Calculate the time component <span>$v^t$</span> of a velocity vector <code>v</code>, which would constrain the vector at a position <code>x</code> as a  geodesic with invariant mass <code>μ</code>.</p><p>The velocity vector needs to only specify the <span>$v^r$</span>, <span>$v^\theta$</span>, and <span>$v^\phi$</span> component, as the <span>$v^t$</span> is constrained in GR by</p><p class="math-container">\[g_{\sigma\nu} v^\sigma v^\nu = -\mu^2,\]</p><p>where <span>$\mu^2$</span> is the invariant mass of the particle. This furthermore permits a choice of geodesic to trace. The choices correspond to</p><ul><li><code>μ = 0.0</code> (default): null geodesic</li><li><code>μ &gt; 0.0</code>: time-like geodesic</li><li><code>μ &lt; 0.0</code>: space-like geodesic</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/astro-group-bristol/Gradus.jl/blob/137e75215d60b67d5758a5e541bf2a529da81326/src/GradusBase/abstract-metric.jl#L56-L73">source</a></section></article><p>The <a href="#Gradus.GradusBase.constrain"><code>constrain</code></a> function is automatically invoked by <a href="../api-documentation/Gradus/#Gradus.tracegeodesics"><code>tracegeodesics</code></a> to normalize velocity vectors appropriately.</p><p>We&#39;ll position ourselves at a great distance from the singularity at the origin, around <span>$1000 \, r_\text{g}$</span> away. We&#39;ll furthermore setup our spacetime with an arbitrary choice of mass <code>M = 1.0</code>, which acts to rescale our system (since all units in Gradus.jl are in standard GR units).</p><p>The initial velocity vector we will somewhat arbitrarily set to be directed towards the black hole (<span>$v^r = -1$</span>), with a small <span>$v^\phi$</span> component so it grazes past the singularity.</p><p>The trajectory is calculated with a call to <a href="../api-documentation/Gradus/#Gradus.tracegeodesics"><code>tracegeodesics</code></a>:</p><pre><code class="language-julia hljs">m = Schwarzschild(1.0)
x = SVector(0.0, 1000.0, π/2, 0.0)
v = SVector(0.0, -1.0, 0.0, -8e-6)

# maximum affine time ~ 2 * x[2]
λ_max = 2000.0
sol = tracegeodesics(m, x, v, λ_max)</code></pre><p>The trajectory can be visualized with the use of <a href="https://docs.juliaplots.org/latest/">Plots.jl</a>:</p><pre><code class="language-julia hljs">using Plots

# plot solution trajectory
plot_paths(sol)
# plot 
plot_horizon!(m)</code></pre><p><img src="../figs/getting-started-1-trajectories.svg" alt/></p><p>Choosing the initial velocity in this manner lacks interpretation. We can instead use so-called <em>impact parameters</em> <span>$(\alpha, \beta)$</span>. These may be thought of as follows: </p><article class="docstring"><header><a class="docstring-binding" id="Gradus.impact_parameters_to_three_velocity" href="#Gradus.impact_parameters_to_three_velocity"><code>Gradus.impact_parameters_to_three_velocity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">impact_parameters_to_three_velocity(m::AbstractMetric, x, α, β)</code></pre><p>Return the three velocity components <span>$(v^r, v^\theta, v^\phi)$</span> corresponding to impact parameters <span>$\alpha$</span> and <span>$\beta$</span>, at position <code>x</code> for metric <code>m</code>.</p><p>For static, axis-symmetric metrics, the map is defined</p><p class="math-container">\[(\alpha, \beta) \mapsto \vec{v} =
\left(
\begin{matrix}
    -1 \
    \frac{-\beta}{g_{\theta\theta}} \
    \frac{-\alpha}{\sqrt{g_{\theta\theta} g_{\phi\phi}}} \
\end{matrix}
\right).\]</p><p>The impact parameters are interpreted as follows:</p><ul><li>if the geodesic were a straight line path, the impact parameter in a given dimension is the distance to the origin from </li></ul><p>the closest point along the geodesic in <span>$r_\text{g}$</span>.</p><p>For example, for the Schwarzschild metric with <span>$M = 1$</span>, the impact parameters <span>$(\alpha = 2, \beta = 0)$</span> would travel  tangential to the event horizon (<span>$r_\text{s} = 2M$</span>) if space were flat. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/astro-group-bristol/Gradus.jl/blob/137e75215d60b67d5758a5e541bf2a529da81326/src/tracing/utility.jl#L36-L61">source</a></section></article><p>Finally, if you imagine a two dimensional image plane, where <span>$x$</span> is the horizontal and <span>$y$</span> the vertical coordinate, the <span>$\alpha$</span> impact parameter corresponds to that closest approach along the <span>$x$</span> axis, and <span>$\beta$</span> along the <span>$y$</span> axis.</p><p>Hopefully that makes sense. With this, we can more easily setup a handful of geodesics to trace and know that they will roughly travel close to the central singularity.</p><pre><code class="language-julia hljs"># grid of impact parameters in horizontal direction
# keeping β fixed at 0
α = range(-10.0, 10.0, 30)
vs = map_impact_parameters(m, x, α, 0.0)

# need a position for each velocity vector
xs = fill(x, size(vs))

sols = tracegeodesics(m, xs, vs, λ_max)

# plot
p = plot_paths(sols, legend=false)
plot_horizon!(m, color = :black)</code></pre><p><img src="../figs/getting-started-2-multi-trajectories.svg" alt/></p><p>When we invoke <a href="../api-documentation/Gradus/#Gradus.tracegeodesics"><code>tracegeodesics</code></a> in this way, Gradus.jl will automatically distribute the workload onto as many threads as Julia was started with. For example, starting julia with</p><pre><code class="language-bash hljs">julia -t6</code></pre><p>will spawn 6 worker threads for Gradus.jl to use. Passing <code>-tauto</code> will allow Julia to use as many threads as your hardware supports.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For more about parallelism in Gradus.jl, see <a href="../internals/parallelism/#Parallelism-and-ensembles">Parallelism and ensembles</a>. </p></div></div><h2 id="Rendering-an-image"><a class="docs-heading-anchor" href="#Rendering-an-image">3 Rendering an image</a><a id="Rendering-an-image-1"></a><a class="docs-heading-anchor-permalink" href="#Rendering-an-image" title="Permalink"></a></h2><p>A common task we&#39;ll want to do is render an image; that is, assign some <span>$(\alpha, \beta)$</span> to each pixel in a 2-dimensional plane, located at the position <code>x</code>. Each pair of impact parameters is then traced along it, and its corresponding pixel coloured according to some function of the geodesic endpoint.</p><p>The simplest non-trivial thing we can do is colour the pixel by the time component of the final position. Since we are not interested in what happens to the geodesic along the path, only the start and end points, we can pass <code>save_on = false</code> to <a href="../api-documentation/Gradus/#Gradus.tracegeodesics"><code>tracegeodesics</code></a>. This tells the solvers to not save intermediary points along the solution, and thereby avoid the overhead of allocating a memory we have no wish to use.</p><pre><code class="language-julia hljs"># set up our image parameters
α = range(-10.0, 10.0, 100)
β = range(-10.0, 10.0, 100)

# this will set up a 100x100 matrix of velocity vectors
# so we use `vec` to flatten the structure
vs = vec([map_impact_parameters(m, x, a, b) for a in α, b in β])
xs = fill(x, size(vs))

# trace in parallel
sols = tracegeodesics(m, xs, vs, λ_max, save_on = false)</code></pre><p>To help us process the solutions, Gradus.jl exports a number of utility functions. There is one in specific we will want to use:</p><article class="docstring"><header><a class="docstring-binding" id="Gradus.GradusBase.process_solution" href="#Gradus.GradusBase.process_solution"><code>Gradus.GradusBase.process_solution</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">process_solution([m], sol)</code></pre><p>Unpack a solution (<code>SciMLBase.AbstractODESolution</code>) as a <a href="../api-documentation/GradusBase/#Gradus.GradusBase.GeodesicPoint"><code>GeodesicPoint</code></a>, optionally specifying the metric under which quantities are transformed. </p><p>If the solution stores any additional parameters (e.g. intensity in radiative transfer), these will be packed  into the <code>aux</code> field of <a href="../api-documentation/GradusBase/#Gradus.GradusBase.GeodesicPoint"><code>GeodesicPoint</code></a>.</p><p><strong>Example use</strong></p><pre><code class="language-julia hljs">sol = tracegeodesics(m, x, v)
point = process_solution(sol)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/astro-group-bristol/Gradus.jl/blob/137e75215d60b67d5758a5e541bf2a529da81326/src/GradusBase/geodesic-solutions.jl#L85-L100">source</a></section></article><p>The <a href="../api-documentation/GradusBase/#Gradus.GradusBase.GeodesicPoint"><code>GeodesicPoint</code></a> struct contains everything we might want to know about the start and endpoint of a geodesic solution, including four-velocities and the nature of the termination (fell into the black hole, went to infinity, collided with some geometry, etc.). </p><p>We can easily filter those geodesic that fell into the black hole, and extract their final coordinate times <span>$x^t({\lambda_\text{final}})$</span>:</p><pre><code class="language-julia hljs">points = process_solution.(sols.u)
# reshape into the same dimensions as the image
points = reshape(points, (100, 100))

times = map(points) do gp
    # check if went off the integration chart on the inner boundary
    if gp.status == StatusCodes.WithinInnerBoundary
        # get the time coordinate
        gp.x[1]
    else
        NaN
    end
end

heatmap(α, β, times, aspect_ratio = 1)</code></pre><p><img src="../figs/getting-started-3-basic-shadow.png" alt/></p><p>This is the so-called <em>shadow</em> of a black hole.</p><h2 id="Defining-and-using-PointFunctions"><a class="docs-heading-anchor" href="#Defining-and-using-PointFunctions">4 Defining and using <code>PointFunction</code>s</a><a id="Defining-and-using-PointFunctions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-and-using-PointFunctions" title="Permalink"></a></h2><p>The above is a little verbose, when all we really wanted to do trace a given grid of <span>$(\alpha, \beta)$</span>, and then compute some physical quantity at each pixel. Having to manually write out the for loop and remember to reshape the solutions array is a trifle unnecessary and error-prone. Furthermore, to someone reading our code, it may not always be obvious what physical quantity it is that we are calculating from just the <code>for</code> loop.</p><p>Gradus.jl instead uses a callback function, which in its own parlance is dubbed the <a href="../overview/point-functions/#Gradus.PointFunction"><code>PointFunction</code></a>. These functions are isolated small physical quantities, that allow us to compose a more complex observable. Many point functions have already been implemented ready for use.</p><p>As a motivating example, say we wanted to write the above as a <a href="../overview/point-functions/#Gradus.PointFunction"><code>PointFunction</code></a>:</p><pre><code class="language-julia hljs">time_coord = PointFunction((m, gp, λ) -&gt; gp.x[1])</code></pre><p>Point functions always receive the metric parameters <code>m</code>, a geodesic point <code>gp</code>, and the final time of the integration <code>λ</code>. To then filter those geodesics which fell into the event horizon, we can use a <a href="../overview/point-functions/#Gradus.FilterPointFunction"><code>FilterPointFunction</code></a> and compose them. Here, we use one of the utility methods <a href="@ref"><code>FilterStatusCode</code></a>.</p><pre><code class="language-julia hljs">filter_event_horizon = FilterStatusCode(StatusCodes.WithinInnerBoundary)
# compose in reverse order
pf = time_coord ∘ filter_event_horizon</code></pre><p>We can then apply our point function on the geodesic points:</p><pre><code class="language-julia hljs">times = pf.(m, points, λ_max)</code></pre><p>Point functions can also be used in other contexts. For example, <a href="@ref"><code>rendergeodesics</code></a> is a utility method to help render images, and one of the keywords we can pass is <code>pf</code>, so that each pixel value is coloured by the point function we gave. We can create a higher resolution render of the above easily using <a href="@ref"><code>rendergeodesics</code></a>:</p><pre><code class="language-julia hljs"># this function returns the impact parameter axes
α, β, image = rendergeodesics(
    m, 
    x,
    # no longer need to specify the velocities
    # these are automatically calculated
    λ_max, 
    pf = pf, 
    # image parameters
    image_width = 800, 
    image_height = 800,
    # the &quot;zoom&quot; -- field of view scale
    fov = 52,
    verbose = true
)

heatmap(α, β, image, aspect_ratio = 1)</code></pre><p><img src="../figs/getting-started-4-hr-shadow.png" alt/></p><p>This is good, but let&#39;s make our render a bit more interesting.</p><h3 id="Short-aside:-rendergeodesics-and-tracegeodesics"><a class="docs-heading-anchor" href="#Short-aside:-rendergeodesics-and-tracegeodesics">Short aside: <code>rendergeodesics</code> and <code>tracegeodesics</code></a><a id="Short-aside:-rendergeodesics-and-tracegeodesics-1"></a><a class="docs-heading-anchor-permalink" href="#Short-aside:-rendergeodesics-and-tracegeodesics" title="Permalink"></a></h3><p>The two functions <a href="@ref"><code>rendergeodesics</code></a> and <a href="../api-documentation/Gradus/#Gradus.tracegeodesics"><code>tracegeodesics</code></a> should be regarded as the fundamental tools that Gradus.jl provides. The former is used to create visualisations, used to <em>see</em> what is going on with your system in images. The latter is the entry point for modelling physical processes, being much more versatile than <a href="@ref"><code>rendergeodesics</code></a>, but also requiring preparatory work.</p><h2 id="Adding-geometry"><a class="docs-heading-anchor" href="#Adding-geometry">5 Adding geometry</a><a id="Adding-geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-geometry" title="Permalink"></a></h2><p>The simplest thing we can do is put a disc around our black hole and visualize that system. Gradus.jl implements many different accretion disc types, but some kind of torus would be good to start with.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>There are many different disc types already implemented, see <a href="../overview/accretion-geometry/#Available-accretion-geometry">Available accretion geometry</a>. For adding your own geometry, see <a href="../overview/accretion-geometry/#Adding-new-accretion-geometry">Adding new accretion geometry</a>.</p></div></div><p>We may be imaginative and specify our own cross-section for the disc. We need to specify the function in the positive <code>z</code> axis, and this will be mirrored in the <span>$x-y$</span> plane and rotated around the black hole.</p><p>The cross section need not be physical. Choosing some arbitrary shape, we can preview what our cross section will look like over a sample range:</p><pre><code class="language-julia hljs">function cross_section(x)
    # centered circle on 8 rg
    center = 8
    radius = 3

    if (x &lt; center - radius) || (radius + center &lt; x)
        zero(x)
    else
        r = x - center
        sqrt(radius^2 - r^2) + (0.5sin(3x))
    end
end

# preview the cross section over a sample range
sample = collect(range(0.0, 20.0, 300))
y = cross_section.(sample)

plot(sample, y, xlabel = &quot;r&quot;, ylabel = &quot;height&quot;, aspect_ratio = 1)</code></pre><p><img src="../figs/getting-started-5-cross-section.svg" alt/></p><p>We then wrap our cross section function as a <a href="../overview/accretion-geometry/#Gradus.ThickDisc"><code>ThickDisc</code></a> type:</p><pre><code class="language-julia hljs">d = ThickDisc(x -&gt; cross_section(x[2]))</code></pre><p>The thick disc callback receives the full four-position, so we forward only the radial component. </p><p>We now need to update our point function so that it filters those geodesics which intersected with the geometry instead of those that fell into the black hole. This is a standard function already implemented in <a href="../overview/point-functions/#Gradus.ConstPointFunctions"><code>ConstPointFunctions</code></a>; only a composition is needed:</p><pre><code class="language-julia hljs">pf_geometry = time_coord ∘ ConstPointFunctions.filter_intersected</code></pre><p>We then make a handful of small changes to make our image more interesting, and render just as before, passing the disc in to the <a href="@ref"><code>rendergeodesics</code></a> function:</p><pre><code class="language-julia hljs"># change inclination
x = SVector(0.0, 1000.0, deg2rad(70), 0.0)

α, β, image = rendergeodesics(
    m, 
    x,
    # add the disc argument
    d,
    λ_max, 
    # new point function
    pf = pf_geometry, 
    # slightly wider image
    image_width = 1200, 
    image_height = 800,
    # zoom out a little
    fov = 22,
    verbose = true
)

heatmap(α, β, image, aspect_ratio = 1)</code></pre><p><img src="../figs/getting-started-6-weird-disc-render.png" alt/></p><h2 id="Calculating-physical-quantities"><a class="docs-heading-anchor" href="#Calculating-physical-quantities">6 Calculating physical quantities</a><a id="Calculating-physical-quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-physical-quantities" title="Permalink"></a></h2><p>A common quantity to look at when ray tracing is the <em>redshift</em> of a photon; that is, the ratio of the energy where the photon was emitted to where it was observed. Mathematically, this is the quantity</p><p class="math-container">\[g = \frac{\left. k_\mu u^\mu \right\rvert_\text{obs}}{\left. k_\nu u^\nu \right\rvert_\text{em}},\]</p><p>where the subscript denote the observer and emitters position respectively. Here, <span>$k_\mu$</span> is the covariant momentum of the photon, and <span>$u^\mu$</span> is the velocity of the disc patch, or of the observer respectively. </p><p>We can choose any velocity profile we like, but for simplicity we use the velocity of the stable circular orbit at the corresponding radius where the photon hit the disc. The above formula for the redshift <span>$g$</span> is already implemented with this velocity profile for us – we need only specify which spacetime we are in and where our observer is positioned:</p><pre><code class="language-julia hljs">redshift = ConstPointFunctions.redshift(m, x)
# compose to filter those that intersected with the geometry
redshift_geometry = redshift ∘ ConstPointFunctions.filter_intersected</code></pre><p>This is another <a href="../overview/point-functions/#Gradus.PointFunction"><code>PointFunction</code></a>, and is used in the same way. Rendering as before:</p><pre><code class="language-julia hljs">α, β, image = rendergeodesics(
    m, 
    x,
    d,
    λ_max, 
    # new point function
    pf = redshift_geometry,
    image_width = 1200, 
    image_height = 800,
    fov = 22,
    verbose = true
)

heatmap(α, β, image, aspect_ratio = 1)</code></pre><p><img src="../figs/getting-started-7-weird-redshift.png" alt/></p><h2 id="Changing-metric"><a class="docs-heading-anchor" href="#Changing-metric">7 Changing metric</a><a id="Changing-metric-1"></a><a class="docs-heading-anchor-permalink" href="#Changing-metric" title="Permalink"></a></h2><p>To change the metric, we need only pass a new metric to <a href="../overview/point-functions/#Gradus.ConstPointFunctions.redshift"><code>ConstPointFunctions.redshift</code></a> to update how the redshift is calculated, and to <a href="@ref"><code>rendergeodesics</code></a> to update how the geodesic equation is integrated. To switch to e.g. the Johannsen (2013)<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> metric, the following modifications are needed:</p><pre><code class="language-julia hljs">j_m = JohannsenMetric(M=1.0, a = 0.7, α13 = 2.0, ϵ3 = 1.0)

# pass the new metric
j_redshift = ConstPointFunctions.redshift(j_m, x)
j_redshift_geometry = j_redshift ∘ ConstPointFunctions.filter_intersected

α, β, image = rendergeodesics(
    # pass the new metric
    j_m, 
    x,
    d,
    λ_max, 
    # and the new point function
    pf = j_redshift_geometry,
    image_width = 1200, 
    image_height = 800,
    fov = 22,
    verbose = true
)

heatmap(α, β, image, aspect_ratio = 1)</code></pre><p><img src="../figs/getting-started-8-jm-weird-redshift.png" alt/></p><h2 id="Calculating-line-profiles"><a class="docs-heading-anchor" href="#Calculating-line-profiles">8 Calculating line profiles</a><a id="Calculating-line-profiles-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-line-profiles" title="Permalink"></a></h2><p>As a final step, we can calculate the line profile of emission from our system with the Johannsen metric. We can compare this to the case where the disc is geometrically thin in the equatorial plane, and furthermore compare this to the Schwarzschild spacetime.</p><p>Line profiles are calculated with <a href="@ref"><code>lineprofile</code></a>, a function that accepts much the same arguments as the previous tracing and rendering functions. We will also limit the domain of the integration to in the upper hemisphere only – thereby avoiding any false images in our line profile calculations. This choice is physically motiviated, as the gaps in the inner regions of the disc are often assumed to be opaque due to extreme ionization of the matter.</p><p>Domain limiting can be done by adding a callback to the integrator.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For more on using callbacks and finer control of the integrator, see <a href="../overview/geodesic-integration/#Using-callbacks">Using callbacks</a>.</p></div></div><pre><code class="language-julia hljs"># define custom bins for g
bins = collect(range(0.1, 1.4, 200))

# define the plane to perform the binning over
plane = PolarPlane(GeometricGrid(); Nr = 1000, Nθ = 1000, r_max = 50.0)</code></pre><p>In the line above we created an explicit <a href="@ref"><code>PolarPlane</code></a>, since we no longer wish to integrate on a rectangular grid. We want to primarily sample the region close to the event horizon where all of the interesting physics is taking place, and as such we scale the radial coordinate geometrically. Adjusting <code>Nr</code> and <code>Nθ</code> lets us control the &quot;resolution&quot; of our render, and will smoothen the line profiles. The values chosen here are to balance resolution and computational time (~ 30 seconds on a 2021 M1 Mac laptop).</p><p>We can preview what the grid will look like (though at lower resolution to avoid unnecessary noise):</p><pre><code class="language-julia hljs">plot(
    PolarPlane(GeometricGrid(); Nr = 10, Nθ = 20, r_max = 50.0)
)</code></pre><p><img src="../figs/getting-started-9-polar-plane.svg" alt/></p><p>Each point on this plane represent a photon which will be traced, and the intensity scaled according to the area the point covers on the image plane.</p><p>With that, we are ready to calculate the line profiles. To avoid having to reuse large parts of our code, we can write a short function that wraps <a href="@ref"><code>lineprofile</code></a>:</p><pre><code class="language-julia hljs">function calculate_line_profile(m, x, d, bins, plane)
    _, f = lineprofile(
        m, 
        x, 
        d, 
        algorithm = BinnedLineProfile(), 
        # no false images
        callback = domain_upper_hemisphere(),
        verbose = true,
        bins = bins,
        plane = plane,
    )
    return f
end</code></pre><p>Note that <a href="@ref"><code>lineprofile</code></a> returns both the redshift <span>$g$</span> (bins) and flux at each <span>$g$</span>. Since we specified the binning, we can ignore the first return value, and keep only the flux.</p><pre><code class="language-julia hljs">d_j_thin = GeometricThinDisc(Gradus.isco(j_m), 200.0, π / 2)
# and for the schwarzschild metric
d_s_thin = GeometricThinDisc(Gradus.isco(m), 200.0, π / 2)

f_j_thick_disc = calculate_line_profile(j_m, x, d, bins, plane)
f_s_thick_disc = calculate_line_profile(m, x, d, bins, plane)
f_j_thin_disc = calculate_line_profile(j_m, x, d_j_thin, bins, plane)
f_s_thin_disc = calculate_line_profile(m, x, d_s_thin, bins, plane)

plot(bins, f_j_thick_disc, label = &quot;Johannsen[thick]&quot;)
plot!(bins, f_s_thick_disc, label = &quot;Schwarzschild[thick]&quot;)
plot!(bins, f_j_thin_disc, label = &quot;Johannsen[thin]&quot;)
plot!(bins, f_s_thin_disc, label = &quot;Schwarzschild[thin]&quot;)</code></pre><p><img src="../figs/getting-started-10-line-profiles.svg" alt/></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For how to use these line profiles and other observables in fitting programs, see <a href="../overview/exports/#Exporting-data-products">Exporting data products</a>.</p></div></div><h2 id="Where-to-go-from-here?"><a class="docs-heading-anchor" href="#Where-to-go-from-here?">Where to go from here?</a><a id="Where-to-go-from-here?-1"></a><a class="docs-heading-anchor-permalink" href="#Where-to-go-from-here?" title="Permalink"></a></h2><p>The documentation is a rich resource for information related to using Gradus, and tailoring the toolkit for your needs. Take a look at <a href="../examples/examples/#Examples">Examples</a> for a number of quick recipes, or try <a href="../internals/custom-metrics/#Implementing-a-new-metric">Implementing a new metric</a> and study a different spacetime.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Johannsen, Tim. ‘Regular Black Hole Metric with Three Constants of Motion’. Physical Review D 88, no. 4 (1 August 2013): 044002. https://doi.org/10.1103/PhysRevD.88.044002.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../problems-and-solvers/">Problems and solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 23 March 2023 17:44">Thursday 23 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
