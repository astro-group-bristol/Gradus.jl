<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · Gradus.jl Documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Gradus.jl Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Gradus.jl Documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Overview</span><ul><li class="is-active"><a class="tocitem" href>Getting started</a><ul class="internal"><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Defining-a-spacetime"><span>Defining a spacetime</span></a></li><li><a class="tocitem" href="#Photon-trajectories"><span>Photon trajectories</span></a></li><li><a class="tocitem" href="#Rendering-an-image"><span>Rendering an image</span></a></li><li><a class="tocitem" href="#Defining-and-using-PointFunctions"><span>Defining and using <code>PointFunction</code>s</span></a></li><li><a class="tocitem" href="#Adding-geometry"><span>Adding geometry</span></a></li><li><a class="tocitem" href="#Calculating-physical-quantities"><span>Calculating physical quantities</span></a></li><li><a class="tocitem" href="#Changing-metric"><span>Changing metric</span></a></li><li><a class="tocitem" href="#Calculating-line-profiles"><span>Calculating line profiles</span></a></li><li><a class="tocitem" href="#Where-to-go-from-here?"><span>Where to go from here?</span></a></li></ul></li><li><a class="tocitem" href="../problems-and-solvers/">Problems and solvers</a></li><li><a class="tocitem" href="../overview/point-functions/">Point functions</a></li><li><a class="tocitem" href="../overview/metrics/">Available metrics</a></li><li><a class="tocitem" href="../overview/accretion-geometry/">Accretion geometry</a></li><li><a class="tocitem" href="../examples/examples/">Examples</a></li></ul></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../overview/geodesic-integration/">Geodesic integration</a></li><li><a class="tocitem" href="../internals/custom-metrics/">Implementing new metrics</a></li><li><a class="tocitem" href="../internals/special-radii/">Special radii</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../api-documentation/Gradus/">Gradus</a></li><li><a class="tocitem" href="../api-documentation/GradusBase/">GradusBase</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Overview</a></li><li class="is-active"><a href>Getting started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/astro-group-bristol/Gradus.jl/blob/main/docs/src/getting-started.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p>Unlike conventional <a href="https://en.wikipedia.org/wiki/Ray_tracing_(graphics)">ray-tracing</a>, ray-tracing in general relativity (GR) has the added complication that the trajectory of light is altered by the curvature of space. In particular, the spacetime around compact singularities, such as black holes, may be significantly curved in weird and wonderful ways, depending on the nature of the object being studied. When attempting to visualise or calculate observational signatures related to these objects, is important to account for so-called <em>GR effects</em>; these effects not only alter how things <em>look</em>, but also the <em>energetics</em> of the system itself.</p><p>This short getting-started guide should hopefully illustrate some of the key ideas that need to be kept in mind when studying accretion processes and simulating spectra of black holes.</p><h2 id="Defining-a-spacetime"><a class="docs-heading-anchor" href="#Defining-a-spacetime">Defining a spacetime</a><a id="Defining-a-spacetime-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-spacetime" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Gradus.GradusBase.geodesic_equation" href="#Gradus.GradusBase.geodesic_equation"><code>Gradus.GradusBase.geodesic_equation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">geodesic_equation(m::AbstractMetricParameters, x, v)</code></pre><p>Calculate the four-acceleration of the geodesic equation for a spacetime given by the metric <code>m</code>, four-position <code>x</code> and four-velocity <code>v</code>.</p><p>A geodesic is the shortest path connecting two points in space. For flat space, this is just a straight line. In curved space, geodesics are analogous to straight lines between points (e.g. the great circle on a sphere).</p><p>The geodesic equation calculates the acceleration experienced by a particle at position <span>$x^\mu = (t, r, \theta, \phi)$</span> travelling with tangential velocity <span>$v^\nu = \text{d} x / \text{d} \lambda$</span> due to the curvature of spacetime. The curvature is calculated from the metric, encoded in the  <a href="https://en.wikipedia.org/wiki/Christoffel_symbols">Christoffel symbols</a>. The acceleration is then calculated via</p><p class="math-container">\[\frac{\text{d}^2 x^\mu}{\text{d} \lambda^2}
    = - \Gamma^{\mu}_{\phantom{\mu}\nu\sigma}
    \frac{\text{d}x^\nu}{\text{d} \lambda}
    \frac{\text{d}x^\sigma}{\text{d} \lambda}\]</p><p>where <span>$\Gamma^{\mu}_{\phantom{\mu}\nu\sigma}$</span> are the Christoffel symbols (of the second kind), and <span>$\lambda$</span> is an affine parameter that parameterizes the solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/astro-group-bristol/Gradus.jl/blob/0142d26ebb955f6d9d8ff05e631d6adc681c8a02/src/GradusBase/metric-params.jl#L32-L54">source</a></section></article><p>All the heavy lifting in Gradus.jl is done by <a href="../api-documentation/Gradus/#Gradus.tracegeodesics"><code>tracegeodesics</code></a>. Minimally, we must choose a spacetime to trace in, and some initial position and velocity for our test photon. </p><p>Let&#39;s pick the <a href="https://en.wikipedia.org/wiki/Schwarzschild_metric">Schwarzschild spacetime</a>, which describes a spherically symmetric black hole with mass <span>$M$</span>. Many metrics have already been implemented in Gradus.jl (see <a href="../overview/metrics/#Available-metrics">Available metrics</a>), but for illustration, we&#39;ll implement the metric ourselves:</p><pre><code class="language-julia hljs">using Gradus

struct Schwarzschild{T} &lt;: AbstractStaticAxisSymmetricParameters{T}
    M::T
end

function Gradus.metric_components(m::Schwarzschild, x)
    r, θ = x
    M = m.M

    dt2 = -(1 - (2M / r))
    dr2 = -inv(dt2)
    dθ2 = r^2
    dϕ2 = r^2 * sin(θ)^2
    dtdϕ = zero(r)

    SVector(dt2, dr2, dθ2, dϕ2, dtdϕ)
end

Gradus.inner_radius(m::Schwarzschild) = 2 * m.M</code></pre><p>Going through this line by line:</p><pre><code class="language-julia hljs">struct Schwarzschild{T} &lt;: AbstractStaticAxisSymmetricParameters{T}
    M::T
end</code></pre><ul><li>First we define a <code>struct</code> that will hold the quantities parameterizing our spacetime. In this case, just the mass <span>$M$</span>. We declare our struct to be a <em>subtype</em> of <code>AbstractStaticAxisSymmetricParameters</code> since we know our metric will be static (no time dependence) and axis-symmetric (no <span>$\phi$</span> dependence). This describes the more general <a href="https://en.wikipedia.org/wiki/Petrov_classification">Petrov type D</a> class of spacetimes, and allows Gradus.jl to make a number of simplifying assumptions under the hood about how this spacetime will behave. The <code>T</code> parameter is the number type of this metric, and dictates the precision of all numerics in the trace. Therefore, if <code>M</code> is a <code>Float32</code>, Gradus.jl will raise errors if you attempt 64-bit floating point operations when tracing. This is <em>by design</em>, since many GPU architectures prefer <code>Float32</code> for speed, especially when precision is less important, and throwing errors is preferable to debugging type coercions. </li></ul><pre><code class="language-julia hljs">function Gradus.metric_components(m::Schwarzschild, x)
    r, θ = x
    M = m.M

    dt2 = -(1 - (2M / r))
    dr2 = -inv(dt2)
    dθ2 = r^2
    dϕ2 = r^2 * sin(θ)^2
    dtdϕ = zero(r)

    SVector(dt2, dr2, dθ2, dϕ2, dtdϕ)
end</code></pre><ul><li>Here we have given the actual implementation of our metric. Since the metric is static, axis-symmetric, the position vector <code>x</code> only contains the radial and poloidal coordinates, and expects the <code>metric_components</code> function to return the five matrix elements of the metric. For the Schwarzschild metric, the <span>$\text{d}t \text{d}\phi$</span> component is zero everywhere, so we set this to <code>zero(r)</code>, which returns 0 but of the same type as <code>r</code>.</li></ul><pre><code class="language-julia hljs">GradusBase.inner_radius(m::KerrMetric) = 2 * m.M</code></pre><ul><li>Finally, we specify some inner radius for the integration. This is the cutoff around the origin at which radius the geodesic integration will stop to avoid numerical errors. Gradus.jl can also calculate the outer horizon of the metric automatically, which can be useful if you don&#39;t know the solution ahead of time, or if the solution is non-symmetric in <span>$\theta$</span>, but is generally slower than providing a simple prescription.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For a full description of implementing a metric, see <a href="../internals/custom-metrics/#Implementing-a-new-metric">Implementing a new metric</a>.</p></div></div><p>If you&#39;re familiar with other GRRT softwares, you might be wondering &quot;where do we define the Christoffel symbols?&quot;, or &quot;do I not need a prescription for Carter&#39;s constant?&quot;. Thanks to <a href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation (AD)</a>, we can calculate the Christoffel symbols <em>on the fly</em>! We determine the metric Jacobian with respect to coordinates of interest, and then sparsely compute the Christoffel symbols for the given spacetime class. For full details, see <a href="../overview/geodesic-integration/#Geodesic-integration-strategies">Geodesic integration strategies</a>.</p><h2 id="Photon-trajectories"><a class="docs-heading-anchor" href="#Photon-trajectories">Photon trajectories</a><a id="Photon-trajectories-1"></a><a class="docs-heading-anchor-permalink" href="#Photon-trajectories" title="Permalink"></a></h2><p>We need to instantiate the metric, and provide a position and velocity four-vector in order to trace a geodesic path. </p><article class="docstring"><header><a class="docstring-binding" id="Gradus.GradusBase.constrain" href="#Gradus.GradusBase.constrain"><code>Gradus.GradusBase.constrain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">constrain(m::AbstractMetricParameters, x, v; μ=0)</code></pre><p>Calculate the time component <span>$v^t$</span> of a velocity vector <code>v</code>, which would constrain the vector at a position <code>x</code> as a  geodesic with invariant mass <code>μ</code>.</p><p>The velocity vector needs to only specify the <span>$v^r$</span>, <span>$v^\theta$</span>, and <span>$v^\phi$</span> component, as the <span>$v^t$</span> is constrained in GR by</p><p class="math-container">\[g_{\sigma\nu} v^\sigma v^\nu = -\mu^2,\]</p><p>where <span>$\mu^2$</span> is the invariant mass of the particle. This furthermore permits a choice of geodesic to trace. The choices correspond to</p><ul><li><code>μ = 0.0</code> (default): null geodesic</li><li><code>μ &gt; 0.0</code>: time-like geodesic</li><li><code>μ &lt; 0.0</code>: space-like geodesic</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/astro-group-bristol/Gradus.jl/blob/0142d26ebb955f6d9d8ff05e631d6adc681c8a02/src/GradusBase/metric-params.jl#L58-L75">source</a></section></article><p>We&#39;ll position ourselves at a great distance from the singularity at the origin, around <span>$1000 \, r_\text{g}$</span> away. We&#39;ll furthermore setup our spacetime with an arbitrary choice of mass <code>M = 1.0</code>, which acts to rescale our system (since all units in Gradus.jl are in standard GR units).</p><p>The initial velocity vector we&#39;ll somewhat arbitrary set to point towards the black hole, with a small <span>$v^\phi$</span> component so it is slightly offset.</p><p>The trajectory is then calculated with a call to <a href="../api-documentation/Gradus/#Gradus.tracegeodesics"><code>tracegeodesics</code></a>:</p><pre><code class="language-julia hljs">m = Schwarzschild(1.0)
x = SVector(0.0, 1000.0, π/2, 0.0)
v = SVector(0.0, -1.0, 0.0, -8e-6)

# maximum affine time ~ 2 * x[2]
λ_max = 2000.0
sol = tracegeodesics(m, x, v, λ_max)</code></pre><p>The trajectory can be plotted with the use of <a href="https://docs.juliaplots.org/latest/">Plots.jl</a>:</p><pre><code class="language-julia hljs">using Plots

# plot solution trajectory
plot_paths(sol)
# plot 
plot_horizon!(m)</code></pre><p><img src="../figs/getting-started-1-trajectories.svg" alt/></p><p>To the initial velocity a little bit more interpretable, we use so-called <em>impact parameters</em> <span>$(\alpha, \beta)$</span>. These may be thought of as follows: if the geodesic were a straight line path, the impact parameter in a given dimension is the distance to the origin from the closest point along the geodesic in <span>$r_\text{g}$</span>.</p><p>If you imagine a two dimensional image plane, where <span>$x$</span> is the horizontal and <span>$y$</span> the vertical coordinate, the <span>$\alpha$</span> impact parameter corresponds to that closest approach along the <span>$x$</span> axis, and vice versa for <span>$\beta$</span>.</p><p>With this, we can more easily setup a handful of geodesics to trace:</p><pre><code class="language-julia hljs"># grid of impact parameters in horizontal direction
# keeping β fixed at 0
α = range(-10.0, 10.0, 30)
vs = map_impact_parameters(m, x, α, 0.0)

# need a position for each velocity vector
xs = fill(x, size(vs))

sols = tracegeodesics(m, xs, vs, 2000.0)

# plot
p = plot_paths(sols, legend=false)
plot_horizon!(m, color = :black)</code></pre><p><img src="../figs/getting-started-2-multi-trajectories.svg" alt/></p><p>When we invoke <a href="../api-documentation/Gradus/#Gradus.tracegeodesics"><code>tracegeodesics</code></a> in this way, Gradus.jl will automatically distribute the workload onto as many threads as Julia was started with. For example, starting julia with</p><pre><code class="language-bash hljs">julia -t6</code></pre><p>will spawn 6 worker threads for Gradus.jl to use. Passing <code>-tauto</code> will allow Julia to use as many threads as your hardware supports.</p><h2 id="Rendering-an-image"><a class="docs-heading-anchor" href="#Rendering-an-image">Rendering an image</a><a id="Rendering-an-image-1"></a><a class="docs-heading-anchor-permalink" href="#Rendering-an-image" title="Permalink"></a></h2><p>A common task we&#39;ll want to do is render an image; that is, assign some <span>$(\alpha, \beta)$</span> to each pixel in a 2-dimensional plane at the position <code>x</code>, and trace along it, colouring the pixel according to some function of where the geodesic ends up.</p><p>The simplest thing we can do is colour the pixel by the time component of the final position. Since we don&#39;t care about what happens to the geodesic inbetween the path, we&#39;ll pass <code>save_on = false</code> to <a href="../api-documentation/Gradus/#Gradus.tracegeodesics"><code>tracegeodesics</code></a> to avoid the overhead of allocating a whole load of memory we don&#39;t want to use.</p><pre><code class="language-julia hljs"># set up our image parameters
α = range(-10.0, 10.0, 100)
β = range(-10.0, 10.0, 100)

# this will set up a 100x100 matrix of velocity vectors
# so we use `vec` to flatten the structure
vs = vec([map_impact_parameters(m, x, a, b) for a in α, b in β])
xs = fill(x, size(vs))

# trace in parallel
sols = tracegeodesics(m, xs, vs, 2000.0, save_on = false)</code></pre><p>To help us process the solutions, Gradus.jl exports <a href="../api-documentation/GradusBase/#Gradus.GradusBase.process_solution-Union{Tuple{T}, Tuple{Any, SciMLBase.AbstractODESolution{T}}} where T"><code>process_solution</code></a>, which returns a <a href="../api-documentation/GradusBase/#Gradus.GradusBase.GeodesicPoint"><code>GeodesicPoint</code></a> per solution. The struct contains everything we might want to know about the start and endpoint of a geodesic solution, including the four-velocity, and the nature of the termination (fell into the black hole, went to infinity, collided with some geometry, etc.). </p><p>Let&#39;s filter those that fell into the black hole, and extract their final coordinate times <span>$x^t |_\text{final}$</span>:</p><pre><code class="language-julia hljs">points = process_solution.(sols.u)
# reshape into the same dimensions as the image
points = reshape(points, (100, 100))

times = map(points) do gp
    # check if went off the integration chart on the inner boundary
    if gp.status == StatusCodes.WithinInnerBoundary
        # get the time coordinate
        gp.x[1]
    else
        NaN
    end
end

heatmap(α, β, times, aspect_ratio = 1)</code></pre><p><img src="../figs/getting-started-3-basic-shadow.png" alt/></p><p>This is the so-called <em>shadow</em> of a black hole.</p><h2 id="Defining-and-using-PointFunctions"><a class="docs-heading-anchor" href="#Defining-and-using-PointFunctions">Defining and using <code>PointFunction</code>s</a><a id="Defining-and-using-PointFunctions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-and-using-PointFunctions" title="Permalink"></a></h2><p>What we did above was quite verbose, when all we really wanted to do was give a grid of <span>$(\alpha, \beta)$</span>, and then compute some physical quantity at each pixel. Having to manually write out the for loop and remember to reshape the solutions array is a trifle unnecessary. Furthermore, to someone reading out code it may not always be obvious what physical quantity it is that we are calculating from just the <code>for</code> loop.</p><p>Gradus.jl instead uses a callback function, which in its own parlance is dubbed the <a href="../overview/point-functions/#Gradus.PointFunction"><code>PointFunction</code></a>. These functions are isolated small physical quantities, that allow us to compose a more complex observable. Many point functions have already been implemented ready for use.</p><p>As a motivating example, say we wanted to write the above as a [<code>PointFunction</code>]:</p><pre><code class="language-julia hljs">time_coord = PointFunction((m, gp, λ) -&gt; gp.x[1])</code></pre><p>Point function always receive the metric parameters <code>m</code>, a geodesic point <code>gp</code>, and the final time of the integration <code>λ</code>. To then filter those geodesics which fell into the event horizon, we can use a <a href="../overview/point-functions/#Gradus.FilterPointFunction"><code>FilterPointFunction</code></a> and compose them. Here, we&#39;ll use one of the utility methods <a href="@ref"><code>FilterStatusCode</code></a>.</p><pre><code class="language-julia hljs">filter_event_horizon = FilterStatusCode(StatusCodes.WithinInnerBoundary)
# compose in reverse order
pf = time_coord ∘ filter_event_horizon</code></pre><p>We can then apply our point function on our geodesic points:</p><pre><code class="language-julia hljs">times = pf.(m, points, 2000.0)</code></pre><p>Point functions can also be used in other contexts. For example, <a href="@ref"><code>rendergeodesics</code></a> is a utility method to help render images, and one of the keywords we can pass is <code>pf</code>, so that each pixel value is coloured by the point function we gave. For example, lets create a higher resolution shadow render using <a href="@ref"><code>rendergeodesics</code></a>:</p><pre><code class="language-julia hljs"># this function returns the impact parameter axes
α, β, image = rendergeodesics(
    m, 
    x,
    # no longer need to specify the velocities
    # these are automatically calculated
    2000.0, 
    pf = pf, 
    # image parameters
    image_width = 800, 
    image_height = 800,
    # the &quot;zoom&quot; -- field of view scale
    fov = 52,
    verbose = true
)

heatmap(α, β, image, aspect_ratio = 1)</code></pre><p><img src="../figs/getting-started-4-hr-shadow.png" alt/></p><p>This is good, but let&#39;s make our render a bit more interesting.</p><h2 id="Adding-geometry"><a class="docs-heading-anchor" href="#Adding-geometry">Adding geometry</a><a id="Adding-geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-geometry" title="Permalink"></a></h2><p>The simplest thing we can do is put a disc around our black hole and visualize what that would look like. Gradus.jl implements many different accretion disc types (see also <a href="../overview/accretion-geometry/#Adding-new-accretion-geometry">Adding new accretion geometry</a>). Some kind of torus would be good to start with.</p><p>We&#39;ll be imaginative and specify our own cross-section for the disc. We need to specify the function in the positive <code>z</code> axis, and this will be flipped and rotated around the black hole. Where we don&#39;t want our disc to exist, we return 0. </p><p>Choosing an interesting function, we can also quickly preview what the cross section will look like over a sample range:</p><pre><code class="language-julia hljs">function cross_section(x)
    # centered circle on 12 rg
    center = 15
    radius = 4

    if (x &lt; center - radius) || (radius + center &lt; x)
        zero(x)
    else
        r = x - center
        sqrt(radius^2 - r^2) + (0.5sin(3x))
    end
end

# preview the cross section over a sample range
sample = collect(range(1.0, 30.0, 300))
y = cross_section.(sample)

p = plot(sample, y, xlabel = &quot;r&quot;, ylabel = &quot;height&quot;)</code></pre><p><img src="../figs/getting-started-5-cross-section.svg" alt/></p><p>We then just need to wrap our cross section function as a thick disc type:</p><pre><code class="language-julia hljs">d = ThickDisc(x -&gt; cross_section(x[2]))</code></pre><p>The thick disc callback gets the full four-position, so we forward only the radial component. This does mean, however, that it would be very simple to implement a time-dependent disc structure if one wanted to, and have the Shapiro delay built in. </p><p>Next, we update our point function so that it filters those geodesics which intersected with the geometry instead of those that fell into the black hole. This is a standard function already implemented for us in <a href="../overview/point-functions/#Gradus.ConstPointFunctions"><code>ConstPointFunctions</code></a>, so we can just compose with:</p><pre><code class="language-julia hljs">pf_geometry = time_coord ∘ ConstPointFunctions.filter_intersected</code></pre><p>We&#39;ll then make a handful of small changes to make our image more interesting, and render just as before, passing the disc in to the <a href="@ref"><code>rendergeodesics</code></a> function:</p><pre><code class="language-julia hljs"># change inclination
x = SVector(0.0, 1000.0, deg2rad(70), 0.0)

α, β, image = rendergeodesics(
    m, 
    x,
    # add the disc argument
    d,
    2000.0, 
    # new point function
    pf = pf_geometry, 
    # slightly wider image
    image_width = 1200, 
    image_height = 800,
    # zoom out a little
    fov = 22,
    verbose = true
)

heatmap(α, β, image, aspect_ratio = 1)</code></pre><p><img src="../figs/getting-started-6-weird-disc-render.png" alt/></p><h2 id="Calculating-physical-quantities"><a class="docs-heading-anchor" href="#Calculating-physical-quantities">Calculating physical quantities</a><a id="Calculating-physical-quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-physical-quantities" title="Permalink"></a></h2><p>A common quantity to look at when ray tracing is the <em>redshift</em> of a photon; that is, the ratio of the energy where the photon was emitted to where it was observed. Mathematically, this is the quantity</p><p class="math-container">\[g = \frac{\left. k_\mu u^\mu \right\rvert_\text{obs}}{\left. k_\nu u^\nu \right\rvert_\text{em}},\]</p><p>where the subscript denote the observer and emitter respectively. Here, <span>$k_\mu$</span> is the covariant momentum of the photon, and <span>$u^\mu$</span> is the velocity of the patch of the disc or observer respectively. </p><p>We can choose any velocity profile we like, but for simplicity we&#39;ll use the velocity of the stable circular orbit at the corresponding radius where the photon hit the disc. The above formula for the redshift <span>$g$</span> is already implemented with this velocity profile for us – we need only specify which spacetime we are in and where our observer is positioned:</p><pre><code class="language-julia hljs">redshift = ConstPointFunctions.redshift(m, x)
# compose to filter those that intersected with the geometry
redshift_geometry = redshift ∘ ConstPointFunctions.filter_intersected</code></pre><p>This is just another <a href="../overview/point-functions/#Gradus.PointFunction"><code>PointFunction</code></a>, and can be used in the same way. Rendering as before:</p><pre><code class="language-julia hljs">α, β, image = rendergeodesics(
    m, 
    x,
    d,
    2000.0, 
    # new point function
    pf = redshift_geometry,
    image_width = 1200, 
    image_height = 800,
    fov = 22,
    verbose = true
)

heatmap(α, β, image, aspect_ratio = 1)</code></pre><p><img src="../figs/getting-started-7-weird-redshift.png" alt/></p><h2 id="Changing-metric"><a class="docs-heading-anchor" href="#Changing-metric">Changing metric</a><a id="Changing-metric-1"></a><a class="docs-heading-anchor-permalink" href="#Changing-metric" title="Permalink"></a></h2><p>To change the metric, we need only pass a new metric to <a href="../overview/point-functions/#Gradus.ConstPointFunctions.redshift"><code>ConstPointFunctions.redshift</code></a> to update how the redshift is being calculated, and to <a href="@ref"><code>rendergeodesics</code></a> to update how the geodesic equation is being integrated. Let&#39;s switch to the Johannsen (2013)<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> metric for testing gravity:</p><pre><code class="language-julia hljs">j_m = JohannsenMetric(M=1.0, a = 0.7, α13 = 2.0, ϵ3 = 1.0)

# pass the new metric
j_redshift = ConstPointFunctions.redshift(j_m, x)
j_redshift_geometry = j_redshift ∘ ConstPointFunctions.filter_intersected

α, β, image = rendergeodesics(
    # pass the new metric
    j_m, 
    x,
    d,
    2000.0, 
    # and the new point function
    pf = j_redshift_geometry,
    image_width = 1200, 
    image_height = 800,
    fov = 22,
    verbose = true
)

heatmap(α, β, image, aspect_ratio = 1)</code></pre><p><img src="../figs/getting-started-8-jm-weird-redshift.png" alt/></p><h2 id="Calculating-line-profiles"><a class="docs-heading-anchor" href="#Calculating-line-profiles">Calculating line profiles</a><a id="Calculating-line-profiles-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-line-profiles" title="Permalink"></a></h2><p>As a final step, lets take our system and calculate what the line profile is. We&#39;ll compare this to the case where the disc is geometrically thin in the equatorial plane.</p><p>We can do this with <a href="@ref"><code>lineprofile</code></a>, which accepts much the same arguments as the previous tracing and rendering functions. We&#39;re also going to limit the domain of the integration to in the upper hemisphere only – thereby avoiding any false images in our line profile calculations.</p><pre><code class="language-julia hljs"># define custom bins for g
bins = collect(range(0.1, 1.4, 200))

# define the plane to perform the binning over
plane = PolarPlane(GeometricGrid(); Nr = 700, Nθ = 1300, r_max = 50.0)</code></pre><p>In the line above we created an explicit image plane, since we no longer wish to integrate on a rectangular grid. We want to primarily sample the region close to the event horizon where all of the interesting physics is taking place, and as such we scale the radial coordinate geometrically. We can even preview what the grid will look like (though lower resolution to avoid unnecessary noise):</p><pre><code class="language-julia hljs">plot(
    PolarPlane(GeometricGrid(); Nr = 10, Nθ = 20, r_max = 50.0)
)</code></pre><p><img src="../figs/getting-started-9-polar-plane.svg" alt/></p><p>Each point on this plane represent a photon which will be traced, and the intensity scaled according to the area the point covers on the image plane.</p><p>With that, we are ready to calculate the line profiles:</p><pre><code class="language-julia hljs">_, f = lineprofile(
    j_m, 
    x, 
    d, 
    algorithm = BinnedLineProfile(), 
    # no false images
    callback = domain_upper_hemisphere(),
    verbose = true,
    bins = bins,
    plane = plane,
)

# geometric thin disc in the equitorial plane
d_thin = GeometricThinDisc(Gradus.isco(j_m), 200.0, π/2)

_, f_thin = lineprofile(
    j_m, 
    x, 
    # new disc
    d_thin, 
    algorithm = BinnedLineProfile(), 
    callback = domain_upper_hemisphere(),
    verbose = true,
    bins = bins,
    plane = plane,
)

p = plot(bins, f, label = &quot;thick&quot;)
plot!(bins, f_thin, label = &quot;thin&quot;)</code></pre><p><img src="../figs/getting-started-10-line-profiles.svg" alt/></p><p>For more on this, see <a href="@ref"><code>lineprofile</code></a>.</p><h2 id="Where-to-go-from-here?"><a class="docs-heading-anchor" href="#Where-to-go-from-here?">Where to go from here?</a><a id="Where-to-go-from-here?-1"></a><a class="docs-heading-anchor-permalink" href="#Where-to-go-from-here?" title="Permalink"></a></h2><p>The documentation is a rich resource for information related to using Gradus, and tailoring the toolkit for your needs. Take a look at <a href="../examples/examples/#Examples">Examples</a> for a number of quick recipes, or try <a href="../internals/custom-metrics/#Implementing-a-new-metric">Implementing a new metric</a> and study a different spacetime.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Johannsen, Tim. ‘Regular Black Hole Metric with Three Constants of Motion’. Physical Review D 88, no. 4 (1 August 2013): 044002. https://doi.org/10.1103/PhysRevD.88.044002.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../problems-and-solvers/">Problems and solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 22 March 2023 22:58">Wednesday 22 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
