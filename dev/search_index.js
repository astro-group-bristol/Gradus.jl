var documenterSearchIndex = {"docs":
[{"location":"overview/metrics/#Available-metrics","page":"Available metrics","title":"Available metrics","text":"","category":"section"},{"location":"overview/metrics/","page":"Available metrics","title":"Available metrics","text":"CurrentModule = Gradus","category":"page"},{"location":"overview/metrics/","page":"Available metrics","title":"Available metrics","text":"Gradus.jl implements a library of metrics ready to use for integrations and rendering.","category":"page"},{"location":"overview/metrics/","page":"Available metrics","title":"Available metrics","text":"Pages = [\"metrics.md\"]\nModules = [Gradus]\nOrder = [:type]","category":"page"},{"location":"overview/metrics/","page":"Available metrics","title":"Available metrics","text":"note: Note\nTo implement your own custom metrics, please see Implementing a new metric.","category":"page"},{"location":"overview/metrics/#Catalogue-of-spacetimes","page":"Available metrics","title":"Catalogue of spacetimes","text":"","category":"section"},{"location":"overview/metrics/","page":"Available metrics","title":"Available metrics","text":"Modules = [Gradus]\nFilter = t -> typeof(t) === UnionAll && t <: Gradus.AbstractMetricParams","category":"page"},{"location":"overview/metrics/#Gradus.BoyerLindquistAD","page":"Available metrics","title":"Gradus.BoyerLindquistAD","text":"struct BoyerLindquistAD{T} <: AbstractAutoDiffStaticAxisSymmetricParams{T}\n\nThe Kerr metric in Boyer-Lindquist coordinates, describing a black hole with mass M and angular spin a:\n\nbeginalign*\n    textds^2 =\n    - left( 1 - frac2 M rSigma right)textdt^2\n    - frac2M r a sin^2(theta)Sigma textdt textdphi\n    \n    + fracSigmaDelta textdr^2\n    + Sigma textdtheta^2\n    + left(r^2 + a^2 + frac2 M r a^2 sin^2(theta)Sigma right) sin^2(theta) textdphi^2\nendalign*\n\nwhere\n\nSigma = r^2 + a^2 cos^2 (theta)\nquad textand quad\nDelta = r^2 - 2Mr + a^2\n\nParameters\n\nM\nBlack hole mass. Default: 1.0\na\nBlack hole spin. Default: 0.0\n\n\n\n\n\n","category":"type"},{"location":"overview/metrics/#Gradus.BoyerLindquistFO","page":"Available metrics","title":"Gradus.BoyerLindquistFO","text":"A first-order implementation of BoyerLindquistAD.\n\nM\nBlack hole mass. Default: 1.0\na\nBlack hole spin. Default: 0.0\nE\nGeodesic energy (a consant of motion). Default: 1.0\n\n\n\n\n\n","category":"type"},{"location":"overview/metrics/#Gradus.DilatonAxionAD","page":"Available metrics","title":"Gradus.DilatonAxionAD","text":"struct DilatonAxionAD{T} <: AbstractAutoDiffStaticAxisSymmetricParams{T}\n\nEinstein-Maxwell-Dilaton-Axion metric.\n\nM\nSingularity mass. Default: 1.0\na\nSingularity spin. Default: 0.0\nβ\nDilaton coupling strength. Default: 0.0\nb\nAxion coupling strength. Default: 1.0\n\n\n\n\n\n","category":"type"},{"location":"overview/metrics/#Gradus.JohannsenAD","page":"Available metrics","title":"Gradus.JohannsenAD","text":"struct JohannsenAD{T} <: AbstractAutoDiffStaticAxisSymmetricParams{T}\n\nThe Johannsen (20xx) metric.\n\nM\nBlack hole mass. Default: 1.0\na\nBlack hole spin. Default: 0.0\nα13\nalpha_13 deviation parameter. Default: 0.0\nα22\nalpha_22 deviation parameter. Default: 0.0\nα52\nalpha_52 deviation parameter. Default: 0.0\nϵ3\nepsilon_3 deviation parameter. Default: 0.0\n\n\n\n\n\n","category":"type"},{"location":"overview/metrics/#Gradus.JohannsenPsaltisAD","page":"Available metrics","title":"Gradus.JohannsenPsaltisAD","text":"struct JohannsenPsaltisAD{T} <: AbstractAutoDiffStaticAxisSymmetricParams{T}\n\nJohannsen and Psaltis 2011\n\nM\nBlack hole mass. Default: 1.0\na\nBlack hole spin. Default: 0.0\nϵ3\nepsilon_3 deviation parameter. Default: 0.0\n\n\n\n\n\n","category":"type"},{"location":"overview/metrics/#Gradus.KerrRefractiveAD","page":"Available metrics","title":"Gradus.KerrRefractiveAD","text":"struct KerrRefractiveAD{T} <: AbstractAutoDiffStaticAxisSymmetricParams{T}\n\nKerr metric in Boyer-Lindquist coordintes with a path-length ansatz, equivalent to a refractive index n, within the coronal radius corona_radius.\n\nM\nBlack hole mass. Default: 1.0\na\nBlack hole spin. Default: 0.0\nn\nRefractive index within the corona. Default: 1.0\ncorona_radius\nRadius of the corona. Default: 20.0\n\n\n\n\n\n","category":"type"},{"location":"overview/metrics/#Gradus.MorrisThorneAD","page":"Available metrics","title":"Gradus.MorrisThorneAD","text":"struct MorrisThorneAD{T} <: AbstractAutoDiffStaticAxisSymmetricParams{T}\n\nMorris-Thorne wormhole metric.\n\nb\nThroat size. Default: 1.0\n\n\n\n\n\n","category":"type"},{"location":"overview/accretion-geometry/#Accretion-geometry","page":"Accretion geometry","title":"Accretion geometry","text":"","category":"section"},{"location":"overview/accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"CurrentModule = Gradus","category":"page"},{"location":"overview/accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"Gradus.jl supports the ability to implement custom accretion geometry, or even load in mesh files in any standard format using MeshIO.jl. Geometry may be standard spherically symmetric accretion discs, or any other custom type.","category":"page"},{"location":"overview/accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"note: Note\nCurrently geometry is optically thick always. Radiative transfer will be added soon.","category":"page"},{"location":"overview/accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"AbstractAccretionGeometry\nGradus.in_nearby_region\nGradus.has_intersect","category":"page"},{"location":"overview/accretion-geometry/#Gradus.AbstractAccretionGeometry","page":"Accretion geometry","title":"Gradus.AbstractAccretionGeometry","text":"abstract type AbstractAccretionGeometry{T}\n\nSupertype of all accretion geometry. Concrete sub-types must minimally implement\n\nin_nearby_region\nhas_intersect\n\nAlternativey, for more control, either intersects_geometry or build_collision_callback may be implemented for a given geometry type.\n\nGeometry intersection calculations are performed by strapping discrete callbacks to the integration procedure.\n\n\n\n\n\n","category":"type"},{"location":"overview/accretion-geometry/#Gradus.in_nearby_region","page":"Accretion geometry","title":"Gradus.in_nearby_region","text":"in_nearby_region(g::AbstractAccretionGeometry{T}, line_element)::Bool\n\nReturns a boolean indicating whether the line_element is \"close\" to the geometry in question. Used to optimize when to call the intersection algorithm.\n\nContextually, \"close\" is a little arbitrary, and this function may always return True, however will suffer in performance if this is the case.\n\nline_element is a tuple of two four-position vectors, indicating the last integration position, and current integration position, i.e. (u_prev, u_curr), in integrator coordinates.\n\nNotes\n\nThis function actually depends on the step size of the integrator, but this is currently not considered in the implementation.\n\n\n\n\n\n","category":"function"},{"location":"overview/accretion-geometry/#Gradus.has_intersect","page":"Accretion geometry","title":"Gradus.has_intersect","text":"has_intersect(g::AbstractAccretionGeometry{T}, line_element)\n\nReturns a boolean indicating whether line_element intersects the geometry g. The intersection algorithm used depends on the geometry considered. For meshes, this uses the jsf_algorithm.\n\nline_element is a tuple of two four-position vectors, indicating the last integration position, and current integration position, i.e. (u_prev, u_curr), in integrator coordinates.\n\n\n\n\n\n","category":"function"},{"location":"overview/accretion-geometry/#Accretion-discs","page":"Accretion geometry","title":"Accretion discs","text":"","category":"section"},{"location":"overview/accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"AbstractAccretionDisc\ndistance_to_disc\nAbstractThickAccretionDisc\ncross_section","category":"page"},{"location":"overview/accretion-geometry/#Gradus.AbstractAccretionDisc","page":"Accretion geometry","title":"Gradus.AbstractAccretionDisc","text":"abstract type AbstractAccretionDisc{T} <: AbstractAccretionGeometry{T}\n\nSupertype for axis-symmetric geometry, where certain optimizing assumptions may be made. Concrete subtypes must implement distance_to_disc.\n\n\n\n\n\n","category":"type"},{"location":"overview/accretion-geometry/#Gradus.distance_to_disc","page":"Accretion geometry","title":"Gradus.distance_to_disc","text":"distance_to_disc(d::AbstractAccretionGeometry, u; kwargs...)\n\nCalculate distance to the closest element of the disc. The distance need not be metric or Pythagorean, but rather should be positive when the four vector u is distant, zero when u is on the surface, and negative when u is within the disc geometry.\n\nMust return a floating point number.\n\n\n\n\n\n","category":"function"},{"location":"overview/accretion-geometry/#Gradus.AbstractThickAccretionDisc","page":"Accretion geometry","title":"Gradus.AbstractThickAccretionDisc","text":"abstract type AbstractThickAccretionDisc{T} <: AbstractAccretionDisc{T}\n\nSupertype for axis-symmetric geometry that are specified by a height cross-section function. Subtypes are required to implement cross_section.\n\n\n\n\n\n","category":"type"},{"location":"overview/accretion-geometry/#Gradus.cross_section","page":"Accretion geometry","title":"Gradus.cross_section","text":"cross_section(d::AbstractThickAccretionDisc, u)\n\nReturn the height cross-section of a thick accretion disc at the (projected) coordinates of u. This function also incorporates bounds checking, and should return a negative value if the disc is not defined at u.\n\nExample\n\nFor a top hat disc profile with constant height between two radii\n\nstruct TopHatDisc{T} <: AbstractThickAccretionDisc{T}\n    inner_r::T\n    outer_r::T\nend\n\nfunction Gradus.cross_section(d::TopHatDisc, u)\n    # project u into equitorial plane\n    r = u[2] * sin(u[3])\n    if (r < d.inner_r) || (r > d.outer_r)\n        return -1.0\n    else\n        return 1.0\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"overview/accretion-geometry/#Pre-defined-discs","page":"Accretion geometry","title":"Pre-defined discs","text":"","category":"section"},{"location":"overview/accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"GeometricThinDisc\nThickDisc\nShakuraSunyaev","category":"page"},{"location":"overview/accretion-geometry/#Gradus.GeometricThinDisc","page":"Accretion geometry","title":"Gradus.GeometricThinDisc","text":"struct GeometricThinDisc{T} <: AbstractAccretionDisc{T}\nGeometricThinDisc(inner_radius::T, outer_radius::T, inclination::T)\n\ninner_radius\nouter_radius\ninclination\n\nSimple geometrically thin accretion disc spanning from inner_radius to outer_radius in gravitational units. Inclination of the disc is relative to spin axis, with 90^circ being perpendicular to the spin axis.\n\n\n\n\n\n","category":"type"},{"location":"overview/accretion-geometry/#Gradus.ThickDisc","page":"Accretion geometry","title":"Gradus.ThickDisc","text":"ThickDisc{T,F,P} <: AbstractThickAccretionDisc{T}\nThickDisc(f, params=nothing; T = Float64)\n\nA standard wrapper for creating custom disc profiles from height cross-section function f. This function is given the disc parameters as unpacked arguments:\n\nd.f(u, d.params...)\n\nIf no parameters are specified, none will be passed to f.\n\nExample\n\nSpecifying a toroidal disc centered on r=10 with radius 1:\n\nd = ThickDisc() do u\n    r = u[2]\n    if r < 9.0 || r > 11.0\n        return -1.0\n    else\n        x = r - 10.0\n        sqrt(1-x^2)\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"overview/accretion-geometry/#Gradus.ShakuraSunyaev","page":"Accretion geometry","title":"Gradus.ShakuraSunyaev","text":"ShakuraSunyaev{T} <: AbstractThickAccretionDisc{T}\nShakuraSunyaev(\n    m::AbstractMetricParams;\n    eddington_ratio = 0.3,\n    η = nothing,\n    contra_rotating = false,\n)\n\nThe classic Shakura & Sunyaev (1973) accretion disc model, with height given by 2H, where\n\nH = frac32 frac1eta left( fracdotMdotM_textEdd right) left( 1 - sqrtfracr_textiscorho right)\n\nHere eta is the radiative efficiency, which, if unspecified, is determined by the circular orbit energy at the ISCO:\n\neta = 1 - E_textisco\n\n\n\n\n\n","category":"type"},{"location":"overview/accretion-geometry/#Meshes","page":"Accretion geometry","title":"Meshes","text":"","category":"section"},{"location":"overview/accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"MeshAccretionGeometry","category":"page"},{"location":"overview/accretion-geometry/#Gradus.MeshAccretionGeometry","page":"Accretion geometry","title":"Gradus.MeshAccretionGeometry","text":"MeshAccretionGeometry(mesh)\n\nmesh\nx_extent\ny_extent\nz_extent\n\n\n\n\n\n","category":"type"},{"location":"overview/geodesic-integration/#Geodesic-integration-strategies","page":"Geodesic integration","title":"Geodesic integration strategies","text":"","category":"section"},{"location":"overview/geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"CurrentModule = Gradus","category":"page"},{"location":"overview/geodesic-integration/#Second-Order","page":"Geodesic integration","title":"Second-Order","text":"","category":"section"},{"location":"overview/geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"The motivation behind the second-order methods is to permit the computation of geodesics in generic spacetimes, via the geodesic equation:","category":"page"},{"location":"overview/geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"Gradus.compute_geodesic_equation","category":"page"},{"location":"overview/geodesic-integration/#Gradus.compute_geodesic_equation","page":"Geodesic integration","title":"Gradus.compute_geodesic_equation","text":"compute_geodesic_equation(ginv, j1, j2, v) -> NTuple{4, Any}\n\n\nUsing the inverse metric ginv, the Jacobian of the metric for r and theta, j1 and j2 respectively, and velocity four-vector v, calculates the four-acceleration via the geodesic equation.\n\nReturns the components of fractextd^2 u^mutextd lambda^2 via\n\nfractextd^2 u^mutextd lambda^2\n    + Gamma^mu_phantommunusigma\n    fractextdu^nutextd lambda\n    fractextdu^sigmatextd lambda\n= 0\n\nwhere x^mu is a position four-vector, Gamma^mu_phantommunusigma are the Christoffel symbols of the second kind, and lambda the affine parameter describing the curve.\n\nThe Christoffel symbols Gamma^mu_phantommunusigma are defined\n\nGamma^mu_phantommunusigma\n= frac12 g^mu rho left(\n    partial_nug_rho sigma\n    + partial_sigmag_rho nu\n    - partial_rhog_sigma nu\nright)\n\nLimitations:\n\ncurrenly pre-supposes static, axis-symmetric metric.\n\nNotes\n\nThis function is symbolically pre-computed using the following code:\n\nusing Symbolics, Tullio\n@variables ginv[1:5], j1[1:5], j2[1:5], v[1:4] # non zero metric components\ninverse_metric = [\n    ginv[1] 0 0 ginv[5]\n    0 ginv[2] 0 0\n    0 0 ginv[3] 0\n    ginv[5] 0 0 ginv[4]\n]\nj1_mat = [\n    j1[1] 0 0 j1[5]\n    0 j1[2] 0 0\n    0 0 j1[3] 0\n    j1[5] 0 0 j1[4]\n]\nj2_mat = [\n    j2[1] 0 0 j2[5]\n    0 j2[2] 0 0\n    0 0 j2[3] 0\n    j2[5] 0 0 j2[4]\n]\nj0 = zeros(Float64, (4, 4))\njacobian = (j0, j1_mat, j2_mat, j0)\n# christoffel symbols\n@tullio Γ[i, k, l] :=\n    1 / 2 *\n    inverse_metric[i, m] *\n    (jacobian[l][m, k] + jacobian[k][m, l] - jacobian[m][k, l])\n# compute geodesic equation\n@tullio δxδλ[i] := -v[j] * Γ[i, j, k] * v[k]\n\n\n\n\n\n","category":"function"},{"location":"overview/geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"The above can be solved as a second-order ODE, subject to an initial position and initial velocity","category":"page"},{"location":"overview/geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"u^mu = left(t r theta phi right)\nquad\ntextand\nquad\ndotu^mu  \n    = left( dott dotr dottheta dotphi right)","category":"page"},{"location":"overview/geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"where the dot refers to the derivative with respect to lambda. In general, the spatial components of the initial velocity are known a priori, and the time-component is determined via the constraint:","category":"page"},{"location":"overview/geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"Gradus.constrain_time","category":"page"},{"location":"overview/geodesic-integration/#Gradus.constrain_time","page":"Geodesic integration","title":"Gradus.constrain_time","text":"constrain_time(g_comp, v, μ = 0.0, positive::Bool = true)\n\nConstrains the time component of the four-velocity v, given metric components g_comp and effective mass μ.\n\ng_sigmanu dotu^sigma dotu^nu = -mu^2\n\nfor v^t. The argument positive allows the sign of mu to be changed. true corresponds to time-like geodesics, false to space-like.\n\nThis function should rarely be directly called, and instead is invoked by constrain.\n\nLimitations:\n\ncurrenly pre-supposes static, axis-symmetric metric.\n\n\n\n\n\n","category":"function"},{"location":"api-documentation/Gradus/#Full-API-documentation","page":"Gradus","title":"Full API documentation","text":"","category":"section"},{"location":"api-documentation/Gradus/","page":"Gradus","title":"Gradus","text":"CurrentModule = Gradus","category":"page"},{"location":"api-documentation/Gradus/","page":"Gradus","title":"Gradus","text":"tracegeodesics\ninverse_metric_components\nGradus.metric_jacobian\nGradus.intersects_geometry\nGradus.build_collision_callback\nGradus.jsf_algorithm","category":"page"},{"location":"api-documentation/Gradus/#Gradus.tracegeodesics","page":"Gradus","title":"Gradus.tracegeodesics","text":"tracegeodesics(\n    m::AbstractMetricParams{T},\n    position,\n    velocity,\n    time_domain::Tuple{T,T};\n    solver = Tsit5(),\n    μ = 0.0,\n    closest_approach = 1.01,\n    effective_infinity = 1200.0,\n    callback = nothing,\n    solver_opts...,\n)\n\nIntegrate a geodesic for metric parameterised by m, for some initial positions and velocities. The positions and velocities may be\n\na single position and velocity in the form of a vector of numbers,\na collection of positions and velocities, as either a vector of vectors, or as a matrix,\na single position and a function with signature vel_func(i) which returns a four-velocity.\n\nThe matrix specification reads each corresponding column as the initial position and velocity. When a collection of positions and velocities is supplied, this method dispatched EnsembleProblem, offering ensemble as a solver_opts, specifying the ensemble method to use.\n\nsolver_opts are the common solver options in DifferentialEquations.\n\n\n\n\n\n","category":"function"},{"location":"api-documentation/Gradus/#Gradus.GradusBase.inverse_metric_components","page":"Gradus","title":"Gradus.GradusBase.inverse_metric_components","text":"inverse_metric_components(g_comp)\n\nCalculates g^tt, g^rr, g^thetatheta, g^phiphi, g^tphi of a static, axis-symmetric metric from g_tt, g_rr, g_thetatheta, g_phiphi, g_tphi using a symbolically computed inverse matrix method.\n\nNotes\n\nTo recreate:\n\nusing Symbolics\n@variables g[1:5] # non zero metric components\nmetric = [\n    g[1] 0 0 g[5]\n    0 g[2] 0 0\n    0 0 g[3] 0\n    g[5] 0 0 g[4]\n]\ninv(metric)\n\n\n\n\n\n","category":"function"},{"location":"api-documentation/Gradus/#Gradus.metric_jacobian","page":"Gradus","title":"Gradus.metric_jacobian","text":"metric_jacobian(m::AbstractAutoDiffStaticAxisSymmetricParams{T}, rθ)\n\nCalculate the value and Jacobian elements of the metric with respect to r and theta.\n\nLimitations:\n\ncurrenly pre-supposes static, axis-symmetric metric.\n\nNotes\n\nFunction body is equivalent to\n\nf = x -> metric_components(m, x)\nJ = ForwardDiff.vector_mode_jacobian(f, rθ)\nf(rθ), J\n\nbut non-allocating.\n\n\n\n\n\n","category":"function"},{"location":"api-documentation/Gradus/#Gradus.intersects_geometry","page":"Gradus","title":"Gradus.intersects_geometry","text":"intersects_geometry(m::AbstractAccretionGeometry{T}, line_element)\n\nUtility function. Returns a boolean dependent on whether line_element intersects with the geometry (true) or not (false). Uses in_nearby_region to optimze and calls has_intersect to determine intersection.\n\n\n\n\n\n","category":"function"},{"location":"api-documentation/Gradus/#Gradus.build_collision_callback","page":"Gradus","title":"Gradus.build_collision_callback","text":"build_collision_callback(m::AbstractAccretionGeometry{T})\n\nGenerates the callback used for the integration. Returns a Function, with the fingerprint\n\nfunction callback(u, λ, integrator)::Bool\n    # ...\nend\n\n\n\n\n\n","category":"function"},{"location":"api-documentation/Gradus/#Gradus.jsf_algorithm","page":"Gradus","title":"Gradus.jsf_algorithm","text":"jsf_algorithm(V₁::T, V₂::T, V₃::T, Q₁::V, Q₂::V; ϵ = 1e-8)\n\nImplemented from Jiménez, Segura, Feito. Computation Geometry 43 (2010) 474-492.\n\nSee this blog post for a discussion.\n\n\n\n\n\n","category":"function"},{"location":"api-documentation/GradusBase/#GradusBase-API-documentation","page":"GradusBase","title":"GradusBase API documentation","text":"","category":"section"},{"location":"api-documentation/GradusBase/","page":"GradusBase","title":"GradusBase","text":"Modules = [Gradus.GradusBase]\nOrder   = [:function, :type]","category":"page"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.E-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T","page":"GradusBase","title":"Gradus.GradusBase.E","text":"E(m::AbstractMatrix{T}, v)\nE(m::AbstractMetricParams{T}, u, v)\n\nCompute the energy for a numerically evaluated metric, and some velocity four vector v,\n\nE = - p_t = - g_tnu p^nu\n\nFor null geodesics, the velocity is the momentum v^nu = p^nu. For massive geodesics, the mass mu needs to be known to compute mu v^nu = p^nu.\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.Lz-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T","page":"GradusBase","title":"Gradus.GradusBase.Lz","text":"Lz(m::AbstractMatrix{T}, v)\nLz(m::AbstractMetricParams{T}, u, v)\n\nCompute the angular momentum for a numerically evaluated metric, and some velocity four vector v.\n\nL_z = p_phi = - g_phinu p^nu\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.constrain-Union{Tuple{T}, Tuple{AbstractMetricParams{T}, Any, Any}} where T","page":"GradusBase","title":"Gradus.GradusBase.constrain","text":"constrain(m::AbstractMetricParams{T}, u, v; μ::T=0.0)\n\nCalculate time component v^t which would constrain a velocity vector v at position x as a geodesic with mass μ.\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.geodesic_eq-Union{Tuple{T}, Tuple{AbstractMetricParams{T}, Any, Any}} where T","page":"GradusBase","title":"Gradus.GradusBase.geodesic_eq","text":"geodesic_eq(m::AbstractMetricParams{T}, u, v)\ngeodesic_eq!(m::AbstractMetricParams{T}, u, v)\n\nCalculate the acceleration components of the geodesic equation given a position u, a velocity v, and a metric m.\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.getgeodesicpoint-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AbstractMetricParams{T}, SciMLBase.AbstractODESolution{T, N, S}}} where {T, N, S}","page":"GradusBase","title":"Gradus.GradusBase.getgeodesicpoint","text":"Used to get pack a SciMLBase.AbstractODESolution into a GeodesicPoint. Will only store information relevant to start and endpoint of the integration. To keep the full geodesic path, it is encouraged to use the SciMLBase.AbstractODESolution directly.\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.getgeodesicpoints-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AbstractMetricParams{T}, SciMLBase.AbstractODESolution{T, N, S}}} where {T, N, S}","page":"GradusBase","title":"Gradus.GradusBase.getgeodesicpoints","text":"getgeodesicpoints(\n    _::AbstractMetricParams{T},\n    sol::SciMLBase.AbstractODESolution{T, N, S}\n) -> Any\n\n\nUnpacks each point in the solution, similar to getgeodesicpoint but returns an  array of GeodesicPoint.\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.inner_radius-Union{Tuple{AbstractMetricParams{T}}, Tuple{T}} where T","page":"GradusBase","title":"Gradus.GradusBase.inner_radius","text":"inner_radius(m::AbstractMetricParams{T})\n\nReturn the innermost valid coordinate relative to the origin, for use in geodesic tracing.\n\nThis usually represents some property of the metric, e.g. event horizon radius in Kerr/Schwarzschild metrics, or throat diameter in worm hole metrics.\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.metric-Union{Tuple{T}, Tuple{AbstractMetricParams{T}, Any}} where T","page":"GradusBase","title":"Gradus.GradusBase.metric","text":"metric(m::AbstractMetricParams{T}, u)\n\nNumerically evaluate the corresponding metric for AbstractMetricParams, given parameter values m and some point u.\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.metric_components-Union{Tuple{T}, Tuple{AbstractMetricParams{T}, Any}} where T","page":"GradusBase","title":"Gradus.GradusBase.metric_components","text":"metric_components(m::AbstractMetricParams{T}, x)\n\nReturn a tuple with each non-zero metric component for the metric described by m at position x. Note that the position need not be a four-vector, and for specific implementations may only be a subset of the total manifold coordinates. See specific implementations for subtypes of AbstractMetricParams for details.\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.metric_type-Union{Tuple{AbstractMetricParams{T}}, Tuple{T}} where T","page":"GradusBase","title":"Gradus.GradusBase.metric_type","text":"metric_type(m::AbstractMetricParams{T})\n\nReturn the AbstractMetric type associated with the metric parameters m.\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.mproject-Tuple{Any, Any, Any}","page":"GradusBase","title":"Gradus.GradusBase.mproject","text":"mproject(g, v, u)\n\nProject vector v onto u with metric g. Optional first argument may be AbstractMetricParams for more optimized methods, which fallback to an einsum.\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.AbstractGeodesicPoint","page":"GradusBase","title":"Gradus.GradusBase.AbstractGeodesicPoint","text":"abstract type AbstractGeodesicPoint\n\nSupertype for geodesic points, used to store information about specific points along geodesic trajectories.\n\nnote: Note\nCurrently limited to storing the start and endpoint of any given trajectory. To keep the full geodesic path, it is encouraged to use the SciMLBase.AbstractODESolution directly.\n\nMust minimally have the same fields as GeodesicPoint. Examples include Gradus.FirstOrderGeodesicPoint.\n\n\n\n\n\n","category":"type"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.AbstractMetricParams","page":"GradusBase","title":"Gradus.GradusBase.AbstractMetricParams","text":"abstract type AbstractMetricParams{T} end\n\nAbstract type used to dispatch different geodesic problems.\n\n\n\n\n\n","category":"type"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.GeodesicPoint","page":"GradusBase","title":"Gradus.GradusBase.GeodesicPoint","text":"struct GeodesicPoint <: AbstractGeodesicPoint\n\nretcode\nReturn code of the integrator for this geodesic.\nt1\nStart affine time\nt2\nEnd affine time\nu1\nStart four position\nu2\nEnd four position\nv1\nStart four velocity\nv2\nEnd four velocity\n\n\n\n\n\n","category":"type"},{"location":"examples/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"Pages = [\"examples.md\"]\nDepth = 3","category":"page"},{"location":"examples/examples/#Tracing-geodesic-paths","page":"Examples","title":"Tracing geodesic paths","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using Gradus\nusing Plots\nusing StaticArrays\n\nm = JohannsenPsaltisAD(M=1.0, a=0.6, ϵ3=2.0)\n# observer position\nu = @SVector [0.0, 1000.0, π/2, 0.0]\n\n# set up impact parameter space\nα = collect(range(-10.0, 10.0, 20))\nβ = [0.0 for _ in α]\n\n# build initial velocity and position vectors\nvs = map_impact_parameters(m, u, α, β)\nus = [u for _ in vs]\n\nsols = tracegeodesics(\n    m, us, vs, (0.0, 2000.0);\n    abstol = 1e-12, reltol = 1e-12\n)\n\n# only use the subset of the solution we're plotting\ntrange = range(990, 1035, 5000)\n\np = plot(projection = :polar, legend = false, range = (0, 10))\nfor s in sols\n    r = [s(t)[2] for t in trange]\n    ϕ = [s(t)[4] for t in trange]\n    plot!(p, ϕ, r)\nend\n\n# plot event horizon \nr0 = inner_radius(m)\nplot!(p, collect(range(0, 2π, 200)), [r0 for _ in 1:200], color = :black, linewidth = 2)","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#Redshift-image","page":"Examples","title":"Redshift image","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"note: Note\nThe Gradus.ConstPointFunctions.redshift function is an analytic solution for redshift, which may not be implemented for every type of metric or disc geometry. See Interpolating redshifts for a more flexible numeric alternative.","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using Gradus\nusing StaticArrays\nusing Plots\n\n# metric and metric parameters\nm = BoyerLindquistAD(M=1.0, a=1.0)\n# observer position\nu = @SVector [0.0, 1000.0, deg2rad(60), 0.0]\n# accretion disc\nd = GeometricThinDisc(1.0, 50.0, deg2rad(90))\n\n# define point function which filters geodesics that intersected the accretion disc\n# and use those to calculate redshift\npf = ConstPointFunctions.redshift ∘ ConstPointFunctions.filter_intersected\n\nimg = rendergeodesics(\n    m,\n    u,\n    d,\n    # maximum integration time\n    2000.0,\n    fov_factor = 6.0,\n    image_width = 700,\n    image_height = 240,\n    verbose = true,\n    pf = pf\n)\n\nheatmap(img)","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#Redshift-line-profile","page":"Examples","title":"Redshift line-profile","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"Using the redshift example, we can bin a redshift line-profile using StatsBase.jl. We'll calculate the iron line redshift profile, with a delta-emission at 6.4 keV.","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using StatsBase\n\n# remove nans and flatten the redshift image\nredshift_data = filter(!isnan, vec(img))\n\n# transpose to iron-line\ndata = redshift_data .* 6.4\n\nx_bins = range(0.0, 10.0, 100) \nlineprof = fit(Histogram, data, x_bins)\n\nplot(x_bins[1:end-1], lineprof.weights, seriestype = :steppre)","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#Interpolating-redshifts","page":"Examples","title":"Interpolating redshifts","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"In cases where no analytic redshift solution is known, we can instead interpolate a numeric approximation. For example, interpolating the plunging region velocities and using the analytic solution for general static, axis symmetric metrics outside of the ISCO can be achieved with:","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using Gradus\nusing StaticArrays\nusing Plots\n\n# metric and metric parameters\nm = BoyerLindquistAD(M=1.0, a=0.4)\n# observer's initial position\nu = @SVector [0.0, 1000.0, deg2rad(85), 0.0]\n# accretion disc\nd = GeometricThinDisc(1.0, 50.0, deg2rad(90))\n\npl_int = interpolate_plunging_velocities(m)\n\nredshift = interpolate_redshift(pl_int, u)\n\npf = redshift ∘ ConstPointFunctions.filter_intersected\n\nimg = rendergeodesics(\n    m,\n    u,\n    d,\n    # maximum integration time\n    2000.0,\n    fov_factor = 6.0,\n    image_width = 700,\n    image_height = 240,\n    verbose = true,\n    pf = pf\n)\n\nheatmap(img)","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#Disc-geometries","page":"Examples","title":"Disc geometries","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"Gradus makes it easy to define new height cross sections for thick discs:","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using Gradus\nusing StaticArrays\nusing Plots\n\nm = BoyerLindquistAD(1.0, 0.0)\nu = @SVector [0.0, 1000.0, deg2rad(85), 0.0]\n\n# define the disc shape -- return a negative number \n# where the disc should not be intersected, else the cross \n# sectional height\nd = ThickDisc() do u\n    r = u[2]\n    if r < 9.0 || r > 11.0\n        return -1.0\n    else\n        x = r - 10.0\n        sqrt(1 - x^2)\n    end\nend\n\n# and then render as usual\nimg = rendergeodesics(\n    m,\n    u,\n    d,\n    2000.0,\n    fov_factor = 18.0,\n    image_width = 700,\n    image_height = 350,\n    verbose = true,\n    pf = pf\n)\n\nheatmap(img, aspect_ratio=1)","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"For more disc on disc geometry, see AbstractAccretionDisc and associated sections.","category":"page"},{"location":"examples/examples/#Circular-orbits","page":"Examples","title":"Circular orbits","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"Simple equatorial circular orbits are straight forward to calculate with Gradus.jl:","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using Gradus\nusing Plots\nusing StaticArrays\n\nm = BoyerLindquistAD(M=1.0, a=0.8)\n\np = plot(aspect_ratio=1)\n\nfor r in [3.0, 4.0, 5.0, 6.0]\n    v = CircularOrbits.fourvelocity(m, r)\n    # trace the circular orbit\n    path = tracegeodesics(m, @SVector([0.0, r, π/2, 0.0]), v, (0.0, 300.0), μ = 1.0)\n    r = [path(t)[2] for t in range(0.0, 100, 200)]\n    ϕ = [path(t)[4] for t in range(0.0, 100, 200)]\n\n    x = @. r * cos(ϕ)\n    y = @. r * sin(ϕ)\n\n    plot!(p, x, y, label = false)\nend","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#ISCO","page":"Examples","title":"ISCO","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"The Gradus.isco may be calculated with a simple convenience function, as may the energy associated with a given stable circular orbit.","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using Gradus\nusing Plots\n\n# prepare plot\np = plot(legend=:bottomright, ylabel = \"E\", xlabel = \"r\", xscale = :log10)\n\n# choice of spin to plot energy curves for\nfor a in [0.0, 0.4, 0.6]\n    m = BoyerLindquistAD(M = 1.0, a = a)\n\n    rs = range(Gradus.isco(m), 100.0, 500)\n    energy = map(rs) do r\n        CircularOrbits.energy(m, r)\n    end\n\n    plot!(rs, energy, label = \"a=$a\")\nend\n\n# calculate the ISCO as a function of spin\ndata = map(range(-1.0, 0.8, 100)) do a\n    m = BoyerLindquistAD(M = 1.0, a = a)\n    r = Gradus.isco(m)\n    CircularOrbits.energy(m, r), r\nend\n\n# overlay onto plot\nplot!(last.(data), first.(data), color=:black, linestyle=:dash, label=\"ISCO\")","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#Event-horizons-and-naked-singularities","page":"Examples","title":"Event horizons and naked singularities","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"Here is an example of how to use eventhorizon to plot the shape of an event horizon in two dimensions. In the case of a naked singularity, as with the certain parameters combinations in the JohannsenPsaltisAD metric, we see a disconnected region in the plot.","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using Gradus\nusing Plots\n\nfunction draw_horizon(p, m)\n    rs, θs = eventhorizon(m, resolution = 200)\n    radius = rs\n\n    x = @. radius * cos(θs)\n    y = @. radius * sin(θs)\n    plot!(p, x, y, label = \"a = $(m.a)\")\nend\n\np = plot(aspect_ratio = 1)\nfor a in [0.0, 0.5, 0.6, 0.7, 0.8]\n    m = JohannsenPsaltisAD(M = 1.0, a = a, ϵ3 = 2.0)\n    draw_horizon(p, m)\nend","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"We can also calculate parameter combinations that lead to naked singularities, and plot the parameter space domains to show exclusion zones:","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"function calc_exclusion(as, ϵs)\n    regions = [\n        is_naked_singularity(JohannsenPsaltisAD(M = 1.0, a = a, ϵ3 = ϵ))\n        for a in as, ϵ in ϵs\n    ]\n\n    map(i -> i ? 1.0 : NaN, regions)\nend\n\n# define ranges (small in this example as a little computationally intense)\nas = range(0, 1.0, 40)\nϵs = range(-10, 10, 40)\n\nimg = calc_exclusion(as, ϵs)\nheatmap(\n    as, \n    ϵs, \n    img', \n    color = :black, \n    colorbar = false, \n    xlabel = \"a\", \n    ylabel = \"ϵ\"\n)","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#Cunningham-transfer-functions","page":"Examples","title":"Cunningham transfer functions","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"Recreating Fig. 1 and 2 from Bambi et al. (2017) for the transfer functions of a Kerr black hole","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using Gradus\nusing StaticArrays\nusing Plots\n\nm = BoyerLindquistAD(M=1.0, a=0.998)\nd = GeometricThinDisc(0.0, 100.0, π/2)\n\np = plot(legend = false)\nfor angle in [3, 35, 50, 65, 74, 85]\n    u = @SVector [0.0, 1000.0, deg2rad(angle), 0.0]\n    ctf = cunningham_transfer_function(\n        m, u, d, 4.0, 2000.0\n    )\n    mask = @. (ctf.gstar > 0.001) & (ctf.gstar < 0.999)\n    @views plot!(p, ctf.gstar[mask], ctf.f[mask])\nend","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"And Fig. 2:","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"# new position vector\nu = @SVector [0.0, 1000.0, deg2rad(30), 0.0]\n\np = plot(legend = false)\nfor a in [0.0, 0.25, 0.5, 0.75, 0.9, 0.998]\n    m = BoyerLindquistAD(1.0, a)\n    ctf = cunningham_transfer_function(\n        m, u, d, 7.0, 2000.0\n    )\n    mask = @. (ctf.gstar > 0.001) & (ctf.gstar < 0.999)\n    @views plot!(p, ctf.gstar[mask], ctf.f[mask])\nend","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#Concentric-rings","page":"Examples","title":"Concentric rings","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"Recreating Figure 2 from Johannsen and Psaltis (2012, II):","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using Gradus\nusing StaticArrays\nusing Plots\n\n# their papers has a=-a\nm = BoyerLindquistAD(M=1.0, a=-0.4)\nu = @SVector [0.0, 1000, acos(0.25), 0.0]\nd = GeometricThinDisc(0.0, 100.0, π / 2)\n\nradii = 2.6:1.0:7.6\n\np = plot(\n    aspect_ratio = 1,\n    legend = false,\n)\n\n# crosshair on origin\nhline!(p, [0.0], color = :black, linestyle=:dash)\nvline!(p, [0.0], color = :black, linestyle=:dash)\n\nfor r in radii\n    α, β = impact_parameters_for_radius(m, u, d, r, N=100)\n    plot!(p, α, β)\nend","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"internals/custom-metrics/#Implementing-a-new-metric","page":"Implementing new metrics","title":"Implementing a new metric","text":"","category":"section"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"CurrentModule = Gradus","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"Gradus.jl is able to integrate any 3+1 dimensional metric. A new metric may be defined by implementing one of the abstract types with a concrete type, and defining a number of methods. Depending on what you want to be able to do with a metric, different functions need to be implemented. ","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"Gradus also provides a few derivative abstract types to implement to ensure the most efficient code is executed for a given metric (see Metric parameter types below).","category":"page"},{"location":"internals/custom-metrics/#Example:-Schwarzschild","page":"Implementing new metrics","title":"Example: Schwarzschild","text":"","category":"section"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"As a minimal example, here is how the Schwarzschild metric may be implemented. First, we must define what the metric parameters for this metric are. These are effectively constants of the spacetime, representing physical quantities that appear in the metric expression. For the Schwarzschild metric, this is only the black hole mass M, but e.g. the Kerr metric also has the black hole spin a.","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"We can choose the integration strategy by sub-typing an abstract type representing different classes of spacetimes. For the Schwarzschild metric, we will use the static, axis-symmetric class, with the automatic differentiation (AD) backend. With AD, we only need to specify the non-zero components of the metric as Julia functions, and the rest is done for us.","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"For ease, we choose the Eddington-Finkelstein coordinates of the Schwarzschild solution, which may be written","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"textds^2 =\n    - left( 1 - frac2 Mr right) textdt^2\n    + left( 1 - frac2 Mr right)^-1 textdr^2\n    + r^2 textdtheta^2\n    + r^2 sin^2(theta) textdphi^2","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"Here is a possible implementation for Gradus.jl:","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"using Gradus\n\n@with_kw struct EddingtonFinkelsteinAD{T} <: AbstractAutoDiffStaticAxisSymmetricParams{T}\n    M = 1.0\nend\n\nfunction GradusBase.metric_components(m::EddingtonFinkelsteinAD{T}, rθ) where {T}\n    (r, θ) = rθ\n    M = m.M\n\n    tt = -(1 - (2M / r))\n    rr = -inv(tt)\n    θθ = r^2\n    ϕϕ = r^2 * sin(θ)^2\n\n    (tt, rr, θθ, ϕϕ, T(0.0))\nend\n\nGradusBase.inner_radius(m::BoyerLindquistAD{T}) where {T} = 2 * m.M","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"A few notes:","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"We use @with_kw from Parameters.jl to define various utility constructors for us.\nGradusBase.metric_components must return five elements for AbstractAutoDiffStaticAxisSymmetricParams, where the last element is the off-axis g_t phi matrix element, which in this case is always 0.\nThe GradusBase.inner_radius function defines the inner-radius of integration chart. This defines where the integration should terminate to avoid running indefinitely, and is, in this case, set to the event-horizon of our metric.","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"That's all we need! This metric is now ready to be traced in the usual way.","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"note: Note\nFor more examples of how to implement different metrics, click on the \"source\" button of a metric in Implemented Metrics. Alternatively, view the source code directly here.","category":"page"},{"location":"internals/custom-metrics/#Metric-parameter-types","page":"Implementing new metrics","title":"Metric parameter types","text":"","category":"section"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"The following types may be implemented to add new metrics. Each type has different requirements for its interface.","category":"page"},{"location":"internals/custom-metrics/#First-Order","page":"Implementing new metrics","title":"First-Order","text":"","category":"section"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"AbstractFirstOrderMetricParams\nGradus.four_velocity\nGradus.calc_lq\nGradus.Vr\nGradus.Vθ","category":"page"},{"location":"internals/custom-metrics/#Gradus.AbstractFirstOrderMetricParams","page":"Implementing new metrics","title":"Gradus.AbstractFirstOrderMetricParams","text":"AbstractFirstOrderMetricParams{T} <: AbstractMetricParams{T}\n\nAbstract type for metrics using the 1st-order integration method. The 1st-order methods reuse the velocity vector as a parameter vector, where only element vel[2] and vel[3] are used, and are local observer ratios sin Theta and sin Phi respectively.\n\nRequire implementation of\n\ninner_radius\nconstrain\nfour_velocity\ncalc_lq\nVr\nVθ\nimpact_parameters_to_vel\n\n\n\n\n\n","category":"type"},{"location":"internals/custom-metrics/#Gradus.four_velocity","page":"Implementing new metrics","title":"Gradus.four_velocity","text":"four_velocity(\n    u,\n    m::AbstractFirstOrderMetricParams,\n    p\n) -> NTuple{4, Any}\n\n\nCalculate the four-velocity at a point u, given a set of metric parameters and the constants of motion in p.\n\n\n\n\n\n","category":"function"},{"location":"internals/custom-metrics/#Gradus.calc_lq","page":"Implementing new metrics","title":"Gradus.calc_lq","text":"Calculate constants of motion L and Q, given a set of metric parameters, the geodesic position, and the param vector.\n\n\n\n\n\n","category":"function"},{"location":"internals/custom-metrics/#Gradus.Vr","page":"Implementing new metrics","title":"Gradus.Vr","text":"Vr(m::AbstractFirstOrderMetricParams{T}, u, p) -> Any\n\n\nEffective potential in the radial direction. Used only to track sign changes.\n\n\n\n\n\n","category":"function"},{"location":"internals/custom-metrics/#Gradus.Vθ","page":"Implementing new metrics","title":"Gradus.Vθ","text":"Effective potential in the angular direction. Used only to track sign changes.\n\n\n\n\n\n","category":"function"},{"location":"internals/custom-metrics/#Second-Order","page":"Implementing new metrics","title":"Second-Order","text":"","category":"section"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"AbstractAutoDiffMetricParams\nmetric_components\nAbstractAutoDiffStaticAxisSymmetricParams","category":"page"},{"location":"internals/custom-metrics/#Gradus.AbstractAutoDiffMetricParams","page":"Implementing new metrics","title":"Gradus.AbstractAutoDiffMetricParams","text":"AbstractAutoDiffMetricParams{T} <: AbstractMetricParams{T}\n\nAbstract type for metrics using the 2nd-order integration method, with the automatic differentiation backend.\n\n\n\n\n\n","category":"type"},{"location":"internals/custom-metrics/#Gradus.GradusBase.metric_components","page":"Implementing new metrics","title":"Gradus.GradusBase.metric_components","text":"metric_components(\n    m::AbstractAutoDiffStaticAxisSymmetricParams{T},\n    rθ\n) -> Any\n\n\nInterface for AbstractAutoDiffStaticAxisSymmetricParams. Should return a vector or tuple with the elements\n\nleft(\n    g_tt g_rr g_theta theta g_phi phi g_tphi\nright)\n\n\n\n\n\nmetric_components(m::AbstractMetricParams{T}, x)\n\nReturn a tuple with each non-zero metric component for the metric described by m at position x. Note that the position need not be a four-vector, and for specific implementations may only be a subset of the total manifold coordinates. See specific implementations for subtypes of AbstractMetricParams for details.\n\n\n\n\n\n","category":"function"},{"location":"internals/custom-metrics/#Gradus.AbstractAutoDiffStaticAxisSymmetricParams","page":"Implementing new metrics","title":"Gradus.AbstractAutoDiffStaticAxisSymmetricParams","text":"AbstractAutoDiffStaticAxisSymmetricParams{T} <: AbstractAutoDiffMetricParams{T}\n\nSpecialisation for static, axis-symmetric metrics. Here, the metric is of the form\n\n    g_munu =\n    left( beginmatrix\n        g_tt      0       0                   g_tphi     \n        0           g_rr  0                   0              \n        0           0       g_thetatheta  0              \n        g_tphi  0       0                   g_phiphi\n    endmatrix right)\n\nwhere the only non-zero off axis elements are g_tphi.\n\nRequired implementations:\n\ninner_radius\nmetric_components\n\n\n\n\n\n","category":"type"},{"location":"internals/special-radii/#Special-radii","page":"Special radii","title":"Special radii","text":"","category":"section"},{"location":"internals/special-radii/","page":"Special radii","title":"Special radii","text":"CurrentModule = Gradus","category":"page"},{"location":"internals/special-radii/","page":"Special radii","title":"Special radii","text":"Gradus.isco\nGradus.r_ph\nGradus.r_mb\nGradus.r_s\nGradus.eventhorizon","category":"page"},{"location":"internals/special-radii/#Gradus.isco","page":"Special radii","title":"Gradus.isco","text":"Innermost stable circular orbit (ISCO), defined by\n\n    fractextdtextdr left( fracEmu right) = 0\n\nUses analytic solutions if known for that metric, else uses a root finder to calculate the radius at which the defining condition is met.\n\n\n\n\n\n","category":"function"},{"location":"internals/special-radii/#Gradus.r_ph","page":"Special radii","title":"Gradus.r_ph","text":"Photon orbit radius, defined as the radius for which\n\n    fracEmu rightarrow infty \n\n\n\n\n\n","category":"function"},{"location":"internals/special-radii/#Gradus.r_mb","page":"Special radii","title":"Gradus.r_mb","text":"r_mb(m::AbstractMetricParams{T})\n\n\nMarginally bound orbit\n\n    fracEmu = 1\n\n\n\n\n\n","category":"function"},{"location":"internals/special-radii/#Gradus.r_s","page":"Special radii","title":"Gradus.r_s","text":"Event horizon radius, often equivalent to GradusBase.inner_radius, however remains distinct, such that the latter may still be an arbitrary chart cutoff.\n\n\n\n\n\n","category":"function"},{"location":"internals/special-radii/#Gradus.eventhorizon","page":"Special radii","title":"Gradus.eventhorizon","text":"eventhorizon(m::AbstractMetricParams; select = last, resolution = 100, θε = 1e-7, rmax = 5.0)\n\nUtility function for helping plot an event horizon shape. Returns a tuple containing the r and θ vectors that solve\n\n    g_tphi^2 - g_tt g_phi phi = 0\n\nA NaN value in the r vector indicates no solution for that particular theta, i.e. that the metric describes a naked singularity.\n\nOften the equation will have multiple roots, in which case the keyword argument select may be assigned to select the desired root.\n\n\n\n\n\n","category":"function"},{"location":"overview/point-functions/#Point-functions","page":"Point functions","title":"Point functions","text":"","category":"section"},{"location":"overview/point-functions/","page":"Point functions","title":"Point functions","text":"CurrentModule = Gradus","category":"page"},{"location":"overview/point-functions/","page":"Point functions","title":"Point functions","text":"AbstractPointFunction\nPointFunction\nFilterPointFunction","category":"page"},{"location":"overview/point-functions/#Gradus.AbstractPointFunction","page":"Point functions","title":"Gradus.AbstractPointFunction","text":"abstract type AbstractPointFunction\n\nAbstract super type for point functions. Must have f::Function field.\n\n\n\n\n\n","category":"type"},{"location":"overview/point-functions/#Gradus.PointFunction","page":"Point functions","title":"Gradus.PointFunction","text":"struct PointFunction <: AbstractPointFunction\nPointFunction(func)\n\nf\nWrapped function.\n\nPoint functions are functions that are used to calculate physical parameters from geodesic integrations, and to compose more complex models. A number of default and utility PointFunction are defined in Gradus.ConstPointFunctions.\n\nPrincipally, point functions return a single value per geodesic, and are used to fill rendered images with values, e.g. colouring redshift.\n\nPoint functions may be instantiated by wrapping a function with the following signature\n\nfunction func(m::AbstractMetricParams{T}, gp::AbstractGeodesicPoint, max_time::T; kwargs...)::T where {T}\n    # ...\nend\n\npf = PointFunction(func)\n\nThe AbstractMetricParams argument may be used to dispatch for different metrics.\ngp is an GradusBase.AbstractGeodesicPoint corresponding to a given geodesic.\nThe max_time parameter is the maximum integration time used to integrate the geodesics. This may be useful when trying to determine whether a geodesic terminated early or not.\n\nThey may be invoked by invoking the instance\n\nresult = pf(m, gp, max_time)\n\nnote: Note\nAs of version 0.1.0, the kwargs parameter is reserved only for passing optional results when chaining multiple point functions (see below). This is subject to revision and breaking changes in future versions.\n\nMultiple AbstractPointFunction may be chained together using the ∘ operator, and are evaluated from right to left\n\npf3 = pf2 ∘ pf1\n\nThis may be useful for constructing filters using FilterPointFunction. When used with two PointFunction objects, the output of the previous PointFunction is passed to the next via the value keyword argument.\n\n\n\n\n\n","category":"type"},{"location":"overview/point-functions/#Gradus.FilterPointFunction","page":"Point functions","title":"Gradus.FilterPointFunction","text":"struct FilterPointFunction <: AbstractPointFunction\nFilterPointFunction(func, default_value)\n\nf\nWrapped function.\ndefault\nDefault return value if condition is false.\n\nPoint functions used to filter geodesics. They may be constructed with\n\nfunction func(m::AbstractMetricParams{T}, gp::AbstractGeodesicPoint, max_time::T; kwargs...)::Bool where {T}\n    # ... return Bool\nend\n\nfpf = FilterPointFunction(func, NaN64)\n\nThe second argument to the constructor is the default value, given to the pixel if the boolean condition of func is false.\n\nExample\n\nA filter for geodesics within a certain radius, used to only calculate redshift within 10 r_textg\n\nfunc(m, gp, max_time) = gp.u[2] < 10.0\npf = ConstPointFunctions.redshift ∘ FilterPointFunction(func, NaN64)\n\n\n\n\n\n","category":"type"},{"location":"overview/point-functions/#Pre-defined-point-functions","page":"Point functions","title":"Pre-defined point functions","text":"","category":"section"},{"location":"overview/point-functions/","page":"Point functions","title":"Point functions","text":"ConstPointFunctions\nConstPointFunctions.filter_early_term\nConstPointFunctions.filter_intersected\nConstPointFunctions.affine_time\nConstPointFunctions.shadow\nConstPointFunctions.redshift","category":"page"},{"location":"overview/point-functions/#Gradus.ConstPointFunctions","page":"Point functions","title":"Gradus.ConstPointFunctions","text":"module ConstPointFunctions\n\nModule defining a number of const Gradus.AbstractPointFunction, serving different utility or common purposes for analysis.\n\n\n\n\n\n","category":"module"},{"location":"overview/point-functions/#Gradus.ConstPointFunctions.filter_early_term","page":"Point functions","title":"Gradus.ConstPointFunctions.filter_early_term","text":"filter_early_term(m::AbstractMetricParams, gp::AbstractGeodesicPoint, max_time)\n\nA FilterPointFunction that filters geodesics that termined early (i.e., did not reach maximum integration time or effective infinity). Default: NaN.\n\n\n\n\n\n","category":"constant"},{"location":"overview/point-functions/#Gradus.ConstPointFunctions.filter_intersected","page":"Point functions","title":"Gradus.ConstPointFunctions.filter_intersected","text":"filter_intersected(m::AbstractMetricParams, gp::AbstractGeodesicPoint, max_time)\n\nA FilterPointFunction that filters geodesics which intersected with the accretion disc. Default: NaN.\n\n\n\n\n\n","category":"constant"},{"location":"overview/point-functions/#Gradus.ConstPointFunctions.affine_time","page":"Point functions","title":"Gradus.ConstPointFunctions.affine_time","text":"affine_time(m::AbstractMetricParams, gp::AbstractGeodesicPoint, max_time)\n\nA PointFunction returning the affine integration time at the endpoint of the geodesic.\n\n\n\n\n\n","category":"constant"},{"location":"overview/point-functions/#Gradus.ConstPointFunctions.shadow","page":"Point functions","title":"Gradus.ConstPointFunctions.shadow","text":"shadow(m::AbstractMetricParams, gp::AbstractGeodesicPoint, max_time)\n\nA PointFunction which colours the shadow of the black hole for any disc-less render. Equivalent to ConstPointFunctions.affine_time ∘ ConstPointFunctions.filter_early_term.\n\n\n\n\n\n","category":"constant"},{"location":"overview/point-functions/#Gradus.ConstPointFunctions.redshift","page":"Point functions","title":"Gradus.ConstPointFunctions.redshift","text":"redshift(m::AbstractMetricParams, gp::AbstractGeodesicPoint, max_time)\n\nCalculate the analytic redshift at a given geodesic point, assuming equitorial, geometrically thin accretion disc. Implementation depends on the metric type. Currently implemented for\n\nGradus.BoyerLindquistAD\nGradus.BoyerLindquistFO\n\nNotes\n\nWraps calls to Gradus._redshift_guard to dispatch different implementations.\n\n\n\n\n\n","category":"constant"},{"location":"#Gradus.jl-Documentation","page":"Home","title":"Gradus.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A pure Julia geodesic integration system built on DifferentialEquations.jl using automatic differentiation (AD) and computer algebra systems (CAS) to efficiently compute the geodesic equation. This package requires only a specification of the non-zero metric components in order to solve the 2nd order geodesic system. Alternatively, an implementation of the four velocity components may be specified to integrate a regular 1st order system.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The motivation behind this package began with an interest in studying reverberation lags around accreting black holes, however the scope has since expanded to facilitate the exploration of generic metrics through time-like, space-like, and null geodesics. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Our aim is to make testing modified Kerr metrics and alternative gravity theories fast.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\" pa=\"0\" ma=\"0\">\n<img width=\"30%\" src=\"assets/uob-astro-grey.png\">\n</p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Gradus.jl allows for drastically different relativistic simulations to be computed with a composable and reusable API, permitting an end user to simply and expressively calculate physical formulae, create observational signatures, and interface with other popular astrophysics tools. Gradus.jl implements a number of high level abstractions, on the path towards a fully parallelized, high performance numerical relativity ecosystem, scalable from personal computers to super computers.","category":"page"},{"location":"#Setup","page":"Home","title":"Setup","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Requires Julia >v1.6. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"First, add Buckets.jl and then add Gradus.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(url=\"https://github.com/fjebaker/Buckets.jl\")\nPlg.add(url=\"https://github.com/astro-group-bristol/Gradus.jl\")","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Gradus.jl is a research tool for calculating geodesic paths in arbitrary space-times. It is currently work-in-progress, and breaking changes are frequent, as the interface is redesigned to match changing use-cases.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is part of a larger developing eco-system of Strong Gravity Codes, created by members of the University of Bristol Astrophysics Group","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fergus Baker (PhD Student)\nDr. Andrew Young (Associate Professor)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more University of Bristol Astrophysics Group codes, see our GitHub organisation.","category":"page"}]
}
