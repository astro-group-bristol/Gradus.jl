var documenterSearchIndex = {"docs":
[{"location":"overview/metrics/#Catalogue-of-metrics","page":"Catalogue of metrics","title":"Catalogue of metrics","text":"","category":"section"},{"location":"overview/metrics/","page":"Catalogue of metrics","title":"Catalogue of metrics","text":"CurrentModule = Gradus","category":"page"},{"location":"overview/metrics/","page":"Catalogue of metrics","title":"Catalogue of metrics","text":"Gradus.jl implements a library of metrics ready to use for integrations and rendering.","category":"page"},{"location":"overview/metrics/","page":"Catalogue of metrics","title":"Catalogue of metrics","text":"Pages = [\"metrics.md\"]\nModules = [Gradus]\nOrder = [:type]","category":"page"},{"location":"overview/metrics/","page":"Catalogue of metrics","title":"Catalogue of metrics","text":"note: Note\nTo implement your own custom metrics, please see Implementing a new metric. If you have a complex metric, please open an issue requesting for it to be added.","category":"page"},{"location":"overview/metrics/#Currently-available-metrics","page":"Catalogue of metrics","title":"Currently available metrics","text":"","category":"section"},{"location":"overview/metrics/","page":"Catalogue of metrics","title":"Catalogue of metrics","text":"Modules = [Gradus]\nFilter = t -> typeof(t) === UnionAll && t <: Gradus.AbstractMetric","category":"page"},{"location":"overview/metrics/#Gradus.DilatonAxion","page":"Catalogue of metrics","title":"Gradus.DilatonAxion","text":"struct DilatonAxion{T} <: AbstractStaticAxisSymmetric{T}\n\nEinstein-Maxwell-Dilaton-Axion metric.\n\nM: Singularity mass. Default: 1.0\na: Singularity spin. Default: 0.0\nβ: Dilaton coupling strength. Default: 0.0\nb: Axion coupling strength. Default: 1.0\n\n\n\n\n\n","category":"type"},{"location":"overview/metrics/#Gradus.JohannsenMetric","page":"Catalogue of metrics","title":"Gradus.JohannsenMetric","text":"struct JohannsenMetric{T} <: AbstractStaticAxisSymmetric{T}\n\nThe Johannsen (20xx) metric.\n\nM: Black hole mass. Default: 1.0\na: Black hole spin. Default: 0.0\nα13: alpha_13 deviation parameter. Default: 0.0\nα22: alpha_22 deviation parameter. Default: 0.0\nα52: alpha_52 deviation parameter. Default: 0.0\nϵ3: epsilon_3 deviation parameter. Default: 0.0\n\n\n\n\n\n","category":"type"},{"location":"overview/metrics/#Gradus.JohannsenPsaltisMetric","page":"Catalogue of metrics","title":"Gradus.JohannsenPsaltisMetric","text":"struct JohannsenPsaltisMetric{T} <: AbstractStaticAxisSymmetric{T}\n\nJohannsen and Psaltis 2011\n\nM: Black hole mass. Default: 1.0\na: Black hole spin. Default: 0.0\nϵ3: epsilon_3 deviation parameter. Default: 0.0\n\n\n\n\n\n","category":"type"},{"location":"overview/metrics/#Gradus.KerrMetric","page":"Catalogue of metrics","title":"Gradus.KerrMetric","text":"struct KerrMetric{T} <: AbstractStaticAxisSymmetric{T}\n\nThe Kerr metric in Boyer-Lindquist coordinates, describing a black hole with mass M and angular spin a:\n\nbeginalign*\n    textds^2 =\n    - left( 1 - frac2 M rSigma right)textdt^2\n    - frac2M r a sin^2(theta)Sigma textdt textdphi\n    \n    + fracSigmaDelta textdr^2\n    + Sigma textdtheta^2\n    + left(r^2 + a^2 + frac2 M r a^2 sin^2(theta)Sigma right) sin^2(theta) textdphi^2\nendalign*\n\nwhere\n\nSigma = r^2 + a^2 cos^2 (theta)\nquad textand quad\nDelta = r^2 - 2Mr + a^2\n\nParameters\n\nM: Black hole mass. Default: 1.0\na: Black hole spin. Default: 0.0\n\n\n\n\n\n","category":"type"},{"location":"overview/metrics/#Gradus.KerrNewmanMetric","page":"Catalogue of metrics","title":"Gradus.KerrNewmanMetric","text":"struct KerrNewmanMetric{T} <: AbstractStaticAxisSymmetric{T}\n\n\n\n\n\n","category":"type"},{"location":"overview/metrics/#Gradus.KerrRefractive","page":"Catalogue of metrics","title":"Gradus.KerrRefractive","text":"struct KerrRefractive{T} <: AbstractStaticAxisSymmetric{T}\n\nKerr metric in Boyer-Lindquist coordintes with a path-length ansatz, equivalent to a refractive index n, within the coronal radius corona_radius.\n\nM: Black hole mass. Default: 1.0\na: Black hole spin. Default: 0.0\nn: Refractive index within the corona. Default: 1.0\ncorona_radius: Radius of the corona. Default: 20.0\n\n\n\n\n\n","category":"type"},{"location":"overview/metrics/#Gradus.KerrSpacetimeFirstOrder","page":"Catalogue of metrics","title":"Gradus.KerrSpacetimeFirstOrder","text":"A first-order implementation of KerrMetric.\n\nM: Black hole mass. Default: 1.0\na: Black hole spin. Default: 0.0\nE: Geodesic energy (a consant of motion). Default: 1.0\n\n\n\n\n\n","category":"type"},{"location":"overview/metrics/#Gradus.MorrisThorneWormhole","page":"Catalogue of metrics","title":"Gradus.MorrisThorneWormhole","text":"struct MorrisThorneWormhole{T} <: AbstractStaticAxisSymmetric{T}\n\nMorris-Thorne wormhole metric.\n\nb: Throat size. Default: 1.0\n\n\n\n\n\n","category":"type"},{"location":"overview/geodesic-integration/#Geodesic-integration-strategies","page":"Geodesic integration","title":"Geodesic integration strategies","text":"","category":"section"},{"location":"overview/geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"CurrentModule = Gradus","category":"page"},{"location":"overview/geodesic-integration/#Second-Order","page":"Geodesic integration","title":"Second-Order","text":"","category":"section"},{"location":"overview/geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"The motivation behind the second-order methods is to permit the computation of geodesics in generic spacetimes, via the geodesic equation:","category":"page"},{"location":"overview/geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"Gradus.compute_geodesic_equation","category":"page"},{"location":"overview/geodesic-integration/#Gradus.compute_geodesic_equation","page":"Geodesic integration","title":"Gradus.compute_geodesic_equation","text":"compute_geodesic_equation(ginv, j1, j2, v) -> Any\n\n\nUsing the inverse metric ginv, the Jacobian of the metric for r and theta, j1 and j2 respectively, and velocity four-vector v, calculates the four-acceleration via the geodesic equation.\n\nReturns the components of fractextd^2 u^mutextd lambda^2 via\n\nfractextd^2 u^mutextd lambda^2\n    + Gamma^mu_phantommunusigma\n    fractextdu^nutextd lambda\n    fractextdu^sigmatextd lambda\n= 0\n\nwhere x^mu is a position four-vector, Gamma^mu_phantommunusigma are the Christoffel symbols of the second kind, and lambda the affine parameter describing the curve.\n\nThe Christoffel symbols Gamma^mu_phantommunusigma are defined\n\nGamma^mu_phantommunusigma\n= frac12 g^murho left(\n    partial_nug_rho sigma\n    + partial_sigmag_rho nu\n    - partial_rhog_sigma nu\nright)\n\nLimitations:\n\ncurrenly pre-supposes static, axis-symmetric metric.\n\nNotes\n\nThis function is symbolically pre-computed using the following code:\n\nusing Symbolics, Tullio\n@variables ginv[1:5], j1[1:5], j2[1:5], v[1:4] # non zero metric components\ninverse_metric = [\n    ginv[1] 0 0 ginv[5]\n    0 ginv[2] 0 0\n    0 0 ginv[3] 0\n    ginv[5] 0 0 ginv[4]\n]\nj1_mat = [\n    j1[1] 0 0 j1[5]\n    0 j1[2] 0 0\n    0 0 j1[3] 0\n    j1[5] 0 0 j1[4]\n]\nj2_mat = [\n    j2[1] 0 0 j2[5]\n    0 j2[2] 0 0\n    0 0 j2[3] 0\n    j2[5] 0 0 j2[4]\n]\nj0 = zeros(Float64, (4, 4))\njacobian = (j0, j1_mat, j2_mat, j0)\n# christoffel symbols\n@tullio Γ[i, k, l] :=\n    1 / 2 *\n    inverse_metric[i, m] *\n    (jacobian[l][m, k] + jacobian[k][m, l] - jacobian[m][k, l])\n# compute geodesic equation\n@tullio δxδλ[i] := -v[j] * Γ[i, j, k] * v[k]\n\n\n\n\n\n","category":"function"},{"location":"overview/geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"The above can be solved as a second-order ODE, subject to an initial position and initial velocity","category":"page"},{"location":"overview/geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"u^mu = left(t r theta phi right)\nquad\ntextand\nquad\ndotu^mu  \n    = left( dott dotr dottheta dotphi right)","category":"page"},{"location":"overview/geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"where the dot refers to the derivative with respect to lambda. In general, the spatial components of the initial velocity are known a priori, and the time-component is determined via the constraint:","category":"page"},{"location":"overview/geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"Gradus.constrain_time","category":"page"},{"location":"overview/geodesic-integration/#Gradus.constrain_time","page":"Geodesic integration","title":"Gradus.constrain_time","text":"constrain_time(g_comp, v, μ = 0.0, positive::Bool = true)\n\nConstrains the time component of the four-velocity v, given metric components g_comp and effective mass μ.\n\ng_sigmanu dotu^sigma dotu^nu = -mu^2\n\nfor v^t. The argument positive allows the sign of mu to be changed. true corresponds to time-like geodesics, false to space-like.\n\nThis function should rarely be directly called, and instead is invoked by constrain.\n\nLimitations:\n\ncurrenly pre-supposes static, axis-symmetric metric.\n\n\n\n\n\n","category":"function"},{"location":"overview/geodesic-integration/#Using-callbacks","page":"Geodesic integration","title":"Using callbacks","text":"","category":"section"},{"location":"api-documentation/Gradus/#Full-API-documentation","page":"Gradus","title":"Full API documentation","text":"","category":"section"},{"location":"api-documentation/Gradus/","page":"Gradus","title":"Gradus","text":"CurrentModule = Gradus","category":"page"},{"location":"api-documentation/Gradus/","page":"Gradus","title":"Gradus","text":"tracegeodesics\ninverse_metric_components\nGradus.metric_jacobian\nGradus.intersects_geometry\nGradus.build_collision_callback\nGradus.jsf_algorithm","category":"page"},{"location":"api-documentation/Gradus/#Gradus.tracegeodesics","page":"Gradus","title":"Gradus.tracegeodesics","text":"tracegeodesics(\n    m::AbstractMetric,\n    x, v, [disc], λ_domain;\n    kwargs...\n)\ntracegeodesics(\n    m::AbstractMetric,\n    x, p::AbstractImagePlane, [disc], λ_domain;\n    kwargs...\n)\ntracegeodesics(\n    m::AbstractMetric,\n    model::AbstractCoronaModel, [disc], λ_domain;\n    kwargs...\n)\n\nTrace a geodesic in the spacetime given by m with initial four-position x and four-velocity v.\n\nIf both x and v are arrays of SVector, then many geodesics are traced in parallel.\nIf x is an SVector and the third argument is of type AbstractImagePlane, then every geodesic\n\nof the image plane is traced in parallel.\n\nIf x is an SVector and v is a function, then trajectories must be specified as a kwarg, and tracing is performed\n\nin parallel.\n\nThe functional form for the velocity must map an index to a velocity\n\nfunction velocity_function(i)\n    return SVector(...)\nend\n\nThe possible keyword arguments are\n\n    chart = chart_for_metric(m),\n    callback = nothing,\n    solver = Tsit5(),\n    ensemble = EnsembleThreads(),\n    trajectories = nothing,\n    abstol = 1e-9,\n    reltol = 1e-9,\n    solver_opts...,\n\nwith solver_opts being forwarded to the SciML solve function.\n\n\n\n\n\n","category":"function"},{"location":"api-documentation/Gradus/#Gradus.GradusBase.inverse_metric_components","page":"Gradus","title":"Gradus.GradusBase.inverse_metric_components","text":"inverse_metric_components(g_comp)\n\nCalculates g^tt, g^rr, g^thetatheta, g^phiphi, g^tphi of a static, axis-symmetric metric from g_tt, g_rr, g_thetatheta, g_phiphi, g_tphi using a symbolically computed inverse matrix method.\n\nNotes\n\nTo recreate:\n\nusing Symbolics\n@variables g[1:5] # non zero metric components\nmetric = [\n    g[1] 0 0 g[5]\n    0 g[2] 0 0\n    0 0 g[3] 0\n    g[5] 0 0 g[4]\n]\ninv(metric)\n\n\n\n\n\n","category":"function"},{"location":"api-documentation/Gradus/#Gradus.metric_jacobian","page":"Gradus","title":"Gradus.metric_jacobian","text":"metric_jacobian(m::AbstractStaticAxisSymmetric{T}, rθ)\n\nCalculate the value and Jacobian elements of the metric with respect to r and theta.\n\nLimitations:\n\ncurrenly pre-supposes static, axis-symmetric metric.\n\nNotes\n\nFunction body is equivalent to\n\nf = x -> metric_components(m, x)\nJ = ForwardDiff.vector_mode_jacobian(f, rθ)\nf(rθ), J\n\nbut non-allocating.\n\n\n\n\n\n","category":"function"},{"location":"api-documentation/Gradus/#Gradus.intersects_geometry","page":"Gradus","title":"Gradus.intersects_geometry","text":"intersects_geometry(m::AbstractAccretionGeometry{T}, line_element)\n\nUtility function. Returns a boolean dependent on whether line_element intersects with the geometry (true) or not (false). Uses in_nearby_region to optimze and calls has_intersect to determine intersection.\n\n\n\n\n\n","category":"function"},{"location":"api-documentation/Gradus/#Gradus.jsf_algorithm","page":"Gradus","title":"Gradus.jsf_algorithm","text":"jsf_algorithm(V₁::T, V₂::T, V₃::T, Q₁::V, Q₂::V; ϵ = 1e-8)\n\nImplemented from Jiménez, Segura, Feito. Computation Geometry 43 (2010) 474-492.\n\nSee this blog post for a discussion.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"Pages = [\"examples.md\"]\nDepth = 3","category":"page"},{"location":"examples/examples/#Tracing-geodesic-paths","page":"Examples","title":"Tracing geodesic paths","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using Gradus\nusing Plots\nusing StaticArrays\n\nm = JohannsenPsaltisMetric(M=1.0, a=0.6, ϵ3=2.0)\n# observer position\nu = @SVector [0.0, 1000.0, π/2, 0.0]\n\n# set up impact parameter space\nα = collect(range(-10.0, 10.0, 20))\nβ = [0.0 for _ in α]\n\n# build initial velocity and position vectors\nvs = map_impact_parameters(m, u, α, β)\nus = [u for _ in vs]\n\nsols = tracegeodesics(\n    m, us, vs, (0.0, 2000.0);\n    abstol = 1e-12, reltol = 1e-12\n)\n\n# only use the subset of the solution we're plotting\ntrange = range(990, 1035, 5000)\n\np = plot(projection = :polar, legend = false, range = (0, 10))\nfor s in sols\n    r = [s(t)[2] for t in trange]\n    ϕ = [s(t)[4] for t in trange]\n    plot!(p, ϕ, r)\nend\n\n# plot event horizon \nr0 = inner_radius(m)\nplot!(p, collect(range(0, 2π, 200)), [r0 for _ in 1:200], color = :black, linewidth = 2)","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#Shadow","page":"Examples","title":"Shadow","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using Gradus\nusing Plots\n\nm = KerrMetric(1.0, 0.998)\nu = SVector(0.0, 1000.0, π / 2, 0.0)\n\nα, β, img = rendergeodesics(\n    m,\n    u,\n    # max integration time\n    2000.0,\n    image_width = 1000,\n    image_height = 1000,\n    fov = 70.0,\n    verbose = true,\n    # geodesics can get much closer to the event horizon than \n    # normal\n    closest_approach = 1.001,\n    ensemble = Gradus.EnsembleEndpointThreads(),\n)\n\np = heatmap(\n    α,\n    β,\n    img,\n    color = :grayC,\n    xlabel = \"α\",\n    ylabel = \"β\",\n    aspect_ratio = 1,\n    minorgrid = true,\n)\ncontour!(p, α, β, img, color = :red)","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#Redshift-image","page":"Examples","title":"Redshift image","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"note: Note\nThe Gradus.ConstPointFunctions.redshift function is an analytic solution for redshift, which may not be implemented for every type of metric or disc geometry. See Interpolating redshifts for a more flexible numeric alternative.","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using Gradus\nusing StaticArrays\nusing Plots\n\n# metric and metric parameters\nm = KerrMetric(M=1.0, a=1.0)\n# observer position\nu = @SVector [0.0, 1000.0, deg2rad(60), 0.0]\n# accretion disc\nd = GeometricThinDisc(1.0, 50.0, deg2rad(90))\n\n# define point function which filters geodesics that intersected the accretion disc\n# and use those to calculate redshift\npf = ConstPointFunctions.redshift(m, u) ∘ ConstPointFunctions.filter_intersected\n\nα, β, img = rendergeodesics(\n    m,\n    u,\n    d,\n    # maximum integration time\n    2000.0,\n    fov = 6.0,\n    image_width = 700,\n    image_height = 240,\n    verbose = true,\n    pf = pf\n)\n\nheatmap(α, β, img)","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#Redshift-line-profile","page":"Examples","title":"Redshift line-profile","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"Using the redshift example, we can bin a redshift line-profile using StatsBase.jl. We'll calculate the iron line redshift profile, with a delta-emission at 6.4 keV.","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using StatsBase\n\n# remove nans and flatten the redshift image\nredshift_data = filter(!isnan, vec(img))\n\n# transpose to iron-line\ndata = redshift_data .* 6.4\n\nx_bins = range(0.0, 10.0, 100) \nlineprof = fit(Histogram, data, x_bins)\n\nplot(x_bins[1:end-1], lineprof.weights, seriestype = :steppre)","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#Line-profiles","page":"Examples","title":"Line profiles","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"Line profiles may be calculated using two different methods – using image-plane binning and integrating Cunningham transfer functions – both of which are implemented in Gradus.jl. By default, the Cunningham transfer function method is used, however passing either BinnedLineProfile() or CunninghamLineProfile() as the first argument to lineprofile allows for explicit specification of the algorithm.","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"For a simple maximally-spinning Kerr black hole, the iron line profile (with a delta emission line at 6.4 keV) may be calculated with:","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"d = GeometricThinDisc(0.0, 400.0, π / 2)\nu = @SVector [0.0, 1000.0, deg2rad(40), 0.0]\nm = KerrMetric(1.0, 0.998)\n\n# maximal integration radius\nmaxrₑ = 50.0\n\n# emissivity function\nε(r) = r^(-3)\n\n# g grid to do flux integration over\ngs = range(0.0, 1.2, 500)\n_, flux = lineprofile(gs, ε, m, u, d, maxrₑ = maxrₑ)\n\n# transform to observed energy\nenergy = gs .* 6.4\n\n# plot flux as a function of energy\nplot(energy, flux, legend=false)","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#Reverberation-transfer-functions","page":"Examples","title":"Reverberation transfer functions","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"m = KerrMetric(1.0, 0.998)\nu = SVector(0.0, 1000.0, deg2rad(60), 0.0)\nd = GeometricThinDisc(0.0, 1000.0, π / 2)\n\n# specify coronal geometry\nmodel = LampPostModel(h = 10.0)\n# gridding for the photon plane\nplane = PolarPlane(GeometricGrid(); Nr = 1800, Nθ = 1800)\n\n# integrate source to disc and observer to disc\ntf = @time lagtransfer(\n    model,\n    m,\n    u,\n    plane,\n    d,\n    callback = domain_upper_hemisphere(),\n    n_samples = 100_000,\n    verbose = true,\n)\n\n# bin into a 2d grid, returning the time and energy axis, \n# and the flux in each bin\nt, E, f = binflux(tf, N_E = 1500, N_t = 1500)\n\n# take the log for visualisation purposes\nI = f .> 0\nf[I] .= log.(f[I])\n\np = heatmap(\n    t,\n    E,\n    f,\n    xlabel = \"Time (GM/c^3)\",\n    ylabel = \"Energy (keV)\",\n    xrange = [0, 150],\n    yrange = [0, 9],\n    clims = (-20, -1),\n)","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#Covariant-radiative-transfer","page":"Examples","title":"Covariant radiative transfer","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"# metric and metric parameters\nm = KerrMetric(M = 1.0, a = 1.0)\n# observer position\nu = SVector(0.0, 1000.0, deg2rad(80), 0.0)\n# accretion disc\nd = PolishDoughnut(m)\n\n# define point function which reads the auxiliary variable\n# which is contextually the intensity\npf = PointFunction((m, gp, t) -> gp.aux)\n\na, b, img = @time rendergeodesics(\n    m,\n    u,\n    d,\n    # maximum integration time\n    2000.0,\n    fov = 10.0,\n    image_width = 600,\n    image_height = 500,\n    verbose = true,\n    pf = pf,\n    trace = Gradus.TraceRadiativeTransfer(),\n)\n\nheatmap(a, b, img, aspect_ratio = 1, xlabel = \"α\", ylabel = \"β\")","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#Interpolating-redshifts","page":"Examples","title":"Interpolating redshifts","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"In cases where no analytic redshift solution is known, we can instead interpolate a numeric approximation. For example, interpolating the plunging region velocities and using the analytic solution for general static, axis symmetric metrics outside of the ISCO can be achieved with:","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using Gradus\nusing StaticArrays\nusing Plots\n\n# metric and metric parameters\nm = KerrMetric(M=1.0, a=0.4)\n# observer's initial position\nu = @SVector [0.0, 1000.0, deg2rad(85), 0.0]\n# accretion disc\nd = GeometricThinDisc(1.0, 50.0, deg2rad(90))\n\npl_int = interpolate_plunging_velocities(m)\n\nredshift = interpolate_redshift(pl_int, u)\n\npf = redshift ∘ ConstPointFunctions.filter_intersected\n\nα, β, img = rendergeodesics(\n    m,\n    u,\n    d,\n    # maximum integration time\n    2000.0,\n    fov = 6.0,\n    image_width = 700,\n    image_height = 240,\n    verbose = true,\n    pf = pf\n)\n\nheatmap(α, β, img)","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#Disc-geometries","page":"Examples","title":"Disc geometries","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"Gradus makes it easy to define new height cross sections for thick discs:","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using Gradus\nusing StaticArrays\nusing Plots\n\nm = KerrMetric(1.0, 0.0)\nu = @SVector [0.0, 1000.0, deg2rad(85), 0.0]\n\n# define the disc shape -- return a negative number \n# where the disc should not be intersected, else the cross \n# sectional height\nd = ThickDisc() do u\n    r = u[2]\n    if r < 9.0 || r > 11.0\n        return -1.0\n    else\n        x = r - 10.0\n        sqrt(1 - x^2)\n    end\nend\n\n# and then render as usual\nα, β, img = rendergeodesics(\n    m,\n    u,\n    d,\n    2000.0,\n    fov = 18.0,\n    image_width = 700,\n    image_height = 350,\n    verbose = true,\n    pf = pf\n)\n\nheatmap(α, β, img, aspect_ratio=1)","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"For more disc on disc geometry, see AbstractAccretionDisc and associated sections.","category":"page"},{"location":"examples/examples/#Circular-orbits","page":"Examples","title":"Circular orbits","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"Simple equatorial circular orbits are straight forward to calculate with Gradus.jl:","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using Gradus\nusing Plots\nusing StaticArrays\n\nm = KerrMetric(M=1.0, a=0.8)\n\np = plot(aspect_ratio=1)\n\nfor r in [3.0, 4.0, 5.0, 6.0]\n    v = CircularOrbits.fourvelocity(m, r)\n    # trace the circular orbit\n    path = tracegeodesics(m, @SVector([0.0, r, π/2, 0.0]), v, (0.0, 300.0), μ = 1.0)\n    r = [path(t)[2] for t in range(0.0, 100, 200)]\n    ϕ = [path(t)[4] for t in range(0.0, 100, 200)]\n\n    x = @. r * cos(ϕ)\n    y = @. r * sin(ϕ)\n\n    plot!(p, x, y, label = false)\nend\n\np","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#ISCO","page":"Examples","title":"ISCO","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"The Gradus.isco may be calculated with a simple convenience function, as may the energy associated with a given stable circular orbit.","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using Gradus\nusing Plots\n\n# prepare plot\np = plot(legend=:bottomright, ylabel = \"E\", xlabel = \"r\", xscale = :log10)\n\n# choice of spin to plot energy curves for\nfor a in [0.0, 0.4, 0.6]\n    m = KerrMetric(M = 1.0, a = a)\n\n    rs = range(Gradus.isco(m), 100.0, 500)\n    energy = map(rs) do r\n        CircularOrbits.energy(m, r)\n    end\n\n    plot!(rs, energy, label = \"a=$a\")\nend\n\n# calculate the ISCO as a function of spin\ndata = map(range(-1.0, 0.8, 100)) do a\n    m = KerrMetric(M = 1.0, a = a)\n    r = Gradus.isco(m)\n    CircularOrbits.energy(m, r), r\nend\n\n# overlay onto plot\nplot!(last.(data), first.(data), color=:black, linestyle=:dash, label=\"ISCO\")","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#Event-horizons-and-naked-singularities","page":"Examples","title":"Event horizons and naked singularities","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"Here is an example of how to use event_horizon to plot the shape of an event horizon in two dimensions. In the case of a naked singularity, as with the certain parameters combinations in the JohannsenPsaltisMetric metric, we see a disconnected region in the plot.","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using Gradus\nusing Plots\n\nfunction draw_horizon(p, m)\n    rs, θs = event_horizon(m, resolution = 200)\n    radius = rs\n\n    x = @. radius * cos(θs)\n    y = @. radius * sin(θs)\n    plot!(p, x, y, label = \"a = $(m.a)\")\nend\n\np = plot(aspect_ratio = 1)\nfor a in [0.0, 0.5, 0.6, 0.7, 0.8]\n    m = JohannsenPsaltisMetric(M = 1.0, a = a, ϵ3 = 2.0)\n    draw_horizon(p, m)\nend\np","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"We can also calculate parameter combinations that lead to naked singularities, and plot the parameter space domains to show exclusion zones:","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"function calc_exclusion(as, ϵs)\n    regions = [\n        is_naked_singularity(JohannsenPsaltisMetric(M = 1.0, a = a, ϵ3 = ϵ))\n        for a in as, ϵ in ϵs\n    ]\n\n    map(i -> i ? 1.0 : NaN, regions)\nend\n\n# define ranges (small in this example as a little computationally intense)\nas = range(0, 1.0, 40)\nϵs = range(-10, 10, 40)\n\nimg = calc_exclusion(as, ϵs)\nheatmap(\n    as, \n    ϵs, \n    img', \n    color = :black, \n    colorbar = false, \n    xlabel = \"a\", \n    ylabel = \"ϵ\"\n)","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#Cunningham-transfer-functions","page":"Examples","title":"Cunningham transfer functions","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"Recreating Fig. 1 and 2 from Bambi et al. (2017) for the transfer functions of a Kerr black hole","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using Gradus\nusing StaticArrays\nusing Plots\n\nm = KerrMetric(M=1.0, a=0.998)\nd = GeometricThinDisc(0.0, 100.0, π/2)\n\np = plot(legend = false)\nfor angle in [3, 35, 50, 65, 74, 85]\n    u = @SVector [0.0, 1000.0, deg2rad(angle), 0.0]\n    ctf = cunningham_transfer_function(\n        m, u, d, 4.0\n    )\n    mask = @. (ctf.g✶ > 0.001) & (ctf.g✶ < 0.999)\n    @views plot!(p, ctf.g✶[mask], ctf.f[mask])\nend\np","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"And Fig. 2:","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"# new position vector\nu = @SVector [0.0, 1000.0, deg2rad(30), 0.0]\n\np = plot(legend = false)\nfor a in [0.0, 0.25, 0.5, 0.75, 0.9, 0.998]\n    m = KerrMetric(1.0, a)\n    ctf = cunningham_transfer_function(\n        m, u, d, 7.0\n    )\n    mask = @. (ctf.g✶ > 0.001) & (ctf.g✶ < 0.999)\n    @views plot!(p, ctf.g✶[mask], ctf.f[mask])\nend\np","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/examples/#Concentric-rings","page":"Examples","title":"Concentric rings","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"Recreating Figure 2 from Johannsen and Psaltis (2012, II):","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"using Gradus\nusing StaticArrays\nusing Plots\n\n# their papers has a=-a\nm = KerrMetric(M=1.0, a=-0.4)\nu = @SVector [0.0, 1000, acos(0.25), 0.0]\nd = GeometricThinDisc(0.0, 100.0, π / 2)\n\nradii = 2.6:1.0:7.6\n\np = plot(\n    aspect_ratio = 1,\n    legend = false,\n)\n\n# crosshair on origin\nhline!(p, [0.0], color = :black, linestyle=:dash)\nvline!(p, [0.0], color = :black, linestyle=:dash)\n\nfor r in radii\n    α, β = impact_parameters_for_radius(m, u, d, r, N=100)\n    plot!(p, α, β)\nend\np","category":"page"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"internals/custom-metrics/#Implementing-a-new-metric","page":"Implementing new metrics","title":"Implementing a new metric","text":"","category":"section"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"CurrentModule = Gradus","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"Gradus.jl is able to integrate any 3+1 dimensional metric. A new metric may be defined by implementing one of the abstract types with a concrete type, and defining a number of methods. Depending on what you want to be able to do with a metric, different functions need to be implemented. ","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"Gradus also provides a few derivative abstract types to implement to ensure the most efficient code is executed for a given metric (see Metric parameter types below).","category":"page"},{"location":"internals/custom-metrics/#Example:-Schwarzschild","page":"Implementing new metrics","title":"Example: Schwarzschild","text":"","category":"section"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"As a minimal example, here is how the Schwarzschild metric may be implemented. First, we must define what the metric parameters for this metric are. These are effectively constants of the spacetime, representing physical quantities that appear in the metric expression. For the Schwarzschild metric, this is only the black hole mass M, but e.g. the Kerr metric also has the black hole spin a.","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"We can choose the integration strategy by sub-typing an abstract type representing different classes of spacetimes. For the Schwarzschild metric, we will use the static, axis-symmetric class, with the automatic differentiation (AD) backend. With AD, we only need to specify the non-zero components of the metric as Julia functions, and the rest is done for us.","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"For ease, we choose the Eddington-Finkelstein coordinates of the Schwarzschild solution, which may be written","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"textds^2 =\n    - left( 1 - frac2 Mr right) textdt^2\n    + left( 1 - frac2 Mr right)^-1 textdr^2\n    + r^2 textdtheta^2\n    + r^2 sin^2(theta) textdphi^2","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"Here is a possible implementation for Gradus.jl:","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"using Gradus\n\n@with_kw struct EddingtonFinkelsteinAD{T} <: AbstractStaticAxisSymmetric{T}\n    M = 1.0\nend\n\nfunction GradusBase.metric_components(m::EddingtonFinkelsteinAD{T}, rθ) where {T}\n    (r, θ) = rθ\n    M = m.M\n\n    tt = -(1 - (2M / r))\n    rr = -inv(tt)\n    θθ = r^2\n    ϕϕ = r^2 * sin(θ)^2\n\n    (tt, rr, θθ, ϕϕ, T(0.0))\nend\n\nGradusBase.inner_radius(m::EddingtonFinkelsteinAD) = 2 * m.M","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"A few notes:","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"We use @with_kw from Parameters.jl to define various utility constructors for us.\nGradusBase.metric_components must return five elements for AbstractStaticAxisSymmetric, where the last element is the off-axis g_t phi matrix element, which in this case is always 0.\nThe GradusBase.inner_radius function defines the inner-radius of integration chart. This defines where the integration should terminate to avoid running indefinitely, and is, in this case, set to the event-horizon of our metric.","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"That's all we need! This metric is now ready to be traced in the usual way.","category":"page"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"note: Note\nFor more examples of how to implement different metrics, click on the \"source\" button of a metric in Implemented Metrics. Alternatively, view the source code directly here.","category":"page"},{"location":"internals/custom-metrics/#Metric-parameter-types","page":"Implementing new metrics","title":"Metric parameter types","text":"","category":"section"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"The following types may be implemented to add new metrics. Each type has different requirements for its interface.","category":"page"},{"location":"internals/custom-metrics/#First-Order","page":"Implementing new metrics","title":"First-Order","text":"","category":"section"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"AbstractFirstOrderMetric\nGradus.four_velocity\nGradus.calc_lq\nGradus.Vr\nGradus.Vθ","category":"page"},{"location":"internals/custom-metrics/#Gradus.AbstractFirstOrderMetric","page":"Implementing new metrics","title":"Gradus.AbstractFirstOrderMetric","text":"AbstractFirstOrderMetric{T} <: AbstractMetric{T}\n\nAbstract type for metrics using the 1st-order integration method. The 1st-order methods reuse the velocity vector as a parameter vector, where only element vel[2] and vel[3] are used, and are local observer ratios sin Theta and sin Phi respectively.\n\nRequire implementation of\n\ninner_radius\nconstrain\nfour_velocity\ncalc_lq\nVr\nVθ\nimpact_parameters_to_three_velocity\n\n\n\n\n\n","category":"type"},{"location":"internals/custom-metrics/#Gradus.four_velocity","page":"Implementing new metrics","title":"Gradus.four_velocity","text":"four_velocity(\n    u,\n    m::AbstractFirstOrderMetric,\n    p\n) -> NTuple{4, Any}\n\n\nCalculate the four-velocity at a point u, given a set of metric parameters and the constants of motion in p.\n\n\n\n\n\n","category":"function"},{"location":"internals/custom-metrics/#Gradus.calc_lq","page":"Implementing new metrics","title":"Gradus.calc_lq","text":"calc_lq(\n    m::AbstractFirstOrderMetric{T},\n    pos,\n    param\n) -> Tuple{Any, Any}\n\n\nCalculate constants of motion L and Q, given a set of metric parameters, the geodesic position, and the param vector.\n\n\n\n\n\n","category":"function"},{"location":"internals/custom-metrics/#Gradus.Vr","page":"Implementing new metrics","title":"Gradus.Vr","text":"Vr(m::AbstractFirstOrderMetric{T}, u, p) -> Any\n\n\nEffective potential in the radial direction. Used only to track sign changes.\n\n\n\n\n\n","category":"function"},{"location":"internals/custom-metrics/#Gradus.Vθ","page":"Implementing new metrics","title":"Gradus.Vθ","text":"Vθ(m::AbstractFirstOrderMetric{T}, u, p) -> Any\n\n\nEffective potential in the angular direction. Used only to track sign changes.\n\n\n\n\n\n","category":"function"},{"location":"internals/custom-metrics/#Second-Order","page":"Implementing new metrics","title":"Second-Order","text":"","category":"section"},{"location":"internals/custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"metric_components\nAbstractStaticAxisSymmetric","category":"page"},{"location":"internals/custom-metrics/#Gradus.GradusBase.metric_components","page":"Implementing new metrics","title":"Gradus.GradusBase.metric_components","text":"metric_components(m::AbstractStaticAxisSymmetric, rθ) -> Any\n\n\nInterface for AbstractStaticAxisSymmetric. Should return a vector or tuple with the elements\n\nleft(\n    g_tt g_rr g_theta theta g_phi phi g_tphi\nright)\n\n\n\n\n\nmetric_components(m::AbstractMetric{T}, x)\n\nReturn a tuple with each non-zero metric component for the metric described by m at position x. Note that the position need not be a four-vector, and for specific implementations may only be a subset of the total manifold coordinates. See specific implementations for subtypes of AbstractMetric for details.\n\n\n\n\n\n","category":"function"},{"location":"internals/custom-metrics/#Gradus.GradusBase.AbstractStaticAxisSymmetric","page":"Implementing new metrics","title":"Gradus.GradusBase.AbstractStaticAxisSymmetric","text":"AbstractStaticAxisSymmetric{T}\n\nSpecialisation for static, axis-symmetric metrics. Here, the metric is of the form\n\n    g_munu =\n    left( beginmatrix\n        g_tt      0       0                   g_tphi     \n        0           g_rr  0                   0              \n        0           0       g_thetatheta  0              \n        g_tphi  0       0                   g_phiphi\n    endmatrix right)\n\nwhere the only non-zero off axis elements are g_tphi.\n\nRequired implementations:\n\ninner_radius\nmetric_components\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"CurrentModule = Gradus","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Unlike conventional ray-tracing, ray-tracing in general relativity (GR) has the added complication that the trajectory of light is altered by the curvature of space. In particular, the spacetime around compact singularities, such as black holes, may be significantly curved in weird and wonderful ways, depending on the nature of the object being studied. When attempting to visualise or calculate observational signatures related to these objects, is important to account for so-called GR effects: these effects not only alter how things look, but also the energetics of the system itself.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"This short getting-started guide should hopefully tour you through some of the features of Gradus.jl, and how it can be used to study accretion processes, and different spacetimes.","category":"page"},{"location":"getting-started/#Defining-a-spacetime","page":"Getting started","title":"1 Defining a spacetime","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"geodesic_equation","category":"page"},{"location":"getting-started/#Gradus.GradusBase.geodesic_equation","page":"Getting started","title":"Gradus.GradusBase.geodesic_equation","text":"geodesic_equation(m::AbstractMetric, x, v)\n\nCalculate the four-acceleration of the geodesic equation for a spacetime given by the metric m, four-position x and four-velocity v.\n\nA geodesic is the shortest path connecting two points in space. For flat space, this is just a straight line. In curved space, geodesics are analogous to straight lines between points (e.g. the great circle on a sphere).\n\nThe geodesic equation calculates the acceleration experienced by a particle at position x^mu = (t r theta phi) travelling with tangential velocity v^nu = textd x  textd lambda due to the curvature of spacetime. The curvature is calculated from the metric, encoded in the  Christoffel symbols. The acceleration is then calculated via\n\nfractextd^2 x^mutextd lambda^2\n    = - Gamma^mu_phantommunusigma\n    fractextdx^nutextd lambda\n    fractextdx^sigmatextd lambda\n\nwhere Gamma^mu_phantommunusigma are the Christoffel symbols (of the second kind), and lambda is an affine parameter that parameterizes the solution.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The workhorse of Gradus.jl is tracegeodesics. This function is responsible to setting up ordinary differential equation and solving them, either sequentially, in parallel, or on different hardware. To get started, we must minimally choose a spacetime to trace in, an initial position and an initial velocity for our test photon. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To demonstrate of the features in the library, we will choose the simplest Schwarzschild spacetime, which describes a spherically symmetric black hole with mass M. We will implement this metric ourselves.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nMany metrics have already been implemented in Gradus.jl; for a comprehensive list, see Catalogue of metrics.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"using Gradus\n\nstruct Schwarzschild{T} <: AbstractStaticAxisSymmetric{T}\n    M::T\nend\n\nfunction Gradus.metric_components(m::Schwarzschild, x)\n    r, θ = x\n    M = m.M\n\n    dt2 = -(1 - (2M / r))\n    dr2 = -inv(dt2)\n    dθ2 = r^2\n    dϕ2 = r^2 * sin(θ)^2\n    dtdϕ = zero(r)\n\n    SVector(dt2, dr2, dθ2, dϕ2, dtdϕ)\nend\n\nGradus.inner_radius(m::Schwarzschild) = 2 * m.M","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Going through this line by line:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"struct Schwarzschild{T} <: AbstractStaticAxisSymmetric{T}\n    M::T\nend","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"First we define a struct that will parameterise our spacetime. In this case, the mass M. We declare our struct to be a subtype of AbstractStaticAxisSymmetric since we know our metric will be static (no time dependence) and axis-symmetric (no phi dependence). This describes the more general Petrov type D class of spacetimes, and allows Gradus.jl to make a number of simplifying assumptions under the hood about how this spacetime will behave. \nThe T parameter is the number type of this metric, and dictates the precision of all numerics in the trace. Therefore, if M is a Float32, Gradus.jl will raise errors if you attempt 64-bit floating point operations when tracing. This is by design, since many GPU architectures prefer Float32 for speed, especially when precision is less important, and throwing errors is preferable to debugging type coercions. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"function Gradus.metric_components(m::Schwarzschild, x)\n    r, θ = x\n    M = m.M\n\n    dt2 = -(1 - (2M / r))\n    dr2 = -inv(dt2)\n    dθ2 = r^2\n    dϕ2 = r^2 * sin(θ)^2\n    dtdϕ = zero(r)\n\n    SVector(dt2, dr2, dθ2, dϕ2, dtdϕ)\nend","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Here we have given the actual implementation of our metric. Since the metric is static, axis-symmetric, the position vector x only contains the radial and poloidal coordinates, and expects the metric_components function to return the five matrix elements of the metric. For the Schwarzschild metric, the textdt textdphi component is zero everywhere. We set this to zero(r), which is a Julia function that returns 0 but of the same type as r.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nCurrently, Gradus.jl uses exclusively Boyer-Lindquist coordinates for its metrics. However, new coordinates can be implemented, and documentation for this will come soon.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"GradusBase.inner_radius(m::KerrMetric) = 2 * m.M","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Finally, we specify some inner radius for the integration. This is the cutoff around the origin at which radius the geodesic integration will stop to avoid numerical errors. Here, it is just the Schwarzschild radius, or the outer event horizon. Gradus.jl can calculate different horizons from the metric automatically, which can be useful if you don't know the solution ahead of time, or if the solution is non-symmetric in theta. But if we know it, we can benefit from a small performance boost by implementing it directly.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nFor a full description of implementing a metric, see Implementing a new metric.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"If you're familiar with other GRRT softwares, you might be wondering \"where do we define the Christoffel symbols?\", or \"do I not need a prescription for Carter's constant?\". Thanks to automatic differentiation (AD), we can calculate the Christoffel symbols on the fly! We determine the metric Jacobian with respect to coordinates of interest, and then sparsely compute the Christoffel symbols for the given spacetime class. For full details, see Geodesic integration strategies.","category":"page"},{"location":"getting-started/#Photon-trajectories","page":"Getting started","title":"2 Photon trajectories","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The metric parameters and position can be easily and arbitrarily chosen, however the velocity has a precondition which must be satisfied.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"constrain","category":"page"},{"location":"getting-started/#Gradus.GradusBase.constrain","page":"Getting started","title":"Gradus.GradusBase.constrain","text":"constrain(m::AbstractMetric, x, v; μ=0)\n\nCalculate the time component v^t of a velocity vector v, which would constrain the vector at a position x as a  geodesic with invariant mass μ.\n\nThe velocity vector needs to only specify the v^r, v^theta, and v^phi component, as the v^t is constrained in GR by\n\ng_sigmanu v^sigma v^nu = -mu^2\n\nwhere mu^2 is the invariant mass of the particle. This furthermore permits a choice of geodesic to trace. The choices correspond to\n\nμ = 0.0 (default): null geodesic\nμ > 0.0: time-like geodesic\nμ < 0.0: space-like geodesic\n\n\n\n\n\n","category":"function"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The constrain function is automatically invoked by tracegeodesics to normalize velocity vectors appropriately.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We'll position ourselves at a great distance from the singularity at the origin, around 1000  r_textg away. We'll furthermore setup our spacetime with an arbitrary choice of mass M = 1.0, which acts to rescale our system (since all units in Gradus.jl are in standard GR units).","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The initial velocity vector we will somewhat arbitrarily set to be directed towards the black hole (v^r = -1), with a small v^phi component so it grazes past the singularity.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The trajectory is calculated with a call to tracegeodesics:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"m = Schwarzschild(1.0)\nx = SVector(0.0, 1000.0, π/2, 0.0)\nv = SVector(0.0, -1.0, 0.0, -8e-6)\n\n# maximum affine time ~ 2 * x[2]\nλ_max = 2000.0\nsol = tracegeodesics(m, x, v, λ_max)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The trajectory can be visualized with the use of Plots.jl:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"using Plots\n\n# plot solution trajectory\nplot_paths(sol)\n# plot \nplot_horizon!(m)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Choosing the initial velocity in this manner lacks interpretation. We can instead use so-called impact parameters (alpha beta). These may be thought of as follows: ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"impact_parameters_to_three_velocity","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Finally, if you imagine a two dimensional image plane, where x is the horizontal and y the vertical coordinate, the alpha impact parameter corresponds to that closest approach along the x axis, and beta along the y axis.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Hopefully that makes sense. With this, we can more easily setup a handful of geodesics to trace and know that they will roughly travel close to the central singularity.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"# grid of impact parameters in horizontal direction\n# keeping β fixed at 0\nα = range(-10.0, 10.0, 30)\nvs = map_impact_parameters(m, x, α, 0.0)\n\n# need a position for each velocity vector\nxs = fill(x, size(vs))\n\nsols = tracegeodesics(m, xs, vs, λ_max)\n\n# plot\np = plot_paths(sols, legend=false)\nplot_horizon!(m, color = :black)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"When we invoke tracegeodesics in this way, Gradus.jl will automatically distribute the workload onto as many threads as Julia was started with. For example, starting julia with","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"julia -t6","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"will spawn 6 worker threads for Gradus.jl to use. Passing -tauto will allow Julia to use as many threads as your hardware supports.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nFor more about parallelism in Gradus.jl, see Parallelism and ensembles. ","category":"page"},{"location":"getting-started/#Rendering-an-image","page":"Getting started","title":"3 Rendering an image","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"A common task we'll want to do is render an image; that is, assign some (alpha beta) to each pixel in a 2-dimensional plane, located at the position x. Each pair of impact parameters is then traced along it, and its corresponding pixel coloured according to some function of the geodesic endpoint.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The simplest non-trivial thing we can do is colour the pixel by the time component of the final position. Since we are not interested in what happens to the geodesic along the path, only the start and end points, we can pass save_on = false to tracegeodesics. This tells the solvers to not save intermediary points along the solution, and thereby avoid the overhead of allocating a memory we have no wish to use.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"# set up our image parameters\nα = range(-10.0, 10.0, 100)\nβ = range(-10.0, 10.0, 100)\n\n# this will set up a 100x100 matrix of velocity vectors\n# so we use `vec` to flatten the structure\nvs = vec([map_impact_parameters(m, x, a, b) for a in α, b in β])\nxs = fill(x, size(vs))\n\n# trace in parallel\nsols = tracegeodesics(m, xs, vs, λ_max, save_on = false)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To help us process the solutions, Gradus.jl exports a number of utility functions. There is one in specific we will want to use:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"unpack_solution","category":"page"},{"location":"getting-started/#Gradus.GradusBase.unpack_solution","page":"Getting started","title":"Gradus.GradusBase.unpack_solution","text":"unpack_solution([m], sol)\n\nUnpack a solution (SciMLBase.AbstractODESolution) as a GeodesicPoint, optionally specifying the metric under which quantities are transformed. \n\nIf the solution stores any additional parameters (e.g. intensity in radiative transfer), these will be packed  into the aux field of GeodesicPoint.\n\nExample use\n\nsol = tracegeodesics(m, x, v)\npoint = unpack_solution(sol)\n\n\n\n\n\n","category":"function"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The GeodesicPoint struct contains everything we might want to know about the start and endpoint of a geodesic solution, including four-velocities and the nature of the termination (fell into the black hole, went to infinity, collided with some geometry, etc.). ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We can easily filter those geodesic that fell into the black hole, and extract their final coordinate times x^t(lambda_textfinal):","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"points = unpack_solution.(sols.u)\n# reshape into the same dimensions as the image\npoints = reshape(points, (100, 100))\n\ntimes = map(points) do gp\n    # check if went off the integration chart on the inner boundary\n    if gp.status == StatusCodes.WithinInnerBoundary\n        # get the time coordinate\n        gp.x[1]\n    else\n        NaN\n    end\nend\n\nheatmap(α, β, times, aspect_ratio = 1)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"This is the so-called shadow of a black hole.","category":"page"},{"location":"getting-started/#Defining-and-using-PointFunctions","page":"Getting started","title":"4 Defining and using PointFunctions","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The above is a little verbose, when all we really wanted to do trace a given grid of (alpha beta), and then compute some physical quantity at each pixel. Having to manually write out the for loop and remember to reshape the solutions array is a trifle unnecessary and error-prone. Furthermore, to someone reading our code, it may not always be obvious what physical quantity it is that we are calculating from just the for loop.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Gradus.jl instead uses a callback function, which in its own parlance is dubbed the PointFunction. These functions are isolated small physical quantities, that allow us to compose a more complex observable. Many point functions have already been implemented ready for use.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"As a motivating example, say we wanted to write the above as a PointFunction:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"time_coord = PointFunction((m, gp, λ) -> gp.x[1])","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Point functions always receive the metric parameters m, a geodesic point gp, and the final time of the integration λ. To then filter those geodesics which fell into the event horizon, we can use a FilterPointFunction and compose them. Here, we use one of the utility methods FilterStatusCode.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"filter_event_horizon = FilterStatusCode(StatusCodes.WithinInnerBoundary)\n# compose in reverse order\npf = time_coord ∘ filter_event_horizon","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We can then apply our point function on the geodesic points:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"times = pf.(m, points, λ_max)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Point functions can also be used in other contexts. For example, rendergeodesics is a utility method to help render images, and one of the keywords we can pass is pf, so that each pixel value is coloured by the point function we gave. We can create a higher resolution render of the above easily using rendergeodesics:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"# this function returns the impact parameter axes\nα, β, image = rendergeodesics(\n    m, \n    x,\n    # no longer need to specify the velocities\n    # these are automatically calculated\n    λ_max, \n    pf = pf, \n    # image parameters\n    image_width = 800, \n    image_height = 800,\n    # the \"zoom\" -- field of view scale\n    fov = 52,\n    verbose = true\n)\n\nheatmap(α, β, image, aspect_ratio = 1)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"This is good, but let's make our render a bit more interesting.","category":"page"},{"location":"getting-started/#Short-aside:-rendergeodesics-and-tracegeodesics","page":"Getting started","title":"Short aside: rendergeodesics and tracegeodesics","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The two functions rendergeodesics and tracegeodesics should be regarded as the fundamental tools that Gradus.jl provides. The former is used to create visualisations, used to see what is going on with your system in images. The latter is the entry point for modelling physical processes, being much more versatile than rendergeodesics, but also requiring preparatory work.","category":"page"},{"location":"getting-started/#Adding-geometry","page":"Getting started","title":"5 Adding geometry","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The simplest thing we can do is put a disc around our black hole and visualize that system. Gradus.jl implements many different accretion disc types, but some kind of torus would be good to start with.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nThere are many different disc types already implemented, see Available accretion geometry. For adding your own geometry, see Adding new accretion geometry.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We may be imaginative and specify our own cross-section for the disc. We need to specify the function in the positive z axis, and this will be mirrored in the x-y plane and rotated around the black hole.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The cross section need not be physical. Choosing some arbitrary shape, we can preview what our cross section will look like over a sample range:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"function cross_section(x)\n    # centered circle on 8 rg\n    center = 8\n    radius = 3\n\n    if (x < center - radius) || (radius + center < x)\n        zero(x)\n    else\n        r = x - center\n        sqrt(radius^2 - r^2) + (0.5sin(3x))\n    end\nend\n\n# preview the cross section over a sample range\nsample = collect(range(0.0, 20.0, 300))\ny = cross_section.(sample)\n\nplot(sample, y, xlabel = \"r\", ylabel = \"height\", aspect_ratio = 1)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We then wrap our cross section function as a ThickDisc type:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"d = ThickDisc(x -> cross_section(x[2]))","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The thick disc callback receives the full four-position, so we forward only the radial component. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We now need to update our point function so that it filters those geodesics which intersected with the geometry instead of those that fell into the black hole. This is a standard function already implemented in ConstPointFunctions; only a composition is needed:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"pf_geometry = time_coord ∘ ConstPointFunctions.filter_intersected","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We then make a handful of small changes to make our image more interesting, and render just as before, passing the disc in to the rendergeodesics function:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"# change inclination\nx = SVector(0.0, 1000.0, deg2rad(70), 0.0)\n\nα, β, image = rendergeodesics(\n    m, \n    x,\n    # add the disc argument\n    d,\n    λ_max, \n    # new point function\n    pf = pf_geometry, \n    # slightly wider image\n    image_width = 1200, \n    image_height = 800,\n    # zoom out a little\n    fov = 22,\n    verbose = true\n)\n\nheatmap(α, β, image, aspect_ratio = 1)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/#Calculating-physical-quantities","page":"Getting started","title":"6 Calculating physical quantities","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"A common quantity to look at when ray tracing is the redshift of a photon; that is, the ratio of the energy where the photon was emitted to where it was observed. Mathematically, this is the quantity","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"g = fracleft k_mu u^mu rightrvert_textobsleft k_nu u^nu rightrvert_textem","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"where the subscript denote the observer and emitters position respectively. Here, k_mu is the covariant momentum of the photon, and u^mu is the velocity of the disc patch, or of the observer respectively. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We can choose any velocity profile we like, but for simplicity we use the velocity of the stable circular orbit at the corresponding radius where the photon hit the disc. The above formula for the redshift g is already implemented with this velocity profile for us – we need only specify which spacetime we are in and where our observer is positioned:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"redshift = ConstPointFunctions.redshift(m, x)\n# compose to filter those that intersected with the geometry\nredshift_geometry = redshift ∘ ConstPointFunctions.filter_intersected","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"This is another PointFunction, and is used in the same way. Rendering as before:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"α, β, image = rendergeodesics(\n    m, \n    x,\n    d,\n    λ_max, \n    # new point function\n    pf = redshift_geometry,\n    image_width = 1200, \n    image_height = 800,\n    fov = 22,\n    verbose = true\n)\n\nheatmap(α, β, image, aspect_ratio = 1)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/#Changing-metric","page":"Getting started","title":"7 Changing metric","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To change the metric, we need only pass a new metric to ConstPointFunctions.redshift to update how the redshift is calculated, and to rendergeodesics to update how the geodesic equation is integrated. To switch to e.g. the Johannsen (2013)[1] metric, the following modifications are needed:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"j_m = JohannsenMetric(M=1.0, a = 0.7, α13 = 2.0, ϵ3 = 1.0)\n\n# pass the new metric\nj_redshift = ConstPointFunctions.redshift(j_m, x)\nj_redshift_geometry = j_redshift ∘ ConstPointFunctions.filter_intersected\n\nα, β, image = rendergeodesics(\n    # pass the new metric\n    j_m, \n    x,\n    d,\n    λ_max, \n    # and the new point function\n    pf = j_redshift_geometry,\n    image_width = 1200, \n    image_height = 800,\n    fov = 22,\n    verbose = true\n)\n\nheatmap(α, β, image, aspect_ratio = 1)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/#Calculating-line-profiles","page":"Getting started","title":"8 Calculating line profiles","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"As a final step, we can calculate the line profile of emission from our system with the Johannsen metric. We can compare this to the case where the disc is geometrically thin in the equatorial plane, and furthermore compare this to the Schwarzschild spacetime.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Line profiles are calculated with lineprofile, a function that accepts much the same arguments as the previous tracing and rendering functions. We will also limit the domain of the integration to in the upper hemisphere only – thereby avoiding any false images in our line profile calculations. This choice is physically motiviated, as the gaps in the inner regions of the disc are often assumed to be opaque due to extreme ionization of the matter.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Domain limiting can be done by adding a callback to the integrator.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nFor more on using callbacks and finer control of the integrator, see Using callbacks.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"# define custom bins for g\nbins = collect(range(0.1, 1.4, 200))\n\n# define the plane to perform the binning over\nplane = PolarPlane(GeometricGrid(); Nr = 1000, Nθ = 1000, r_max = 50.0)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In the line above we created an explicit PolarPlane, since we no longer wish to integrate on a rectangular grid. We want to primarily sample the region close to the event horizon where all of the interesting physics is taking place, and as such we scale the radial coordinate geometrically. Adjusting Nr and Nθ lets us control the \"resolution\" of our render, and will smoothen the line profiles. The values chosen here are to balance resolution and computational time (~ 30 seconds on a 2021 M1 Mac laptop).","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We can preview what the grid will look like (though at lower resolution to avoid unnecessary noise):","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"plot(\n    PolarPlane(GeometricGrid(); Nr = 10, Nθ = 20, r_max = 50.0)\n)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Each point on this plane represent a photon which will be traced, and the intensity scaled according to the area the point covers on the image plane.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"With that, we are ready to calculate the line profiles. To avoid having to reuse large parts of our code, we can write a short function that wraps lineprofile:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"function calculate_line_profile(m, x, d, bins, plane)\n    _, f = lineprofile(\n        m, \n        x, \n        d, \n        algorithm = BinnedLineProfile(), \n        # no false images\n        callback = domain_upper_hemisphere(),\n        verbose = true,\n        bins = bins,\n        plane = plane,\n    )\n    return f\nend","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Note that lineprofile returns both the redshift g (bins) and flux at each g. Since we specified the binning, we can ignore the first return value, and keep only the flux.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"d_j_thin = GeometricThinDisc(Gradus.isco(j_m), 200.0, π / 2)\n# and for the schwarzschild metric\nd_s_thin = GeometricThinDisc(Gradus.isco(m), 200.0, π / 2)\n\nf_j_thick_disc = calculate_line_profile(j_m, x, d, bins, plane)\nf_s_thick_disc = calculate_line_profile(m, x, d, bins, plane)\nf_j_thin_disc = calculate_line_profile(j_m, x, d_j_thin, bins, plane)\nf_s_thin_disc = calculate_line_profile(m, x, d_s_thin, bins, plane)\n\nplot(bins, f_j_thick_disc, label = \"Johannsen[thick]\")\nplot!(bins, f_s_thick_disc, label = \"Schwarzschild[thick]\")\nplot!(bins, f_j_thin_disc, label = \"Johannsen[thin]\")\nplot!(bins, f_s_thin_disc, label = \"Schwarzschild[thin]\")","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nFor how to use these line profiles and other observables in fitting programs, see Exporting data products.","category":"page"},{"location":"getting-started/#Where-to-go-from-here?","page":"Getting started","title":"Where to go from here?","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The documentation is a rich resource for information related to using Gradus, and tailoring the toolkit for your needs. Take a look at Examples for a number of quick recipes, or try Implementing a new metric and study a different spacetime.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"[1]: Johannsen, Tim. ‘Regular Black Hole Metric with Three Constants of Motion’. Physical Review D 88, no. 4 (1 August 2013): 044002. https://doi.org/10.1103/PhysRevD.88.044002.","category":"page"},{"location":"overview/point-functions/#Point-functions","page":"Point functions","title":"Point functions","text":"","category":"section"},{"location":"overview/point-functions/","page":"Point functions","title":"Point functions","text":"CurrentModule = Gradus","category":"page"},{"location":"overview/point-functions/","page":"Point functions","title":"Point functions","text":"AbstractPointFunction\nPointFunction\nFilterPointFunction","category":"page"},{"location":"overview/point-functions/#Gradus.AbstractPointFunction","page":"Point functions","title":"Gradus.AbstractPointFunction","text":"abstract type AbstractPointFunction\n\nAbstract super type for point functions. Must have f::Function field.\n\n\n\n\n\n","category":"type"},{"location":"overview/point-functions/#Gradus.PointFunction","page":"Point functions","title":"Gradus.PointFunction","text":"struct PointFunction <: AbstractPointFunction\nPointFunction(func)\n\nf: Wrapped function.\n\nPoint functions are functions that are used to calculate physical parameters from geodesic integrations, and to compose more complex models. A number of default and utility PointFunction are defined in Gradus.ConstPointFunctions.\n\nPrincipally, point functions return a single value per geodesic, and are used to fill rendered images with values, e.g. colouring redshift.\n\nPoint functions may be instantiated by wrapping a function with the following signature\n\nfunction func(m::AbstractMetric{T}, gp::AbstractGeodesicPoint, max_time::T; kwargs...)::T where {T}\n    # ...\nend\n\npf = PointFunction(func)\n\nThe AbstractMetric argument may be used to dispatch for different metrics.\ngp is an GradusBase.AbstractGeodesicPoint corresponding to a given geodesic.\nThe max_time parameter is the maximum integration time used to integrate the geodesics. This may be useful when trying to determine whether a geodesic terminated early or not.\n\nThey may be invoked by invoking the instance\n\nresult = pf(m, gp, max_time)\n\nnote: Note\nAs of version 0.1.0, the kwargs parameter is reserved only for passing optional results when chaining multiple point functions (see below). This is subject to revision and breaking changes in future versions.\n\nMultiple AbstractPointFunction may be chained together using the ∘ operator, and are evaluated from right to left\n\npf3 = pf2 ∘ pf1\n\nThis may be useful for constructing filters using FilterPointFunction. When used with two PointFunction objects, the output of the previous PointFunction is passed to the next via the value keyword argument.\n\n\n\n\n\n","category":"type"},{"location":"overview/point-functions/#Gradus.FilterPointFunction","page":"Point functions","title":"Gradus.FilterPointFunction","text":"struct FilterPointFunction <: AbstractPointFunction\nFilterPointFunction(func, default_value)\n\nf: Wrapped function.\ndefault: Default return value if condition is false.\n\nPoint functions used to filter geodesics. They may be constructed with\n\nfunction func(m::AbstractMetric{T}, gp::AbstractGeodesicPoint, max_time::T; kwargs...)::Bool where {T}\n    # ... return Bool\nend\n\nfpf = FilterPointFunction(func, NaN64)\n\nThe second argument to the constructor is the default value, given to the pixel if the boolean condition of func is false.\n\nExample\n\nA filter for geodesics within a certain radius, used to only calculate redshift within 10 r_textg\n\nfunc(m, gp, max_time) = gp.u[2] < 10.0\npf = ConstPointFunctions.redshift(m, u) ∘ FilterPointFunction(func, NaN64)\n\n\n\n\n\n","category":"type"},{"location":"overview/point-functions/#Pre-defined-point-functions","page":"Point functions","title":"Pre-defined point functions","text":"","category":"section"},{"location":"overview/point-functions/","page":"Point functions","title":"Point functions","text":"ConstPointFunctions\nConstPointFunctions.filter_early_term\nConstPointFunctions.filter_intersected\nConstPointFunctions.affine_time\nConstPointFunctions.shadow\nConstPointFunctions.redshift","category":"page"},{"location":"overview/point-functions/#Gradus.ConstPointFunctions","page":"Point functions","title":"Gradus.ConstPointFunctions","text":"module ConstPointFunctions\n\nModule defining a number of const Gradus.AbstractPointFunction, serving different utility or common purposes for analysis.\n\n\n\n\n\n","category":"module"},{"location":"overview/point-functions/#Gradus.ConstPointFunctions.filter_early_term","page":"Point functions","title":"Gradus.ConstPointFunctions.filter_early_term","text":"filter_early_term(m::AbstractMetric, gp::AbstractGeodesicPoint, max_time)\n\nA FilterPointFunction that filters geodesics that termined early (i.e., did not reach maximum integration time or effective infinity). Default: NaN.\n\n\n\n\n\n","category":"constant"},{"location":"overview/point-functions/#Gradus.ConstPointFunctions.filter_intersected","page":"Point functions","title":"Gradus.ConstPointFunctions.filter_intersected","text":"filter_intersected(m::AbstractMetric, gp::AbstractGeodesicPoint, max_time)\n\nA FilterPointFunction that filters geodesics which intersected with the accretion disc. Default: NaN.\n\n\n\n\n\n","category":"constant"},{"location":"overview/point-functions/#Gradus.ConstPointFunctions.affine_time","page":"Point functions","title":"Gradus.ConstPointFunctions.affine_time","text":"affine_time(m::AbstractMetric, gp::AbstractGeodesicPoint, max_time)\n\nA PointFunction returning the affine integration time at the endpoint of the geodesic.\n\n\n\n\n\n","category":"constant"},{"location":"overview/point-functions/#Gradus.ConstPointFunctions.shadow","page":"Point functions","title":"Gradus.ConstPointFunctions.shadow","text":"shadow(m::AbstractMetric, gp::AbstractGeodesicPoint, max_time)\n\nA PointFunction which colours the shadow of the black hole for any disc-less render. Equivalent to ConstPointFunctions.affine_time ∘ ConstPointFunctions.filter_early_term.\n\n\n\n\n\n","category":"constant"},{"location":"overview/point-functions/#Gradus.ConstPointFunctions.redshift","page":"Point functions","title":"Gradus.ConstPointFunctions.redshift","text":"redshift(m::AbstractMetric)\n\nReturns a PointFunction.\n\nCalculate the analytic redshift at a given geodesic point, assuming equitorial, geometrically thin accretion disc. Implementation depends on the metric type. Currently implemented for\n\nGradus.KerrMetric\nGradus.KerrSpacetimeFirstOrder\n\nNotes\n\nWraps calls to Gradus._redshift_guard to dispatch different implementations.\n\n\n\n\n\n","category":"function"},{"location":"overview/exports/#Exporting-data-products","page":"Exporting data products","title":"Exporting data products","text":"","category":"section"},{"location":"internals/custom-traces/#Tracing-auxiliary-quantities","page":"Custom tracing","title":"Tracing auxiliary quantities","text":"","category":"section"},{"location":"internals/custom-traces/","page":"Custom tracing","title":"Custom tracing","text":"CurrentModule = Gradus","category":"page"},{"location":"internals/custom-traces/","page":"Custom tracing","title":"Custom tracing","text":"There are many scenarios where it may be useful to trace additional quantities along a geodesic, such as with radiative transfer or polarization. Gradus.jl provides some methods in an attempt to streamline how new quantities and physics may be added.","category":"page"},{"location":"internals/custom-traces/","page":"Custom tracing","title":"Custom tracing","text":"As an example, let us consider tracing the path-length (a scalar) along the trajectory as we are integrating. Principally, we need only provide a new AbstractTrace, which is used to dispatch our method, and implement either geodesic_ode_problem or assemble_tracing_problem function.","category":"page"},{"location":"internals/custom-traces/","page":"Custom tracing","title":"Custom tracing","text":"geodesic_ode_problem\nassemble_tracing_problem","category":"page"},{"location":"internals/custom-traces/#Gradus.geodesic_ode_problem","page":"Custom tracing","title":"Gradus.geodesic_ode_problem","text":"geodesic_ode_problem(\n    trace::AbstractTrace,\n    m::AbstractMetric,\n    pos, \n    vel,\n    time_domain::Tuple,\n    callback\n)\n\nReturns an OrdinaryDiffEq.ODEProblem{false}, specifying the ODE problem to be solved.  The precise problem depends on the AbstractTrace and AbstractMetric defined.\n\nMay be overwritten to more easily define a new tracing problem. The standard geodesic equation implemention looks like:\n\nfunction geodesic_ode_problem(\n    ::TraceGeodesic,\n    m::AbstractMetric,\n    pos,\n    vel,\n    time_domain,\n    callback,\n)\n    function f(u::SVector{8,T}, p, λ) where {T}\n        @inbounds let x = SVector{4,T}(@view(u[1:4])), \n            v = SVector{4,T}(@view(u[5:8]))\n            dv = SVector{4,T}(geodesic_equation(m, x, v))\n            # modify the differential equation here\n            vcat(v, dv)\n        end\n    end\n    \n    # add additional parameters here\n    u_init = vcat(pos, vel)\n    ODEProblem{false}(\n        f,\n        u_init,\n        time_domain,\n        # specify parameters needed by `f` here\n        IntegrationParameters(StatusCodes.NoStatus);\n        callback = callback,\n    )\nend\n\nSee also TraceGeodesic and TraceRadiativeTransfer.\n\n\n\n\n\n","category":"function"},{"location":"internals/custom-traces/#Gradus.assemble_tracing_problem","page":"Custom tracing","title":"Gradus.assemble_tracing_problem","text":"assemble_tracing_problem(trace::AbstractTrace, config::TracingConfiguration)\n\nMerges callbacks, defines an ODE builder through (a variation of) geodesic_ode_problem, and wraps the ODE problem depending on the input argument types. \n\nThis function need only be overwritten if the AbstractTrace requires fine control or non-standard arguments when building the ODE. See, e.g., the TraceRadiativeTransfer implementation.\n\nFor merging the callbacks, use create_callback_set.\n\nFor wrapping arguments, use the utility function wrap_arguments.\n\n\n\n\n\n","category":"function"},{"location":"internals/custom-traces/#Path-length-example","page":"Custom tracing","title":"Path-length example","text":"","category":"section"},{"location":"internals/custom-traces/","page":"Custom tracing","title":"Custom tracing","text":"The AbstractTrace type we define is used to hold on to any quantities we want to be able to set for a given tracing problem. This commonly includes the mass and/or charge of the geodesic, or some initial vector in the case of parallel transport. In our case, we will mandate that all path-lengths start at 0, and therefore only provide the mass μ as a field.","category":"page"},{"location":"internals/custom-traces/","page":"Custom tracing","title":"Custom tracing","text":"struct TracePathLength{T} <: Gradus.AbstractTrace\n    \"Geodesic mass\"\n    μ::T\nend","category":"page"},{"location":"internals/custom-traces/","page":"Custom tracing","title":"Custom tracing","text":"The path-length will be calculated as a local toy path-length for simplicity:","category":"page"},{"location":"internals/custom-traces/","page":"Custom tracing","title":"Custom tracing","text":"textds^2 = textdr^2 + textdtheta^2 + textdphi^2","category":"page"},{"location":"internals/custom-traces/","page":"Custom tracing","title":"Custom tracing","text":"which we can express as a differential equation","category":"page"},{"location":"internals/custom-traces/","page":"Custom tracing","title":"Custom tracing","text":"fractextdstextdlambda = sqrtleft(fractextdrtextdlambdaright)^2 + left(fractextdthetatextdlambdaright)^2 + left(fractextdphitextdlambdaright)^2","category":"page"},{"location":"internals/custom-traces/","page":"Custom tracing","title":"Custom tracing","text":"Writing this as a Julia function","category":"page"},{"location":"internals/custom-traces/","page":"Custom tracing","title":"Custom tracing","text":"function dsdλ(v)\n    l2 = (v[2])^2 + (v[3])^2 + (v[4])^2\n    sqrt(l2)\nend","category":"page"},{"location":"internals/custom-traces/","page":"Custom tracing","title":"Custom tracing","text":"Then we specify how the tracing problem should be put together. This is currently quite a lot of boilerplate code, but gives us plenty of control over how the tracing problems are built should we need it. We first write the function that generates our ODEProblem:","category":"page"},{"location":"internals/custom-traces/","page":"Custom tracing","title":"Custom tracing","text":"function Gradus.geodesic_ode_problem(\n    ::TracePathLength,\n    m::AbstractMetric,\n    pos,\n    vel,\n    time_domain,\n    callback,\n)\n    # note this function takes SVector{9} instead of SVector{8}\n    function f(u::SVector{9,T}, p, λ) where {T}\n        @inbounds let x = SVector{4,T}(u[1:4]), v = SVector{4,T}(u[5:8])\n            # geodesic equation as usual\n            dv = SVector{4,T}(Gradus.geodesic_equation(m, x, v))\n\n            # calculate our path length difference\n            ds = dsdλ(v)\n\n            # concatanate the quantities\n            vcat(v, dv, SVector(ds))\n        end\n    end\n    \n    # append the initial pathlength\n    u_init = vcat(pos, vel, SVector(zero(eltype(pos))))\n    \n    # this function returns a `OrdinaryDiffEq.ODEProblem` type\n    Gradus.ODEProblem{false}(\n        f,\n        u_init,\n        time_domain,\n        Gradus.IntegrationParameters(StatusCodes.NoStatus);\n        callback = callback,\n    )\nend","category":"page"},{"location":"internals/custom-traces/","page":"Custom tracing","title":"Custom tracing","text":"We are then ready to trace! For example, using some code from Getting started:","category":"page"},{"location":"internals/custom-traces/","page":"Custom tracing","title":"Custom tracing","text":"m = KerrMetric(1.0, 0.8)\nx = SVector(0.0, 1000.0, deg2rad(90), 0.0)\n\nα = range(-10.0, 10.0, 300)\nvs = map_impact_parameters(m, x, α, 0.0)\nxs = fill(x, size(vs))\nλ_max = 2000.0\n\nsols = tracegeodesics(m, xs, vs, λ_max, trace = TracePathLength(0.0))\n\n# get the path lenght for each geodesic\npoints = unpack_solution(sols)\nlengths = map(p -> p.aux[1], points)\n\n# filter only those that fell into the black hole\nI = map(i -> i.status == StatusCodes.WithinInnerBoundary, points)\n\nplot(α[I], lengths[I], xlabel = \"α\", ylabel = \"path-length\")","category":"page"},{"location":"internals/custom-traces/","page":"Custom tracing","title":"Custom tracing","text":"(Image: )","category":"page"},{"location":"problems-and-solvers/#Defining-and-using-geodesic-problems-and-their-solvers","page":"Problems and solvers","title":"Defining and using geodesic problems and their solvers","text":"","category":"section"},{"location":"internals/parallelism/#Parallelism-and-ensembles","page":"Parallelism and ensembles","title":"Parallelism and ensembles","text":"","category":"section"},{"location":"overview/accretion-geometry/#Accretion-geometry","page":"Accretion geometry","title":"Accretion geometry","text":"","category":"section"},{"location":"overview/accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"CurrentModule = Gradus","category":"page"},{"location":"overview/accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"Gradus.jl supports the ability to implement custom accretion geometry, or even load in mesh files in any standard format using MeshIO.jl. Geometry may be standard spherically symmetric accretion discs, or any other custom type.","category":"page"},{"location":"overview/accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"note: Note\nCurrently geometry is optically thick always. Radiative transfer will be added soon.","category":"page"},{"location":"overview/accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"AbstractAccretionGeometry\nGradus.in_nearby_region\nGradus.has_intersect","category":"page"},{"location":"overview/accretion-geometry/#Gradus.AbstractAccretionGeometry","page":"Accretion geometry","title":"Gradus.AbstractAccretionGeometry","text":"abstract type AbstractAccretionGeometry{T}\n\nSupertype of all accretion geometry. Concrete sub-types must minimally implement\n\nin_nearby_region\nhas_intersect\n\nAlternativey, for more control, either intersects_geometry or geometry_collision_callback may be implemented for a given geometry type.\n\nGeometry intersection calculations are performed by strapping discrete callbacks to the integration procedure.\n\n\n\n\n\n","category":"type"},{"location":"overview/accretion-geometry/#Gradus.in_nearby_region","page":"Accretion geometry","title":"Gradus.in_nearby_region","text":"in_nearby_region(g::AbstractAccretionGeometry{T}, line_element)::Bool\n\nReturns a boolean indicating whether the line_element is \"close\" to the geometry in question. Used to optimize when to call the intersection algorithm.\n\nContextually, \"close\" is a little arbitrary, and this function may always return True, however will suffer in performance if this is the case.\n\nline_element is a tuple of two four-position vectors, indicating the last integration position, and current integration position, i.e. (u_prev, u_curr), in integrator coordinates.\n\nNotes\n\nThis function actually depends on the step size of the integrator, but this is currently not considered in the implementation.\n\n\n\n\n\n","category":"function"},{"location":"overview/accretion-geometry/#Gradus.has_intersect","page":"Accretion geometry","title":"Gradus.has_intersect","text":"has_intersect(g::AbstractAccretionGeometry{T}, line_element)\n\nReturns a boolean indicating whether line_element intersects the geometry g. The intersection algorithm used depends on the geometry considered. For meshes, this uses the jsf_algorithm.\n\nline_element is a tuple of two four-position vectors, indicating the last integration position, and current integration position, i.e. (u_prev, u_curr), in integrator coordinates.\n\n\n\n\n\n","category":"function"},{"location":"overview/accretion-geometry/#Adding-new-accretion-geometry","page":"Accretion geometry","title":"Adding new accretion geometry","text":"","category":"section"},{"location":"overview/accretion-geometry/#Accretion-discs","page":"Accretion geometry","title":"Accretion discs","text":"","category":"section"},{"location":"overview/accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"AbstractAccretionDisc\ndistance_to_disc\nAbstractThickAccretionDisc\ncross_section","category":"page"},{"location":"overview/accretion-geometry/#Gradus.AbstractAccretionDisc","page":"Accretion geometry","title":"Gradus.AbstractAccretionDisc","text":"abstract type AbstractAccretionDisc{T} <: AbstractAccretionGeometry{T}\n\nSupertype for axis-symmetric geometry, where certain optimizing assumptions may be made. Concrete subtypes must implement distance_to_disc.\n\n\n\n\n\n","category":"type"},{"location":"overview/accretion-geometry/#Gradus.distance_to_disc","page":"Accretion geometry","title":"Gradus.distance_to_disc","text":"distance_to_disc(d::AbstractAccretionGeometry, u; kwargs...)\n\nCalculate distance to the closest element of the disc. The distance need not be metric or Pythagorean, but rather should be positive when the four vector u is distant, zero when u is on the surface, and negative when u is within the disc geometry.\n\nMust return a floating point number.\n\n\n\n\n\n","category":"function"},{"location":"overview/accretion-geometry/#Gradus.AbstractThickAccretionDisc","page":"Accretion geometry","title":"Gradus.AbstractThickAccretionDisc","text":"abstract type AbstractThickAccretionDisc{T} <: AbstractAccretionDisc{T}\n\nSupertype for axis-symmetric geometry that are specified by a height cross-section function. Subtypes are required to implement cross_section.\n\n\n\n\n\n","category":"type"},{"location":"overview/accretion-geometry/#Gradus.cross_section","page":"Accretion geometry","title":"Gradus.cross_section","text":"cross_section(d::AbstractThickAccretionDisc, u)\n\nReturn the height cross-section of a thick accretion disc at the (projected) coordinates of u. This function also incorporates bounds checking, and should return a negative value if the disc is not defined at u.\n\nExample\n\nFor a top hat disc profile with constant height between two radii\n\nstruct TopHatDisc{T} <: AbstractThickAccretionDisc{T}\n    inner_r::T\n    outer_r::T\nend\n\nfunction Gradus.cross_section(d::TopHatDisc, u)\n    # project u into equitorial plane\n    r = u[2] * sin(u[3])\n    if (r < d.inner_r) || (r > d.outer_r)\n        return -1.0\n    else\n        return 1.0\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"overview/accretion-geometry/#Available-accretion-geometry","page":"Accretion geometry","title":"Available accretion geometry","text":"","category":"section"},{"location":"overview/accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"GeometricThinDisc\nThickDisc\nShakuraSunyaev","category":"page"},{"location":"overview/accretion-geometry/#Gradus.GeometricThinDisc","page":"Accretion geometry","title":"Gradus.GeometricThinDisc","text":"struct GeometricThinDisc{T} <: AbstractAccretionDisc{T}\nGeometricThinDisc(inner_radius::T, outer_radius::T, inclination::T)\n\ninner_radius\nouter_radius\ninclination\n\nSimple geometrically thin accretion disc spanning from inner_radius to outer_radius in gravitational units. Inclination of the disc is relative to spin axis, with 90^circ being perpendicular to the spin axis.\n\n\n\n\n\n","category":"type"},{"location":"overview/accretion-geometry/#Gradus.ThickDisc","page":"Accretion geometry","title":"Gradus.ThickDisc","text":"ThickDisc{T,F,P} <: AbstractThickAccretionDisc{T}\nThickDisc(f, params=nothing; T = Float64)\n\nA standard wrapper for creating custom disc profiles from height cross-section function f. This function is given the disc parameters as unpacked arguments:\n\nd.f(u, d.params...)\n\nIf no parameters are specified, none will be passed to f.\n\nExample\n\nSpecifying a toroidal disc centered on r=10 with radius 1:\n\nd = ThickDisc() do u\n    r = u[2]\n    if r < 9.0 || r > 11.0\n        return -1.0\n    else\n        x = r - 10.0\n        sqrt(1-x^2)\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"overview/accretion-geometry/#Gradus.ShakuraSunyaev","page":"Accretion geometry","title":"Gradus.ShakuraSunyaev","text":"ShakuraSunyaev{T} <: AbstractThickAccretionDisc{T}\nShakuraSunyaev(\n    m::AbstractMetric;\n    eddington_ratio = 0.3,\n    η = nothing,\n    contra_rotating = false,\n)\n\nThe classic Shakura & Sunyaev (1973) accretion disc model, with height given by 2H, where\n\nH = frac32 frac1eta left( fracdotMdotM_textEdd right) left( 1 - sqrtfracr_textiscorho right)\n\nHere eta is the radiative efficiency, which, if unspecified, is determined by the circular orbit energy at the ISCO:\n\neta = 1 - E_textisco\n\n\n\n\n\n","category":"type"},{"location":"overview/accretion-geometry/#Meshes","page":"Accretion geometry","title":"Meshes","text":"","category":"section"},{"location":"overview/accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"MeshAccretionGeometry","category":"page"},{"location":"overview/accretion-geometry/#Gradus.MeshAccretionGeometry","page":"Accretion geometry","title":"Gradus.MeshAccretionGeometry","text":"MeshAccretionGeometry(mesh)\n\nmesh\nx_extent\ny_extent\nz_extent\n\n\n\n\n\n","category":"type"},{"location":"api-documentation/GradusBase/#GradusBase-API-documentation","page":"GradusBase","title":"GradusBase API documentation","text":"","category":"section"},{"location":"api-documentation/GradusBase/","page":"GradusBase","title":"GradusBase","text":"Modules = [Gradus.GradusBase]\nOrder   = [:function, :type]","category":"page"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.E-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T","page":"GradusBase","title":"Gradus.GradusBase.E","text":"E(m::AbstractMatrix{T}, v)\nE(m::AbstractMetric{T}, u, v)\n\nCompute the energy for a numerically evaluated metric, and some velocity four vector v,\n\nE = - p_t = - g_tnu p^nu\n\nFor null geodesics, the velocity is the momentum v^nu = p^nu. For massive geodesics, the mass mu needs to be known to compute mu v^nu = p^nu.\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.Lz-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T","page":"GradusBase","title":"Gradus.GradusBase.Lz","text":"Lz(m::AbstractMatrix{T}, v)\nLz(m::AbstractMetric{T}, u, v)\n\nCompute the angular momentum for a numerically evaluated metric, and some velocity four vector v.\n\nL_z = p_phi = - g_phinu p^nu\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.constrain-Union{Tuple{T}, Tuple{AbstractMetric{T}, Any, Any}} where T","page":"GradusBase","title":"Gradus.GradusBase.constrain","text":"constrain(m::AbstractMetric, x, v; μ=0)\n\nCalculate the time component v^t of a velocity vector v, which would constrain the vector at a position x as a  geodesic with invariant mass μ.\n\nThe velocity vector needs to only specify the v^r, v^theta, and v^phi component, as the v^t is constrained in GR by\n\ng_sigmanu v^sigma v^nu = -mu^2\n\nwhere mu^2 is the invariant mass of the particle. This furthermore permits a choice of geodesic to trace. The choices correspond to\n\nμ = 0.0 (default): null geodesic\nμ > 0.0: time-like geodesic\nμ < 0.0: space-like geodesic\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.geodesic_equation-Tuple{AbstractMetric, Any, Any}","page":"GradusBase","title":"Gradus.GradusBase.geodesic_equation","text":"geodesic_equation(m::AbstractMetric, x, v)\n\nCalculate the four-acceleration of the geodesic equation for a spacetime given by the metric m, four-position x and four-velocity v.\n\nA geodesic is the shortest path connecting two points in space. For flat space, this is just a straight line. In curved space, geodesics are analogous to straight lines between points (e.g. the great circle on a sphere).\n\nThe geodesic equation calculates the acceleration experienced by a particle at position x^mu = (t r theta phi) travelling with tangential velocity v^nu = textd x  textd lambda due to the curvature of spacetime. The curvature is calculated from the metric, encoded in the  Christoffel symbols. The acceleration is then calculated via\n\nfractextd^2 x^mutextd lambda^2\n    = - Gamma^mu_phantommunusigma\n    fractextdx^nutextd lambda\n    fractextdx^sigmatextd lambda\n\nwhere Gamma^mu_phantommunusigma are the Christoffel symbols (of the second kind), and lambda is an affine parameter that parameterizes the solution.\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.inner_radius-Union{Tuple{AbstractMetric{T}}, Tuple{T}} where T","page":"GradusBase","title":"Gradus.GradusBase.inner_radius","text":"inner_radius(m::AbstractMetric{T})\n\nReturn the innermost valid coordinate relative to the origin, for use in geodesic tracing.\n\nThis usually represents some property of the metric, e.g. event horizon radius in Kerr/Schwarzschild metrics, or throat diameter in worm hole metrics.\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.metric-Tuple{AbstractMetric, Any}","page":"GradusBase","title":"Gradus.GradusBase.metric","text":"metric(m::AbstractMetric{T}, u)\n\nNumerically evaluate the corresponding metric for AbstractMetric, given parameter values m and some point u.\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.metric_components-Tuple{AbstractMetric, Any}","page":"GradusBase","title":"Gradus.GradusBase.metric_components","text":"metric_components(m::AbstractMetric{T}, x)\n\nReturn a tuple with each non-zero metric component for the metric described by m at position x. Note that the position need not be a four-vector, and for specific implementations may only be a subset of the total manifold coordinates. See specific implementations for subtypes of AbstractMetric for details.\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.metric_type-Tuple{AbstractMetric}","page":"GradusBase","title":"Gradus.GradusBase.metric_type","text":"metric_type(m::AbstractMetric{T})\n\nReturn the AbstractMetric type associated with the metric parameters m.\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.mproject-Tuple{Any, Any, Any}","page":"GradusBase","title":"Gradus.GradusBase.mproject","text":"mproject(g, v, u)\n\nProject vector v onto u with metric g. Optional first argument may be AbstractMetric for more optimized methods, which fallback to an einsum.\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.unpack_solution-Union{Tuple{T}, Tuple{AbstractMetric, SciMLBase.AbstractODESolution{T}}} where T","page":"GradusBase","title":"Gradus.GradusBase.unpack_solution","text":"unpack_solution([m], sol)\n\nUnpack a solution (SciMLBase.AbstractODESolution) as a GeodesicPoint, optionally specifying the metric under which quantities are transformed. \n\nIf the solution stores any additional parameters (e.g. intensity in radiative transfer), these will be packed  into the aux field of GeodesicPoint.\n\nExample use\n\nsol = tracegeodesics(m, x, v)\npoint = unpack_solution(sol)\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.unpack_solution_full-Union{Tuple{T}, Tuple{AbstractMetric{T}, SciMLBase.AbstractODESolution{T}}} where T","page":"GradusBase","title":"Gradus.GradusBase.unpack_solution_full","text":"unpack_solution_full\n\nUnpacks each point in the solution, similar to unpack_solution but returns an array of GeodesicPoint.\n\n\n\n\n\n","category":"method"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.AbstractGeodesicPoint","page":"GradusBase","title":"Gradus.GradusBase.AbstractGeodesicPoint","text":"abstract type AbstractGeodesicPoint\n\nSupertype for geodesic points, used to store information about specific points along geodesic trajectories.\n\nnote: Note\nCurrently limited to storing the start and endpoint of any given trajectory. To keep the full geodesic path, it is encouraged to use the SciMLBase.AbstractODESolution directly.\n\nMust minimally have the same fields as GeodesicPoint. Examples include Gradus.FirstOrderGeodesicPoint.\n\n\n\n\n\n","category":"type"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.AbstractIntegrationParameters","page":"GradusBase","title":"Gradus.GradusBase.AbstractIntegrationParameters","text":"AbstractIntegrationParameters\n\nParameters that are made available at each step of the integration, that need not be constant. For example, the turning points or withing-geometry flags.\n\n\n\n\n\n","category":"type"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.AbstractMetric","page":"GradusBase","title":"Gradus.GradusBase.AbstractMetric","text":"abstract type AbstractMetric{T} end\n\nAbstract type used to dispatch different geodesic problems.\n\n\n\n\n\n","category":"type"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.AbstractTrace","page":"GradusBase","title":"Gradus.GradusBase.AbstractTrace","text":"AbstractTrace\n\nParameters that are constant throughout the integration (e.g. mass or frequency) for any number of geodesics. Also used to dispatch different tracing problems.\n\n\n\n\n\n","category":"type"},{"location":"api-documentation/GradusBase/#Gradus.GradusBase.GeodesicPoint","page":"GradusBase","title":"Gradus.GradusBase.GeodesicPoint","text":"struct GeodesicPoint <: AbstractGeodesicPoint\n\nstatus: Return code of the integrator for this geodesic.\nλ_min: Start affine time\nλ_max: End affine time\nx_init: Start four position\nx: End four position\nv_init: Start four velocity\nv: End four velocity\naux: Auxillary values (polarisation, intensities, etc.)\n\n\n\n\n\n","category":"type"},{"location":"internals/special-radii/#Special-radii","page":"Special radii","title":"Special radii","text":"","category":"section"},{"location":"internals/special-radii/","page":"Special radii","title":"Special radii","text":"CurrentModule = Gradus","category":"page"},{"location":"internals/special-radii/","page":"Special radii","title":"Special radii","text":"Gradus.isco\nGradus.r_ph\nGradus.r_mb\nGradus.r_s\nGradus.event_horizon","category":"page"},{"location":"internals/special-radii/#Gradus.isco","page":"Special radii","title":"Gradus.isco","text":"isco(m::AbstractMetric) -> Any\n\n\nInnermost stable circular orbit (ISCO), defined by\n\n    fractextdtextdr left( fracEmu right) = 0\n\nUses analytic solutions if known for that metric, else uses a root finder to calculate the radius at which the above condition is met.\n\n\n\n\n\n","category":"function"},{"location":"internals/special-radii/#Gradus.event_horizon","page":"Special radii","title":"Gradus.event_horizon","text":"event_horizon(m::AbstractMetric; select = last, resolution = 100, θε = 1e-7, rmax = 5.0)\n\nEvent horizon radius, often equivalent to GradusBase.inner_radius, however remains distinct, such that the latter may still be an arbitrary chart cutoff.\n\nUtility function for helping plot an event horizon shape. Returns a tuple containing the r and θ vectors that solve\n\n    g_tphi^2 - g_tt g_phi phi = 0\n\nA NaN value in the r vector indicates no solution for that particular theta, i.e. that the metric describes a naked singularity.\n\nOften the equation will have multiple roots, in which case the keyword argument select may be assigned to select the desired root.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\" pa=\"0\" ma=\"0\">\n<img width=\"30%\" src=\"assets/uob-astro-grey.png\">\n</p>","category":"page"},{"location":"#Gradus.jl-Documentation","page":"Home","title":"Gradus.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Spacetime generic, general relativistic ray-tracing (GRRT) in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\"> <i> This package is in development and subject to rapid breaking changes, with documentation updates lagging behind features.</i> </p>","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Gradus.jl is a suite of tools related to tracing geodesics and calculating observational signatures. Gradus.jl requires only a specification of the non-zero metric components of a chosen spacetime in order to solve the geodesic equation and compute a wide variety of trajectories and orbits. Various algorithms for calculating physical quantities are implemented generically, so they may be used with different classes of spacetime with minimal implementation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, Gradus.jl can be used for any static, axis-symmetric spacetime to calculate:","category":"page"},{"location":"","page":"Home","title":"Home","text":"geodesic orbits and special radii (event horizon shapes, ISCO radii, etc.)\nnull / time / space like trajectories including for charged particles\nblack hole shadows\nredshift images\nCunningham transfer functions\nline profiles and spectra\nreverberation transfer functions\ntime-lags from different coronal models\nemissivity profiles on the accretion disc\ncovariant radiative transfer\nvarious toy accretion models (thin disc, alpha-discs, rotationally-supported polish doughnut, etc)\nnon-symmetric disc geometries\nmesh file geometry","category":"page"},{"location":"","page":"Home","title":"Home","text":"The library is written to make adding new features as effortless as possible. See Examples for more. Many new features are currently being developed as our research advances.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Gradus.jl uses DifferentialEquations.jl and ForwardDiff.jl as the backend for integrating and solving the geodesic equation for arbitrary metrics, and vendors the DifferentialEquations.jl solver and callback system, making Gradus.jl easy to extend for new problems. Gradus.jl currently supports multi-CPU integration and analysis, with GPU support on the horizon.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We assume you already have Julia >1.6.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All non-General dependencies for Gradus.jl are in the AstroRegistry which can be added to Julia with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia>] registry add https://github.com/astro-group-bristol/AstroRegistry","category":"page"},{"location":"","page":"Home","title":"Home","text":"NB: the Julia General Registry is required to install Gradus, however this should be configured by default with any Julia installation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Gradus.jl can then be fetched easily:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia>] add Gradus\njulia> using Gradus","category":"page"},{"location":"","page":"Home","title":"Home","text":"See GettingStarted for setting up your first traces.","category":"page"},{"location":"#See-also","page":"Home","title":"See also","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Julia programming language\nDifferentialEquations.jl\nForwardDiff.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"<hr>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\"> Astrophysics Group Bristol </p>","category":"page"},{"location":"#About-2","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Gradus.jl is a research tool for calculating geodesic paths in arbitrary space-times. It is currently work-in-progress, and breaking changes are frequent, as the interface is redesigned to match changing use-cases.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is part of a larger developing eco-system of codes, created by members of the University of Bristol Astrophysics Group. Gradus.jl is primarily being developed by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fergus Baker (PhD Student)\nDr. Andrew Young (Associate Professor)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more University of Bristol Astrophysics Group codes, see our GitHub organisation.","category":"page"}]
}
