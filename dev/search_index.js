var documenterSearchIndex = {"docs":
[{"location":"parallelism/#Parallelism-and-ensembles","page":"Parallelism and ensembles","title":"Parallelism and ensembles","text":"","category":"section"},{"location":"api-documentation/Gradus/#Full-API-documentation","page":"Gradus","title":"Full API documentation","text":"","category":"section"},{"location":"api-documentation/Gradus/","page":"Gradus","title":"Gradus","text":"CurrentModule = Gradus","category":"page"},{"location":"api-documentation/Gradus/","page":"Gradus","title":"Gradus","text":"StatusCodes\ntracegeodesics\ninverse_metric_components\nGradus.metric_jacobian\nGradus.intersects_geometry\nGradus.build_collision_callback\nGradus.jsf_algorithm","category":"page"},{"location":"api-documentation/Gradus/#Gradus.StatusCodes","page":"Gradus","title":"Gradus.StatusCodes","text":"StatusCodes.T\n\nStatus codes that represent the fate of different geodesics.\n\nOutOfDomain: left the integration chart by travelling to effective infinity (see chart_for_metric).\nWithinInnerBoundary: left the integration chart by falling into the inner horizon inner_radius.\nIntersectedWithGeometry: geodesics intersected with AbstractAccretionGeometry and terminated there. Note\n\nthat this status code only applies to optically thick geometry (see optical_property for more).\n\nNoStatus: the default status code, which is used to imply no calculation has yet been performed.\n\n\n\n\n\n","category":"module"},{"location":"api-documentation/Gradus/#Gradus.tracegeodesics","page":"Gradus","title":"Gradus.tracegeodesics","text":"tracegeodesics(\n    m::AbstractMetric,\n    x, v, [disc], λ_domain;\n    kwargs...\n)\ntracegeodesics(\n    m::AbstractMetric,\n    x, p::AbstractImagePlane, [disc], λ_domain;\n    kwargs...\n)\ntracegeodesics(\n    m::AbstractMetric,\n    model::AbstractCoronaModel, [disc], λ_domain;\n    kwargs...\n)\n\nTrace a geodesic in the spacetime given by m with initial four-position x and four-velocity v.\n\nIf both x and v are arrays of SVector, then many geodesics are traced in parallel.\nIf x is an SVector and the third argument is of type AbstractImagePlane, then every geodesic\n\nof the image plane is traced in parallel.\n\nIf x is an SVector and v is a function, then trajectories must be specified as a kwarg, and tracing is performed\n\nin parallel.\n\nThe functional form for the velocity must map an index to a velocity\n\nfunction velocity_function(i)\n    return SVector(...)\nend\n\nThe possible keyword arguments are\n\n    chart = chart_for_metric(m),\n    callback = nothing,\n    solver = Tsit5(),\n    ensemble = EnsembleThreads(),\n    trajectories = nothing,\n    abstol = 1e-9,\n    reltol = 1e-9,\n    solver_opts...,\n\nwith solver_opts being forwarded to the SciML solve function.\n\n\n\n\n\n","category":"function"},{"location":"api-documentation/Gradus/#Gradus.inverse_metric_components","page":"Gradus","title":"Gradus.inverse_metric_components","text":"inverse_metric_components(g_comp)\n\nCalculates g^tt, g^rr, g^thetatheta, g^phiphi, g^tphi of a static, axis-symmetric metric from g_tt, g_rr, g_thetatheta, g_phiphi, g_tphi using a symbolically computed inverse matrix method.\n\nNotes\n\nTo recreate:\n\nusing Symbolics\n@variables g[1:5] # non zero metric components\nmetric = [\n    g[1] 0 0 g[5]\n    0 g[2] 0 0\n    0 0 g[3] 0\n    g[5] 0 0 g[4]\n]\ninv(metric)\n\n\n\n\n\n","category":"function"},{"location":"api-documentation/Gradus/#Gradus.metric_jacobian","page":"Gradus","title":"Gradus.metric_jacobian","text":"metric_jacobian(m::AbstractStaticAxisSymmetric{T}, rθ)\n\nCalculate the value and Jacobian elements of the metric with respect to r and theta.\n\nLimitations:\n\ncurrenly pre-supposes static, axis-symmetric metric.\n\nNotes\n\nFunction body is equivalent to\n\nf = x -> metric_components(m, x)\nJ = ForwardDiff.vector_mode_jacobian(f, rθ)\nf(rθ), J\n\nbut non-allocating.\n\n\n\n\n\n","category":"function"},{"location":"api-documentation/Gradus/#Gradus.intersects_geometry","page":"Gradus","title":"Gradus.intersects_geometry","text":"intersects_geometry(m::AbstractAccretionGeometry{T}, line_element)\n\nUtility function. Returns a boolean dependent on whether line_element intersects with the geometry (true) or not (false). Uses in_nearby_region to optimze and calls has_intersect to determine intersection.\n\n\n\n\n\n","category":"function"},{"location":"api-documentation/Gradus/#Gradus.jsf_algorithm","page":"Gradus","title":"Gradus.jsf_algorithm","text":"jsf_algorithm(V₁::T, V₂::T, V₃::T, Q₁::V, Q₂::V; ϵ = 1e-8)\n\nImplemented from Jiménez, Segura, Feito. Computation Geometry 43 (2010) 474-492.\n\nSee this blog post for a discussion.\n\n\n\n\n\n","category":"function"},{"location":"lineprofiles/#Line-profiles","page":"Line profiles","title":"Line profiles","text":"","category":"section"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"Line profiles are kernels that represent the blurring of spectral lines from e.g. an accretion disc around a black hole. They show how the flux is smeared over a range of energies relative to the rest energy due to relativistic effects and Doppler shifts.","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"Gradus.jl has various methods for calculating line profiles (see Methods). Here we will explore how to compute line profiles with Gradus using the BinningMethod and the TransferFunctionMethod.","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"As with any Gradus.jl simulation, we start by picking the basic components of our model:","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"using Gradus\n\nm = KerrMetric(M = 1.0, a = 0.998)\n# an infinite thin disc in the equatorial plane\nd = ThinDisc(0.0, Inf)\nx = SVector(0.0, 10_000.0, deg2rad(60), 0.0)","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"We can compute a line profile directly using the lineprofile method:","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"lineprofile","category":"page"},{"location":"lineprofiles/#Gradus.lineprofile","page":"Line profiles","title":"Gradus.lineprofile","text":"lineprofile(m::AbstractMetric, x::SVector, d::AbstractAccretionGeometry; kwargs...)\nlineprofile(\n    m::AbstractMetric, \n    x::SVector, \n    d::AbstractAccretionDisc, \n    profile::AbstractDiscProfile; \n    kwargs...\n)\n\nCompute a line profile for a given set of model components. Returns both the grid and flux.\n\nThe dispatch that includes a profile can be used with an AbstractDiscProfile, conventionally calculated by a coronal model.\n\nIf no profile is specified, the emissivity is assumed to be a power-law varepsilon(r) = r^-3.\n\nThis function accepts a number of keyword arguments depending on method used to compute the line profile. Common arguments with their defaults are:\n\nbins = collect(range(0.1, 1.5, 180)): the (energy) bins used as the domain of the line profile.\nmethod = TransferFunctionMethod(): used to select which method to use when  computing the line profile. Alternatives include BinningMethod.\n\nThe TransferFunctionMethod dispatch additionally accepts the following keyword arguments:\n\nminrₑ = isco(m): the innermost transfer function radius to compute / inner  radius of line profile integration.\nmaxrₑ = 50: the outermost transfer function radius to compute / outer radius  of line profile integration.\nnumrₑ = 100: the number of transfer functions to calculate.\nverbose = false: show a progress bar.\nh = 2e-8: an integration padding value to avoid numerical instabilities. See  Dauser et al., 2010 for details.\nNr = 1000: the number of radial steps used to interpolate between transfer  function branches when integrating.\n\nThe BinningMethod dispatch additionally accepts the following keyword arguments:\n\nλ_max = 2 * x[2]: the maximum integration time (affine parameter).\nredshift_pf = ConstPointFunctions.redshift(m, x): the function used to  compute redshift values.\nverbose = false: show a progress bar.\nminrₑ = isco(m):` the inner radius of the line profile.\nmaxrₑ = T(50):` the outer radius of the line profile.\nplane = PolarPlane(GeometricGrid(); Nr = 450, Nθ = 1300, r_max = 5maxrₑ):  the image plane used in the calculation.\n\nAll other keyword arguments are passed to tracegeodesics.\n\nThere is an additional dispatch that does not accept bins as a keyword argument:\n\nlineprofile(\n    bins,\n    ε::Function,\n    m::AbstractMetric,\n    u,\n    d::AbstractAccretionGeometry;\n    kwargs...\n)\n\nThis dispatch is special as it be used to pass any arbitrary function to act as the emissivity profile of the disc.\n\n\n\n\n\n","category":"function"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"We can invoke this directly ","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"bins, flux = lineprofile(m, x, d)","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"If a custom (enregy) bins is desired, it can be passed using the keyword arguments. We can plot these vectors directly:","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"using Plots\nplot(bins, flux; xlabel = \"g\", ylabel = \"flux\")","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"(Image: )","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"To pass a custom emissivity function, we can use a different dispatch that takes the bins and the emissivity function as the first argument. Here is a shallower power-law, reusing the same bins:","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"emissivity(r) = r^-2\nbins, flux = lineprofile(bins, emissivity, m, x, d)\nplot!(bins, flux)","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"(Image: )","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"To use the emissivity calcualted via an AbstractDiscProfile from a coronal model, we can do something like","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"model = LampPostModel(h = 10.0)\nprofile = emissivity_profile(m, d, model)\nbins, flux = lineprofile(m, x, d, profile; bins = bins)\nplot!(bins, flux)","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"(Image: )","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"We can at any point switch to the BinningMethod dispatches, which have largely the same functions calls. These methods take significantly longer to execute, and often give slightly lower resolution, however are much more flexible in the underlying assumptions of the model:","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"bins, flux = lineprofile(m, x, d, profile; bins = bins, method = BinningMethod())\nplot!(bins, flux)","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"(Image: )","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"The defaults have been chosen to balance accuracy and speed. The above TransferFunctionMethod calculations only take a handful of seconds to compute from scratch. If all we are changing are properties of the disc, we do not necessarily need to recompute the transfer functions, and can make use of caches instead. Here is an example recipe using the transferfunctions utility:","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"tfs = transferfunctions(m, x, d)\n\nf1 = integrate_lineprofile(r -> r^-3, tfs, bins)\nf2 = integrate_lineprofile(profile, tfs, bins)\n\nplot(bins, f1)\nplot!(bins, f2)","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"(Image: )","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"Similar pre-computation can be done with the binning method, however there are currently no utility functions available in the same way as with the transfer functions.","category":"page"},{"location":"lineprofiles/","page":"Line profiles","title":"Line profiles","text":"integrate_lineprofile","category":"page"},{"location":"lineprofiles/#Gradus.integrate_lineprofile","page":"Line profiles","title":"Gradus.integrate_lineprofile","text":"integrate_lineprofile(\n    prof::AbstractDiscProfile, \n    transfer_functions, \n    g_grid;\n    kwargs...\n)\nintegrate_lineprofile(\n    emssivity::Function,\n    transfer_functions, \n    g_grid;\n    kwargs...\n)\n\nIntegrate a set of InterpolatingTransferBranches (calculated using transferfunctions) with either an AbstractDiscProfile or function representing the emissivity profile of the disc.\n\nThe emissivity function must be of the form r -> f(r)::tyepof(r), i.e. represent the emissivty as a function of only radius, returning a single value for each ring.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"CurrentModule = Gradus","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Unlike conventional ray-tracing, ray-tracing in general relativity (GR) has the added complication that the trajectory of light is altered by the curvature of space. In particular, the spacetime around compact singularities, such as black holes, may be significantly curved in weird and wonderful ways, depending on the nature of the object being studied. When attempting to visualise or calculate observational signatures related to these objects, is important to account for so-called GR effects: these effects not only alter how things look, but also the energetics of the system itself.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"This short getting-started guide should hopefully tour you through some of the features of Gradus.jl, and how it can be used to study accretion processes, and different spacetimes.","category":"page"},{"location":"getting-started/#1-Defining-a-spacetime","page":"Getting started","title":"1 Defining a spacetime","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"geodesic_equation","category":"page"},{"location":"getting-started/#Gradus.geodesic_equation","page":"Getting started","title":"Gradus.geodesic_equation","text":"geodesic_equation(m::AbstractMetric, x, v)\n\nCalculate the four-acceleration of the geodesic equation for a spacetime given by the metric m, four-position x and four-velocity v.\n\nA geodesic is the shortest path connecting two points in space. For flat space, this is just a straight line. In curved space, geodesics are analogous to straight lines between points (e.g. the great circle on a sphere).\n\nThe geodesic equation calculates the acceleration experienced by a particle at position x^mu = (t r theta phi) travelling with tangential velocity v^nu = textd x  textd lambda due to the curvature of spacetime. The curvature is calculated from the metric, encoded in the  Christoffel symbols. The acceleration is then calculated via\n\nfractextd^2 x^mutextd lambda^2\n    = - Gamma^mu_phantommunusigma\n    fractextdx^nutextd lambda\n    fractextdx^sigmatextd lambda\n\nwhere Gamma^mu_phantommunusigma are the Christoffel symbols (of the second kind), and lambda is an affine parameter that parameterizes the solution.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The workhorse of Gradus.jl is tracegeodesics. This function is responsible to setting up ordinary differential equation and solving them, either sequentially, in parallel, or on different hardware. To get started, we must minimally choose a spacetime to trace in, an initial position and an initial velocity for our test photon. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To demonstrate of the features in the library, we will choose the simplest Schwarzschild spacetime, which describes a spherically symmetric black hole with mass M. We will implement this metric ourselves.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nMany metrics have already been implemented in Gradus.jl; for a comprehensive list, see Catalogue of metrics.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"using Gradus\n\nstruct Schwarzschild{T} <: AbstractStaticAxisSymmetric{T}\n    M::T\nend\n\nfunction Gradus.metric_components(m::Schwarzschild, x)\n    r, θ = x\n    M = m.M\n\n    dt2 = -(1 - (2M / r))\n    dr2 = -inv(dt2)\n    dθ2 = r^2\n    dϕ2 = r^2 * sin(θ)^2\n    dtdϕ = zero(r)\n\n    SVector(dt2, dr2, dθ2, dϕ2, dtdϕ)\nend\n\nGradus.inner_radius(m::Schwarzschild) = 2 * m.M","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Going through this line by line:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"struct Schwarzschild{T} <: AbstractStaticAxisSymmetric{T}\n    M::T\nend","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"First we define a struct that will parameterise our spacetime. In this case, the mass M. We declare our struct to be a subtype of AbstractStaticAxisSymmetric since we know our metric will be static (no time dependence) and axis-symmetric (no phi dependence). This describes the more general Petrov type D class of spacetimes, and allows Gradus.jl to make a number of simplifying assumptions under the hood about how this spacetime will behave. \nThe T parameter is the number type of this metric, and dictates the precision of all numerics in the trace. Therefore, if M is a Float32, Gradus.jl will raise errors if you attempt 64-bit floating point operations when tracing. This is by design, since many GPU architectures prefer Float32 for speed, especially when precision is less important, and throwing errors is preferable to debugging type coercions. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"function Gradus.metric_components(m::Schwarzschild, x)\n    r, θ = x\n    M = m.M\n\n    dt2 = -(1 - (2M / r))\n    dr2 = -inv(dt2)\n    dθ2 = r^2\n    dϕ2 = r^2 * sin(θ)^2\n    dtdϕ = zero(r)\n\n    SVector(dt2, dr2, dθ2, dϕ2, dtdϕ)\nend","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Here we have given the actual implementation of our metric. Since the metric is static, axis-symmetric, the position vector x only contains the radial and poloidal coordinates, and expects the metric_components function to return the five matrix elements of the metric. For the Schwarzschild metric, the textdt textdphi component is zero everywhere. We set this to zero(r), which is a Julia function that returns 0 but of the same type as r.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nCurrently, Gradus.jl uses exclusively Boyer-Lindquist coordinates for its metrics. However, new coordinates can be implemented, and documentation for this will come soon.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Gradus.inner_radius(m::KerrMetric) = 2 * m.M","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Finally, we specify some inner radius for the integration. This is the cutoff around the origin at which radius the geodesic integration will stop to avoid numerical errors. Here, it is just the Schwarzschild radius, or the outer event horizon. Gradus.jl can calculate different horizons from the metric automatically, which can be useful if you don't know the solution ahead of time, or if the solution is non-symmetric in theta. But if we know it, we can benefit from a small performance boost by implementing it directly.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nFor a full description of implementing a metric, see Implementing a new metric.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"If you're familiar with other GRRT softwares, you might be wondering \"where do we define the Christoffel symbols?\", or \"do I not need a prescription for Carter's constant?\". Thanks to automatic differentiation (AD), we can calculate the Christoffel symbols on the fly! We determine the metric Jacobian with respect to coordinates of interest, and then sparsely compute the Christoffel symbols for the given spacetime class. For full details, see Geodesic integration strategies.","category":"page"},{"location":"getting-started/#2-Photon-trajectories","page":"Getting started","title":"2 Photon trajectories","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The metric parameters and position can be easily and arbitrarily chosen, however the velocity has a precondition which must be satisfied.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"constrain","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The constrain function is automatically invoked by tracegeodesics to normalize velocity vectors appropriately.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We'll position ourselves at a great distance from the singularity at the origin, around 1000  r_textg away. We'll furthermore setup our spacetime with an arbitrary choice of mass M = 1.0, which acts to rescale our system (since all units in Gradus.jl are in standard GR units).","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The initial velocity vector we will somewhat arbitrarily set to be directed towards the black hole (v^r = -1), with a small v^phi component so it grazes past the singularity.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The trajectory is calculated with a call to tracegeodesics:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"m = Schwarzschild(1.0)\nx = SVector(0.0, 1000.0, π/2, 0.0)\nv = SVector(0.0, -1.0, 0.0, -8e-6)\n\n# maximum affine time ~ 2 * x[2]\nλ_max = 2000.0\nsol = tracegeodesics(m, x, v, λ_max)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The trajectory can be visualized with the use of Plots.jl:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"using Plots\n\n# plot solution trajectory\nplot_paths(sol)\n# plot \nplot_horizon!(m)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Choosing the initial velocity in this manner lacks interpretation. We can instead use so-called impact parameters (alpha beta). These may be thought of as follows: ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"impact_parameters_to_three_velocity","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Finally, if you imagine a two dimensional image plane, where x is the horizontal and y the vertical coordinate, the alpha impact parameter corresponds to that closest approach along the x axis, and beta along the y axis.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Hopefully that makes sense. With this, we can more easily setup a handful of geodesics to trace and know that they will roughly travel close to the central singularity.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"# grid of impact parameters in horizontal direction\n# keeping β fixed at 0\nα = range(-10.0, 10.0, 30)\nvs = map_impact_parameters(m, x, α, 0.0)\n\n# need a position for each velocity vector\nxs = fill(x, size(vs))\n\nsols = tracegeodesics(m, xs, vs, λ_max)\n\n# plot\np = plot_paths(sols, legend=false)\nplot_horizon!(m, color = :black)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"When we invoke tracegeodesics in this way, Gradus.jl will automatically distribute the workload onto as many threads as Julia was started with. For example, starting julia with","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"julia -t6","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"will spawn 6 worker threads for Gradus.jl to use. Passing -tauto will allow Julia to use as many threads as your hardware supports.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nFor more about parallelism in Gradus.jl, see Parallelism and ensembles. ","category":"page"},{"location":"getting-started/#3-Rendering-an-image","page":"Getting started","title":"3 Rendering an image","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"A common task we'll want to do is render an image; that is, assign some (alpha beta) to each pixel in a 2-dimensional plane, located at the position x. Each pair of impact parameters is then traced along it, and its corresponding pixel coloured according to some function of the geodesic endpoint.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The simplest non-trivial thing we can do is colour the pixel by the time component of the final position. Since we are not interested in what happens to the geodesic along the path, only the start and end points, we can pass save_on = false to tracegeodesics. This tells the solvers to not save intermediary points along the solution, and thereby avoid the overhead of allocating a memory we have no wish to use.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"# set up our image parameters\nα = range(-10.0, 10.0, 100)\nβ = range(-10.0, 10.0, 100)\n\n# this will set up a 100x100 matrix of velocity vectors\n# so we use `vec` to flatten the structure\nvs = vec([map_impact_parameters(m, x, a, b) for a in α, b in β])\nxs = fill(x, size(vs))\n\n# trace in parallel\nsols = tracegeodesics(m, xs, vs, λ_max, save_on = false)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To help us process the solutions, Gradus.jl exports a number of utility functions. There is one in specific we will want to use:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"unpack_solution","category":"page"},{"location":"getting-started/#Gradus.unpack_solution","page":"Getting started","title":"Gradus.unpack_solution","text":"unpack_solution([m], sol)\n\nUnpack a solution (SciMLBase.AbstractODESolution) as a GeodesicPoint, optionally specifying the metric under which quantities are transformed. \n\nIf the solution stores any additional parameters (e.g. intensity in radiative transfer), these will be packed  into the aux field of GeodesicPoint.\n\nExample use\n\nsol = tracegeodesics(m, x, v)\npoint = unpack_solution(sol)\n\n\n\n\n\n","category":"function"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The GeodesicPoint struct contains everything we might want to know about the start and endpoint of a geodesic solution, including four-velocities and the nature of the termination (fell into the black hole, went to infinity, collided with some geometry, etc.). ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We can easily filter those geodesic that fell into the black hole, and extract their final coordinate times x^t(lambda_textfinal):","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"points = unpack_solution.(sols.u)\n# reshape into the same dimensions as the image\npoints = reshape(points, (100, 100))\n\ntimes = map(points) do gp\n    # check if went off the integration chart on the inner boundary\n    if gp.status == StatusCodes.WithinInnerBoundary\n        # get the time coordinate\n        gp.x[1]\n    else\n        NaN\n    end\nend\n\nheatmap(α, β, times, aspect_ratio = 1)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"This is the so-called shadow of a black hole.","category":"page"},{"location":"getting-started/#4-Defining-and-using-PointFunctions","page":"Getting started","title":"4 Defining and using PointFunctions","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The above is a little verbose, when all we really wanted to do trace a given grid of (alpha beta), and then compute some physical quantity at each pixel. Having to manually write out the for loop and remember to reshape the solutions array is a trifle unnecessary and error-prone. Furthermore, to someone reading our code, it may not always be obvious what physical quantity it is that we are calculating from just the for loop.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Gradus.jl instead uses a callback function, which in its own parlance is dubbed the PointFunction. These functions are isolated small physical quantities, that allow us to compose a more complex observable. Many point functions have already been implemented ready for use.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"As a motivating example, say we wanted to write the above as a PointFunction:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"time_coord = PointFunction((m, gp, λ) -> gp.x[1])","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Point functions always receive the metric parameters m, a geodesic point gp, and the final time of the integration λ. To then filter those geodesics which fell into the event horizon, we can use a FilterPointFunction and compose them. Here, we use one of the utility methods FilterStatusCode.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"filter_event_horizon = FilterStatusCode(StatusCodes.WithinInnerBoundary)\n# compose in reverse order\npf = time_coord ∘ filter_event_horizon","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We can then apply our point function on the geodesic points:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"times = pf.(m, points, λ_max)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Point functions can also be used in other contexts. For example, rendergeodesics is a utility method to help render images, and one of the keywords we can pass is pf, so that each pixel value is coloured by the point function we gave. We can create a higher resolution render of the above easily using rendergeodesics:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"# this function returns the impact parameter axes\nα, β, image = rendergeodesics(\n    m, \n    x,\n    # no longer need to specify the velocities\n    # these are automatically calculated\n    λ_max, \n    pf = pf, \n    # image parameters\n    image_width = 800, \n    image_height = 800,\n    # the \"zoom\" -- use the impact parameter axes\n    αlims = (-10, 10),\n    βlims = (-8, 8),\n    verbose = true\n)\n\nheatmap(α, β, image, aspect_ratio = 1)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"This is good, but let's make our render a bit more interesting.","category":"page"},{"location":"getting-started/#Short-aside:-rendergeodesics-and-tracegeodesics","page":"Getting started","title":"Short aside: rendergeodesics and tracegeodesics","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The two functions rendergeodesics and tracegeodesics should be regarded as the fundamental tools that Gradus.jl provides. The former is used to create visualisations, used to see what is going on with your system in images. The latter is the entry point for modelling physical processes, being much more versatile than rendergeodesics, but also requiring preparatory work.","category":"page"},{"location":"getting-started/#5-Adding-geometry","page":"Getting started","title":"5 Adding geometry","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The simplest thing we can do is put a disc around our black hole and visualize that system. Gradus.jl implements many different accretion disc types, but some kind of torus would be good to start with.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nThere are many different disc types already implemented, see Available accretion geometry. For adding your own geometry, see Adding new accretion geometry.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We may be imaginative and specify our own cross-section for the disc. We need to specify the function in the positive z axis, and this will be mirrored in the x-y plane and rotated around the black hole.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The cross section need not be physical. Choosing some arbitrary shape, we can preview what our cross section will look like over a sample range:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"function cross_section(x)\n    # centered circle on 8 rg\n    center = 8\n    radius = 3\n\n    if (x < center - radius) || (radius + center < x)\n        zero(x)\n    else\n        r = x - center\n        sqrt(radius^2 - r^2) + (0.5sin(3x))\n    end\nend\n\n# preview the cross section over a sample range\nsample = collect(range(0.0, 20.0, 300))\ny = cross_section.(sample)\n\nplot(sample, y, xlabel = \"r\", ylabel = \"height\", aspect_ratio = 1)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We then wrap our cross section function as a ThickDisc type:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"d = ThickDisc(r -> cross_section(r))","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The thick disc callback receives the full four-position, so we forward only the radial component. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We now need to update our point function so that it filters those geodesics which intersected with the geometry instead of those that fell into the black hole. This is a standard function already implemented in ConstPointFunctions; only a composition is needed:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"pf_geometry = time_coord ∘ ConstPointFunctions.filter_intersected()","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We then make a handful of small changes to make our image more interesting, and render just as before, passing the disc in to the rendergeodesics function:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"# change inclination\nx = SVector(0.0, 1000.0, deg2rad(70), 0.0)\n\nα, β, image = rendergeodesics(\n    m, \n    x,\n    # add the disc argument\n    d,\n    λ_max, \n    # new point function\n    pf = pf_geometry, \n    # slightly wider image\n    image_width = 1200, \n    image_height = 800,\n    # zoom out a little\n    αlims = (-20, 20),\n    βlims = (-15, 15),\n    verbose = true\n)\n\nheatmap(α, β, image, aspect_ratio = 1)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/#6-Calculating-physical-quantities","page":"Getting started","title":"6 Calculating physical quantities","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"A common quantity to look at when ray tracing is the redshift of a photon; that is, the ratio of the energy where the photon was emitted to where it was observed. Mathematically, this is the quantity","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"g = fracleft k_mu u^mu rightrvert_textobsleft k_nu u^nu rightrvert_textem","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"where the subscript denote the observer and emitters position respectively. Here, k_mu is the covariant momentum of the photon, and u^mu is the velocity of the disc patch, or of the observer respectively. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We can choose any velocity profile we like, but for simplicity we use the velocity of the stable circular orbit at the corresponding radius where the photon hit the disc. The above formula for the redshift g is already implemented with this velocity profile for us – we need only specify which spacetime we are in and where our observer is positioned:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"redshift = ConstPointFunctions.redshift(m, x)\n# compose to filter those that intersected with the geometry\nredshift_geometry = redshift ∘ ConstPointFunctions.filter_intersected()","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"This is another PointFunction, and is used in the same way. Rendering as before:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"α, β, image = rendergeodesics(\n    m, \n    x,\n    d,\n    λ_max, \n    # new point function\n    pf = redshift_geometry,\n    image_width = 1200, \n    image_height = 800,\n    αlims = (-20, 20),\n    βlims = (-15, 15),\n    verbose = true\n)\n\nheatmap(α, β, image, aspect_ratio = 1)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/#7-Changing-metric","page":"Getting started","title":"7 Changing metric","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To change the metric, we need only pass a new metric to ConstPointFunctions.redshift to update how the redshift is calculated, and to rendergeodesics to update how the geodesic equation is integrated. To switch to e.g. the Johannsen (2013)[1] metric, the following modifications are needed:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"j_m = JohannsenMetric(M=1.0, a = 0.7, α13 = 2.0, ϵ3 = 1.0)\n\n# pass the new metric\nj_redshift = ConstPointFunctions.redshift(j_m, x)\nj_redshift_geometry = j_redshift ∘ ConstPointFunctions.filter_intersected()\n\nα, β, image = rendergeodesics(\n    # pass the new metric\n    j_m, \n    x,\n    d,\n    λ_max, \n    # and the new point function\n    pf = j_redshift_geometry,\n    image_width = 1200, \n    image_height = 800,\n    αlims = (-20, 20),\n    βlims = (-15, 15),\n    verbose = true\n)\n\nheatmap(α, β, image, aspect_ratio = 1)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/#8-Calculating-line-profiles","page":"Getting started","title":"8 Calculating line profiles","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"As a final step, we can calculate the line profile of emission from our system with the Johannsen metric. We can compare this to the case where the disc is geometrically thin in the equatorial plane, and furthermore compare this to the Schwarzschild spacetime.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Line profiles are calculated with lineprofile, a function that accepts much the same arguments as the previous tracing and rendering functions. We will also limit the domain of the integration to in the upper hemisphere only – thereby avoiding any false images in our line profile calculations. This choice is physically motiviated, as the gaps in the inner regions of the disc are often assumed to be opaque due to extreme ionization of the matter.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Domain limiting can be done by adding a callback to the integrator.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nFor more on using callbacks and finer control of the integrator, see Using callbacks.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"# define custom bins for g\nbins = collect(range(0.1, 1.4, 200))\n\n# define the plane to perform the binning over\nplane = PolarPlane(GeometricGrid(); Nr = 1000, Nθ = 1000, r_max = 50.0)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In the line above we created an explicit PolarPlane, since we no longer wish to integrate on a rectangular grid. We want to primarily sample the region close to the event horizon where all of the interesting physics is taking place, and as such we scale the radial coordinate geometrically. Adjusting Nr and Nθ lets us control the \"resolution\" of our render, and will smoothen the line profiles. The values chosen here are to balance resolution and computational time (~ 30 seconds on a 2021 M1 Mac laptop).","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We can preview what the grid will look like (though at lower resolution to avoid unnecessary noise):","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"plot(\n    PolarPlane(GeometricGrid(); Nr = 10, Nθ = 20, r_max = 50.0)\n)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Each point on this plane represent a photon which will be traced, and the intensity scaled according to the area the point covers on the image plane.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"With that, we are ready to calculate the line profiles. To avoid having to reuse large parts of our code, we can write a short function that wraps lineprofile:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"function calculate_line_profile(m, x, d, bins, plane)\n    _, f = lineprofile(\n        m, \n        x, \n        d, \n        method = BinningMethod(), \n        # no false images\n        callback = domain_upper_hemisphere(),\n        verbose = true,\n        bins = bins,\n        plane = plane,\n    )\n    return f\nend","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Note that lineprofile returns both the redshift g (bins) and flux at each g. Since we specified the binning, we can ignore the first return value, and keep only the flux.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"d_j_thin = ThinDisc(Gradus.isco(j_m), 200.0)\n# and for the schwarzschild metric\nd_s_thin = ThinDisc(Gradus.isco(m), 200.0)\n\nf_j_thick_disc = calculate_line_profile(j_m, x, d, bins, plane)\nf_s_thick_disc = calculate_line_profile(m, x, d, bins, plane)\nf_j_thin_disc = calculate_line_profile(j_m, x, d_j_thin, bins, plane)\nf_s_thin_disc = calculate_line_profile(m, x, d_s_thin, bins, plane)\n\nplot(bins, f_j_thick_disc, label = \"Johannsen[thick]\")\nplot!(bins, f_s_thick_disc, label = \"Schwarzschild[thick]\")\nplot!(bins, f_j_thin_disc, label = \"Johannsen[thin]\")\nplot!(bins, f_s_thin_disc, label = \"Schwarzschild[thin]\")","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nFor how to use these line profiles and other observables in fitting programs, see Exporting data products.","category":"page"},{"location":"getting-started/#Where-to-go-from-here?","page":"Getting started","title":"Where to go from here?","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The documentation is a rich resource for information related to using Gradus, and tailoring the toolkit for your needs. Take a look at Examples for a number of quick recipes, or try Implementing a new metric and study a different spacetime.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"[1]: Johannsen, Tim. ‘Regular Black Hole Metric with Three Constants of Motion’. Physical Review D 88, no. 4 (1 August 2013): 044002. https://doi.org/10.1103/PhysRevD.88.044002.","category":"page"},{"location":"point-functions/#Point-functions","page":"Point functions","title":"Point functions","text":"","category":"section"},{"location":"point-functions/","page":"Point functions","title":"Point functions","text":"CurrentModule = Gradus","category":"page"},{"location":"point-functions/","page":"Point functions","title":"Point functions","text":"AbstractPointFunction\nPointFunction\nFilterPointFunction","category":"page"},{"location":"point-functions/#Gradus.AbstractPointFunction","page":"Point functions","title":"Gradus.AbstractPointFunction","text":"abstract type AbstractPointFunction\n\nAbstract super type for point functions. Must have f::Function field.\n\n\n\n\n\n","category":"type"},{"location":"point-functions/#Gradus.PointFunction","page":"Point functions","title":"Gradus.PointFunction","text":"struct PointFunction <: AbstractPointFunction\nPointFunction(func)\n\nPoint functions are functions that are used to calculate physical parameters from geodesic integrations, and to compose more complex models. A number of default and utility PointFunction are defined in Gradus.ConstPointFunctions.\n\nPrincipally, point functions return a single value per geodesic, and are used to fill rendered images with values, e.g. colouring redshift.\n\nPoint functions may be instantiated by wrapping a function with the following signature\n\nfunction func(m::AbstractMetric{T}, gp::AbstractGeodesicPoint, max_time::T; kwargs...)::T where {T}\n    # ...\nend\n\npf = PointFunction(func)\n\nThe AbstractMetric argument may be used to dispatch for different metrics.\ngp is an AbstractGeodesicPoint corresponding to a given geodesic.\nThe max_time parameter is the maximum integration time used to integrate the geodesics. This may be useful when trying to determine whether a geodesic terminated early or not.\n\nThey may be invoked by invoking the instance\n\nresult = pf(m, gp, max_time)\n\nnote: Note\nAs of version 0.1.0, the kwargs parameter is reserved only for passing optional results when chaining multiple point functions (see below). This is subject to revision and breaking changes in future versions.\n\nMultiple AbstractPointFunction may be chained together using the ∘ operator, and are evaluated from right to left\n\npf3 = pf2 ∘ pf1\n\nThis may be useful for constructing filters using FilterPointFunction. When used with two PointFunction objects, the output of the previous PointFunction is passed to the next via the value keyword argument.\n\n\n\n\n\n","category":"type"},{"location":"point-functions/#Gradus.FilterPointFunction","page":"Point functions","title":"Gradus.FilterPointFunction","text":"struct FilterPointFunction <: AbstractPointFunction\nFilterPointFunction(func, default_value)\n\nPoint functions used to filter geodesics. They may be constructed with\n\nfunction func(m::AbstractMetric{T}, gp::AbstractGeodesicPoint, max_time::T; kwargs...)::Bool where {T}\n    # ... return Bool\nend\n\nfpf = FilterPointFunction(func, NaN64)\n\nThe second argument to the constructor is the default value, given to the pixel if the boolean condition of func is false.\n\nExample\n\nA filter for geodesics within a certain radius, used to only calculate redshift within 10 r_textg\n\nfunc(m, gp, max_time) = gp.u[2] < 10.0\npf = ConstPointFunctions.redshift(m, u) ∘ FilterPointFunction(func, NaN64)\n\n\n\n\n\n","category":"type"},{"location":"point-functions/#Pre-defined-point-functions","page":"Point functions","title":"Pre-defined point functions","text":"","category":"section"},{"location":"point-functions/","page":"Point functions","title":"Point functions","text":"ConstPointFunctions\nConstPointFunctions.filter_early_term\nConstPointFunctions.filter_intersected\nConstPointFunctions.affine_time\nConstPointFunctions.shadow\nConstPointFunctions.redshift","category":"page"},{"location":"point-functions/#Gradus.ConstPointFunctions","page":"Point functions","title":"Gradus.ConstPointFunctions","text":"module ConstPointFunctions\n\nModule defining a number of const Gradus.AbstractPointFunction, serving different utility or common purposes for analysis.\n\n\n\n\n\n","category":"module"},{"location":"point-functions/#Gradus.ConstPointFunctions.filter_early_term","page":"Point functions","title":"Gradus.ConstPointFunctions.filter_early_term","text":"filter_early_term(m::AbstractMetric, gp::AbstractGeodesicPoint, max_time)\n\nA FilterPointFunction that filters geodesics that termined early (i.e., did not reach maximum integration time or effective infinity). Default: NaN.\n\n\n\n\n\n","category":"function"},{"location":"point-functions/#Gradus.ConstPointFunctions.filter_intersected","page":"Point functions","title":"Gradus.ConstPointFunctions.filter_intersected","text":"filter_intersected(m::AbstractMetric, gp::AbstractGeodesicPoint, max_time)\n\nA FilterPointFunction that filters geodesics which intersected with the accretion disc. Default: NaN.\n\n\n\n\n\n","category":"function"},{"location":"point-functions/#Gradus.ConstPointFunctions.affine_time","page":"Point functions","title":"Gradus.ConstPointFunctions.affine_time","text":"affine_time(m::AbstractMetric, gp::AbstractGeodesicPoint, max_time)\n\nA PointFunction returning the affine integration time at the endpoint of the geodesic.\n\n\n\n\n\n","category":"function"},{"location":"point-functions/#Gradus.ConstPointFunctions.shadow","page":"Point functions","title":"Gradus.ConstPointFunctions.shadow","text":"shadow(m::AbstractMetric, gp::AbstractGeodesicPoint, max_time)\n\nA PointFunction which colours the shadow of the black hole for any disc-less render. Equivalent to ConstPointFunctions.affine_time ∘ ConstPointFunctions.filter_early_term.\n\n\n\n\n\n","category":"function"},{"location":"point-functions/#Gradus.ConstPointFunctions.redshift","page":"Point functions","title":"Gradus.ConstPointFunctions.redshift","text":"redshift(m::AbstractMetric)\n\nReturns a PointFunction.\n\nCalculate the analytic redshift at a given geodesic point, assuming equatorial, geometrically thin accretion disc. Implementation depends on the metric type. Currently implemented for\n\nGradus.KerrMetric\nGradus.KerrSpacetimeFirstOrder\n\nNotes\n\nWraps calls to Gradus._redshift_guard to dispatch different implementations.\n\n\n\n\n\n","category":"function"},{"location":"problems-and-solvers/#Defining-and-using-geodesic-problems-and-their-solvers","page":"Problems and solvers","title":"Defining and using geodesic problems and their solvers","text":"","category":"section"},{"location":"problems-and-solvers/","page":"Problems and solvers","title":"Problems and solvers","text":"CurrentModule = Gradus","category":"page"},{"location":"problems-and-solvers/","page":"Problems and solvers","title":"Problems and solvers","text":"Gradus conceptualises geodesic problems as representing different quantities to trace, measures to optimize, or physical values to extract. For example, parallel transport represents a new type of geodesic problem, which traces the transport of an initial vector along a geodesic path. Similarly, optimizing an orbit or determining the Jacobian of some quantity on the image plane are also problems that Gradus.jl provides methods to help solve.","category":"page"},{"location":"problems-and-solvers/#Tracing-custom-quantities","page":"Problems and solvers","title":"Tracing custom quantities","text":"","category":"section"},{"location":"problems-and-solvers/","page":"Problems and solvers","title":"Problems and solvers","text":"There are many scenarios where it may be useful to trace additional quantities along a geodesic, such as with radiative transfer or polarization. Gradus.jl provides some methods in an attempt to streamline how new quantities and physics may be added.","category":"page"},{"location":"problems-and-solvers/","page":"Problems and solvers","title":"Problems and solvers","text":"As an example, let us consider tracing the path-length (a scalar) along the trajectory as we are integrating. Principally, we need only provide a new AbstractTrace, which is used to dispatch our method, and implement either geodesic_ode_problem or assemble_tracing_problem function.","category":"page"},{"location":"problems-and-solvers/","page":"Problems and solvers","title":"Problems and solvers","text":"geodesic_ode_problem\nassemble_tracing_problem","category":"page"},{"location":"problems-and-solvers/#Gradus.geodesic_ode_problem","page":"Problems and solvers","title":"Gradus.geodesic_ode_problem","text":"geodesic_ode_problem(\n    trace::AbstractTrace,\n    m::AbstractMetric,\n    pos, \n    vel,\n    time_domain::Tuple,\n    callback\n\nReturns an OrdinaryDiffEq.ODEProblem{false}, specifying the ODE problem to be solved.  The precise problem depends on the AbstractTrace and AbstractMetric defined.\n\nMay be overwritten to more easily define a new tracing problem. The standard geodesic equation implemention looks like:\n\nfunction geodesic_ode_problem(\n    ::TraceGeodesic,\n    m::AbstractMetric,\n    pos,\n    vel,\n    time_domain,\n    callback,\n)\n    function f(u::SVector{8,T}, p, λ) where {T}\n        @inbounds let x = SVector{4,T}(@view(u[1:4])), \n            v = SVector{4,T}(@view(u[5:8]))\n            dv = SVector{4,T}(geodesic_equation(m, x, v))\n            # modify the differential equation here\n            vcat(v, dv)\n        end\n    end\n    \n    # add additional parameters here\n    u_init = vcat(pos, vel)\n    ODEProblem{false}(\n        f,\n        u_init,\n        time_domain,\n        # specify parameters needed by `f` here\n        IntegrationParameters(StatusCodes.NoStatus);\n        callback = callback,\n    )\nend\n\nSee also TraceGeodesic and TraceRadiativeTransfer.\n\n\n\n\n\n","category":"function"},{"location":"problems-and-solvers/#Gradus.assemble_tracing_problem","page":"Problems and solvers","title":"Gradus.assemble_tracing_problem","text":"assemble_tracing_problem(trace::AbstractTrace, config::TracingConfiguration)\n\nMerges callbacks, defines an ODE builder through (a variation of) geodesic_ode_problem, and wraps the ODE problem depending on the input argument types. \n\nThis function need only be overwritten if the AbstractTrace requires fine control or non-standard arguments when building the ODE. See, e.g., the TraceRadiativeTransfer implementation.\n\nFor merging the callbacks, use create_callback_set.\n\nFor wrapping arguments, use the utility function wrap_arguments.\n\n\n\n\n\n","category":"function"},{"location":"problems-and-solvers/#Path-length-example","page":"Problems and solvers","title":"Path-length example","text":"","category":"section"},{"location":"problems-and-solvers/","page":"Problems and solvers","title":"Problems and solvers","text":"The AbstractTrace type we define is used to hold on to any quantities we want to be able to set for a given tracing problem. This commonly includes the mass and/or charge of the geodesic, or some initial vector in the case of parallel transport. In our case, we will mandate that all path-lengths start at 0, and therefore only provide the mass μ as a field.","category":"page"},{"location":"problems-and-solvers/","page":"Problems and solvers","title":"Problems and solvers","text":"struct TracePathLength{T} <: Gradus.AbstractTrace\n    \"Geodesic mass\"\n    μ::T\nend","category":"page"},{"location":"problems-and-solvers/","page":"Problems and solvers","title":"Problems and solvers","text":"The path-length will be calculated as a local toy path-length for simplicity:","category":"page"},{"location":"problems-and-solvers/","page":"Problems and solvers","title":"Problems and solvers","text":"textds^2 = textdr^2 + textdtheta^2 + textdphi^2","category":"page"},{"location":"problems-and-solvers/","page":"Problems and solvers","title":"Problems and solvers","text":"which we can express as a differential equation","category":"page"},{"location":"problems-and-solvers/","page":"Problems and solvers","title":"Problems and solvers","text":"fractextdstextdlambda = sqrtleft(fractextdrtextdlambdaright)^2 + left(fractextdthetatextdlambdaright)^2 + left(fractextdphitextdlambdaright)^2","category":"page"},{"location":"problems-and-solvers/","page":"Problems and solvers","title":"Problems and solvers","text":"Writing this as a Julia function","category":"page"},{"location":"problems-and-solvers/","page":"Problems and solvers","title":"Problems and solvers","text":"function dsdλ(v)\n    l2 = (v[2])^2 + (v[3])^2 + (v[4])^2\n    sqrt(l2)\nend","category":"page"},{"location":"problems-and-solvers/","page":"Problems and solvers","title":"Problems and solvers","text":"Then we specify how the tracing problem should be put together. This is currently quite a lot of boilerplate code, but gives us plenty of control over how the tracing problems are built should we need it. We first write the function that generates our ODEProblem:","category":"page"},{"location":"problems-and-solvers/","page":"Problems and solvers","title":"Problems and solvers","text":"function Gradus.geodesic_ode_problem(\n    ::TracePathLength,\n    m::AbstractMetric,\n    pos,\n    vel,\n    time_domain,\n    callback,\n)\n    # note this function takes SVector{9} instead of SVector{8}\n    function f(u::SVector{9,T}, p, λ) where {T}\n        @inbounds let x = SVector{4,T}(u[1:4]), v = SVector{4,T}(u[5:8])\n            # geodesic equation as usual\n            dv = SVector{4,T}(Gradus.geodesic_equation(m, x, v))\n\n            # calculate our path length difference\n            ds = dsdλ(v)\n\n            # concatanate the quantities\n            vcat(v, dv, SVector(ds))\n        end\n    end\n    \n    # append the initial pathlength\n    u_init = vcat(pos, vel, SVector(zero(eltype(pos))))\n    \n    # this function returns a `OrdinaryDiffEq.ODEProblem` type\n    Gradus.ODEProblem{false}(\n        f,\n        u_init,\n        time_domain,\n        Gradus.IntegrationParameters(StatusCodes.NoStatus);\n        callback = callback,\n    )\nend","category":"page"},{"location":"problems-and-solvers/","page":"Problems and solvers","title":"Problems and solvers","text":"We are then ready to trace! For example, using some code from Getting started:","category":"page"},{"location":"problems-and-solvers/","page":"Problems and solvers","title":"Problems and solvers","text":"m = KerrMetric(1.0, 0.8)\nx = SVector(0.0, 1000.0, deg2rad(90), 0.0)\n\nα = range(-10.0, 10.0, 300)\nvs = map_impact_parameters(m, x, α, 0.0)\nxs = fill(x, size(vs))\nλ_max = 2000.0\n\nsols = tracegeodesics(m, xs, vs, λ_max, trace = TracePathLength(0.0))\n\n# get the path lenght for each geodesic\npoints = unpack_solution(sols)\nlengths = map(p -> p.aux[1], points)\n\n# filter only those that fell into the black hole\nI = map(i -> i.status == StatusCodes.WithinInnerBoundary, points)\n\nplot(α[I], lengths[I], xlabel = \"α\", ylabel = \"path-length\")","category":"page"},{"location":"problems-and-solvers/","page":"Problems and solvers","title":"Problems and solvers","text":"(Image: )","category":"page"},{"location":"special-radii/#Special-radii","page":"Special radii","title":"Special radii","text":"","category":"section"},{"location":"special-radii/","page":"Special radii","title":"Special radii","text":"CurrentModule = Gradus","category":"page"},{"location":"special-radii/","page":"Special radii","title":"Special radii","text":"Gradus.isco\nGradus.r_ph\nGradus.r_mb\nGradus.r_s\nGradus.event_horizon","category":"page"},{"location":"special-radii/#Gradus.isco","page":"Special radii","title":"Gradus.isco","text":"isco(m::AbstractMetric)\nisco(m::AbstractMetric, lower_bound, upper_bound; kwargs...)\n\nInnermost stable circular orbit (ISCO), defined by\n\n    fractextdtextdr left( fracEmu right) = 0\n\nUses analytic solutions if known for that metric, else uses a root finder to calculate the radius at which the above condition is met.\n\n\n\n\n\n","category":"function"},{"location":"special-radii/#Gradus.event_horizon","page":"Special radii","title":"Gradus.event_horizon","text":"event_horizon(m::AbstractMetric; select = last, resolution = 100, θε = 1e-7, rmax = 5.0)\n\nEvent horizon radius, often equivalent to inner_radius, however remains distinct, such that the latter may still be an arbitrary chart cutoff.\n\nUtility function for helping plot an event horizon shape. Returns a tuple containing the r and θ vectors that solve\n\n    g_tphi^2 - g_tt g_phi phi = 0\n\nA NaN value in the r vector indicates no solution for that particular theta, i.e. that the metric describes a naked singularity.\n\nOften the equation will have multiple roots, in which case the keyword argument select may be assigned to select the desired root.\n\n\n\n\n\n","category":"function"},{"location":"emissivity/#Disc-emissivity","page":"Disc emissivity","title":"Disc emissivity","text":"","category":"section"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"CurrentModule = Gradus","category":"page"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"The emissivity of an accretion disc is the intensity of radiation coming from a given patch of the disc. In addition to the inherent thermal flux in the disc, GRRTs can be used to estimate reflected flux from a coronal source.","category":"page"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"source_to_disc_emissivity","category":"page"},{"location":"emissivity/#Gradus.source_to_disc_emissivity","page":"Disc emissivity","title":"Gradus.source_to_disc_emissivity","text":"source_to_disc_emissivity(\n    m::AbstractStaticAxisSymmetric,\n    spec::AbstractCoronalSpectrum,\n    N,\n    A,\n    x,\n    g,\n    v_disc,\n)\n\nCompute the emissivity of a disc element with (proper) area A at coordinates x with metric m and coronal spectrum spec. Since the emissivity is dependent on the incident flux, the photon (geodesic) count N must be specified, along with the ratio of energies g (computed with energy_ratio) and the spectrum spec.\n\nThe mathematical definition is\n\nvarepsilon = fracNA g^Gamma gamma\n\nwhere gamma is the Lorentz factor due to the velocity of the local disc frame. The velocity is currently always considered to be the Keplerian velocity.\n\nWilkins & Fabian (2012) and Gonzalez et al. (2017).\n\n\n\n\n\n","category":"function"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"These functions are not meant to be directly interacted with. Instead, Gradus abstracts these definitions into profile structs. These structs bin the emissivity in various ways – for example RadialDiscProfile.","category":"page"},{"location":"emissivity/#Calculating-emissivity-profiles","page":"Disc emissivity","title":"Calculating emissivity profiles","text":"","category":"section"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"Depending on the geometry of the corona, the symmetries of the spacetime, and the type of disc being traced, there are sometimes very efficient schemes for calculating the emissivity profiles.","category":"page"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"As a motivating example, consider the lamp post geometry with 64 rays. These may either be traced by sampling directions on the local sky of the emitter:","category":"page"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"(Image: )","category":"page"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"Or, alternatively, we may exploit the radial symmetry of the system, and sample fewer points in the two dimensional x-z plane:","category":"page"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"(Image: )","category":"page"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"note: Note\nFor detailed descriptions of these methods, see Emissivity profile algorithms.","category":"page"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"Both of these methods can be used to estimate the emissivity profiles with trivial changes to switch between them","category":"page"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"emissivity_profile","category":"page"},{"location":"emissivity/#Gradus.emissivity_profile","page":"Disc emissivity","title":"Gradus.emissivity_profile","text":"function emissivity_profile(\n    m::AbstractMetric,\n    d::AbstractAccretionGeometry,\n    model::AbstractCoronaModel;\n    kwargs...,\nend\n\nCalculate the reflection emissivity profile of an accretion disc d around the spacetime m for an illuminating coronal model model.\n\nReturns a RadialDiscProfile via (Monte-Carlo or uniform) sampling of the AbstractCoronaModel position and velocity distribution.\n\nThis function will attempt to automatically switch to use a better scheme to calculate the emissivity profiles if one is available. If not, the default algorithm is to estimate photon count N and calculate the emissivity with source_to_disc_emissivity.\n\nCommon keyword arguments:\n\nn_samples: the maximum number of individual geodesics to sample on the emitter's sky.\n\nPlease consult the documentation of a specific model (e.g. LampPostModel) to see algorithm specific keywords that may be passed.\n\nAll other keyword arguments are forwarded to tracegeodesics.\n\nExample\n\nm = KerrMetric()\nd = ThinDisc(Gradus.isco(m), 1000.0)\nmodel = LampPostModel(h = 10.0)\n\nprofile = emissivity_profile(m, d, model; n_samples = 128)\n\n# visualise as a function of disc radius\nusing Plots\nplot(profile)\n\nNotes\n\nThe sampling is performed using an AbstractDirectionSampler, which samples angles on the emitters sky along which a geodesic is traced.  The effects of the spacetime and the observer's velocity are taken into account by using tetradframe and the corresponding coordinate transformation for local to global coordinates.\n\nThis function assumes axis symmetry, and therefore always interpolates the emissivity as a function of the radial coordinate on the disc. If non-symmetric profiles are desired, consider using tracecorona with a profile constructor, e.g. VoronoiDiscProfile.\n\n\n\n\n\n","category":"function"},{"location":"emissivity/#Using-emissivity-profiles","page":"Disc emissivity","title":"Using emissivity profiles","text":"","category":"section"},{"location":"emissivity/#Adding-coronal-models","page":"Disc emissivity","title":"Adding coronal models","text":"","category":"section"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"A coronal model must minimally specify how pairs of source position and velocity are to be sampled. For example, the lamp post model has only a single position (the point location), and is stationary. A stationary extended corona has different positions, but always the same velocity, and a moving extended source has both a position and velocity distribution which must be sampled to calculate the emissivity profile:","category":"page"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"(Image: )","category":"page"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"Coronal sources must subtype AbstractCoronaModel:","category":"page"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"AbstractCoronaModel\nsample_position_velocity","category":"page"},{"location":"emissivity/#Gradus.AbstractCoronaModel","page":"Disc emissivity","title":"Gradus.AbstractCoronaModel","text":"abstract type AbstractCoronaModel{T}\n\nThe supertype of coronal models, which concrete models must subtype. Struct implementing AbstractCoronaModel must implement minimally sample_position_velocity.\n\nFor example, adding the lamp-post coronal model\n\nstruct LampPostModel{T} <: AbstractCoronaModel{T}\n    height::T\nend\n\nfunction Gradus.sample_position_velocity(m::AbstractMetric, model::LampPostModel)\n    # avoid coordinate singularity with a small θ\n    x = SVector(0, model.height, 1e-3, 0)\n    # ensure velocity is normalized\n    g = metric_components(m, SVector(x[2], x[3]))\n    v = inv(√(-g[1])) * SVector(1, 0, 0, 0)\n    x, v\nend\n\nNote that sample_position_velocity has a number of its own requirements (see that function's documentation). This function must be implemented as a fallback for other methods.\n\nIf special symmetries exist, these may be used in the implementations of higher-order functions, such as emissivity_profile. \n\n\n\n\n\n","category":"type"},{"location":"emissivity/#Gradus.sample_position_velocity","page":"Disc emissivity","title":"Gradus.sample_position_velocity","text":"sample_position_velocity(m::AbstractMetric, model::AbstractCoronaModel) \nsample_position_velocity(\n    m::AbstractMetric,\n    model::AbstractCoronaModel,\n    ::AbstractDirectionSampler,\n    i,\n    N,\n)\n\nSample a source position and velocity pair from the AbstractCoronaModel, optionally specifying the sampler, the sample index i, and total number of samples N. The latter is used when uniform samples are needed, but will invoke the prior if not implemented.\n\nCurrently, these functions should make use of random if they have underlying position and/or velocity distributions, allowing higher order methods, such as tracecorona to approximate a Monte-Carlo sampling technique. The user is required to ensure that the distributions have the desired properties.\n\nThis function must return a pair of SVector{4,T}, where the type must match the parametric type of the coronal model, corresponding to the source position and velocity of that position.\n\nThe velocity vector must be appropriately normalised for the source (see propernorm for help).\n\nExample\n\nHere we implement a new AbstractCoronaModel that is extended over a region at constant height above the black hole. Since we desire the distribution of points to be even over this disc, we must sample as\n\nphi sim 2pi mathcalU\nquad textand quad\nr sim sqrtR^2 mathcalU\n\nwhere mathcalU is a uniform random variable in 0 1, and R is the radial extent of the coronal source. Implemented, this is\n\nstruct ExtendedCorona{T} <: Gradus.AbstractCoronaModel{T}\n    h::T\n    R::T\nend\n\nfunction Gradus.sample_position_velocity(m::AbstractMetric, model::ExtendedCorona{T}) where {T}\n    ϕ = rand(T) * 2π\n    R = √(rand(T) * model.R^2)\n\n    # geometry to translate to global coordinates\n    r = √(model.h^2 + R^2)\n    θ = atan(R, model.h)\n\n    # ensure velocity is normalized\n    g = metric_components(m, SVector(r, θ))\n    v = inv(√(-g[1])) * SVector(1, 0, 0, 0)\n    SVector(0, r, θ, ϕ), v\nend\n\n\n\n\n\n","category":"function"},{"location":"emissivity/#Radial-disc-profile","page":"Disc emissivity","title":"Radial disc profile","text":"","category":"section"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"RadialDiscProfile","category":"page"},{"location":"emissivity/#Voronoi-disc-profile","page":"Disc emissivity","title":"Voronoi disc profile","text":"","category":"section"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"VoronoiDiscProfile","category":"page"},{"location":"emissivity/#Emissivity-profile-algorithms","page":"Disc emissivity","title":"Emissivity profile algorithms","text":"","category":"section"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"In this case, we must be careful to weight the emissivity accordingly:","category":"page"},{"location":"emissivity/","page":"Disc emissivity","title":"Disc emissivity","text":"point_source_equitorial_disc_emissivity","category":"page"},{"location":"custom-metrics/#Implementing-a-new-metric","page":"Implementing new metrics","title":"Implementing a new metric","text":"","category":"section"},{"location":"custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"CurrentModule = Gradus","category":"page"},{"location":"custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"Gradus.jl is able to integrate any 3+1 dimensional metric. A new metric may be defined by implementing one of the abstract types with a concrete type, and defining a number of methods. Depending on what you want to be able to do with a metric, different functions need to be implemented. ","category":"page"},{"location":"custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"Gradus also provides a few derivative abstract types to implement to ensure the most efficient code is executed for a given metric (see Metric parameter types below).","category":"page"},{"location":"custom-metrics/#Example:-Schwarzschild","page":"Implementing new metrics","title":"Example: Schwarzschild","text":"","category":"section"},{"location":"custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"As a minimal example, here is how the Schwarzschild metric may be implemented. First, we must define what the metric parameters for this metric are. These are effectively constants of the spacetime, representing physical quantities that appear in the metric expression. For the Schwarzschild metric, this is only the black hole mass M, but e.g. the Kerr metric also has the black hole spin a.","category":"page"},{"location":"custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"We can choose the integration strategy by sub-typing an abstract type representing different classes of spacetimes. For the Schwarzschild metric, we will use the static, axis-symmetric class, with the automatic differentiation (AD) backend. With AD, we only need to specify the non-zero components of the metric as Julia functions, and the rest is done for us.","category":"page"},{"location":"custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"For ease, we choose the Eddington-Finkelstein coordinates of the Schwarzschild solution, which may be written","category":"page"},{"location":"custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"textds^2 =\n    - left( 1 - frac2 Mr right) textdt^2\n    + left( 1 - frac2 Mr right)^-1 textdr^2\n    + r^2 textdtheta^2\n    + r^2 sin^2(theta) textdphi^2","category":"page"},{"location":"custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"Here is a possible implementation for Gradus.jl:","category":"page"},{"location":"custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"using Gradus\n\n@with_kw struct EddingtonFinkelsteinAD{T} <: AbstractStaticAxisSymmetric{T}\n    M = 1.0\nend\n\nfunction Gradus.metric_components(m::EddingtonFinkelsteinAD{T}, rθ) where {T}\n    (r, θ) = rθ\n    M = m.M\n\n    tt = -(1 - (2M / r))\n    rr = -inv(tt)\n    θθ = r^2\n    ϕϕ = r^2 * sin(θ)^2\n\n    (tt, rr, θθ, ϕϕ, T(0.0))\nend\n\nGradus.inner_radius(m::EddingtonFinkelsteinAD) = 2 * m.M","category":"page"},{"location":"custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"A few notes:","category":"page"},{"location":"custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"We use @with_kw from Parameters.jl to define various utility constructors for us.\nmetric_components must return five elements for AbstractStaticAxisSymmetric, where the last element is the off-axis g_t phi matrix element, which in this case is always 0.\nThe inner_radius function defines the inner-radius of integration chart. This defines where the integration should terminate to avoid running indefinitely, and is, in this case, set to the event-horizon of our metric.","category":"page"},{"location":"custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"That's all we need! This metric is now ready to be traced in the usual way.","category":"page"},{"location":"custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"note: Note\nFor more examples of how to implement different metrics, click on the \"source\" button of a metric in Implemented Metrics. Alternatively, view the source code directly here.","category":"page"},{"location":"custom-metrics/#Metric-parameter-types","page":"Implementing new metrics","title":"Metric parameter types","text":"","category":"section"},{"location":"custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"The following types may be implemented to add new metrics. Each type has different requirements for its interface.","category":"page"},{"location":"custom-metrics/#First-Order","page":"Implementing new metrics","title":"First-Order","text":"","category":"section"},{"location":"custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"AbstractFirstOrderMetric\nGradus.four_velocity\nGradus.calc_lq\nGradus.Vr\nGradus.Vθ","category":"page"},{"location":"custom-metrics/#Gradus.AbstractFirstOrderMetric","page":"Implementing new metrics","title":"Gradus.AbstractFirstOrderMetric","text":"AbstractFirstOrderMetric{T} <: AbstractMetric{T}\n\nAbstract type for metrics using the 1st-order integration method. The 1st-order methods reuse the velocity vector as a parameter vector, where only element vel[2] and vel[3] are used, and are local observer ratios sin Theta and sin Phi respectively.\n\nRequire implementation of\n\ninner_radius\n_constrain\nfour_velocity\ncalc_lq\nVr\nVθ\nimpact_parameters_to_three_velocity\n\n\n\n\n\n","category":"type"},{"location":"custom-metrics/#Gradus.four_velocity","page":"Implementing new metrics","title":"Gradus.four_velocity","text":"four_velocity(x, m::AbstractFirstOrderMetric, p)\n\nCalculate the four-velocity at a point u, given a set of metric parameters and the constants of motion in p.\n\n\n\n\n\n","category":"function"},{"location":"custom-metrics/#Gradus.calc_lq","page":"Implementing new metrics","title":"Gradus.calc_lq","text":"calc_lq(m::AbstractFirstOrderMetric, pos, param))\n\nCalculate constants of motion L and Q, given a set of metric parameters, the geodesic position, and the param vector.\n\n\n\n\n\n","category":"function"},{"location":"custom-metrics/#Gradus.Vr","page":"Implementing new metrics","title":"Gradus.Vr","text":"Vr(m::AbstractFirstOrderMetric, u, p)\n\nEffective potential in the radial direction. Used only to track sign changes.\n\n\n\n\n\n","category":"function"},{"location":"custom-metrics/#Gradus.Vθ","page":"Implementing new metrics","title":"Gradus.Vθ","text":"Vθ(m::AbstractFirstOrderMetric, u, p)\n\nEffective potential in the angular direction. Used only to track sign changes.\n\n\n\n\n\n","category":"function"},{"location":"custom-metrics/#Second-Order","page":"Implementing new metrics","title":"Second-Order","text":"","category":"section"},{"location":"custom-metrics/","page":"Implementing new metrics","title":"Implementing new metrics","text":"metric_components\nAbstractStaticAxisSymmetric","category":"page"},{"location":"custom-metrics/#Gradus.metric_components","page":"Implementing new metrics","title":"Gradus.metric_components","text":"metric_components(m::AbstractMetric{T}, x)\n\nReturn a tuple with each non-zero metric component for the metric described by m at position x. Note that the position need not be a four-vector, and for specific implementations may only be a subset of the total manifold coordinates. See specific implementations for subtypes of AbstractMetric for details.\n\n\n\n\n\nmetric_components(m::AbstractStaticAxisSymmetric, rθ\n\nInterface for AbstractStaticAxisSymmetric. Should return a vector or tuple with the elements\n\nleft(\n    g_tt g_rr g_theta theta g_phi phi g_tphi\nright)\n\n\n\n\n\n","category":"function"},{"location":"custom-metrics/#Gradus.AbstractStaticAxisSymmetric","page":"Implementing new metrics","title":"Gradus.AbstractStaticAxisSymmetric","text":"AbstractStaticAxisSymmetric{T}\n\nSpecialisation for static, axis-symmetric metrics. Here, the metric is of the form\n\n    g_munu =\n    left( beginmatrix\n        g_tt      0       0                   g_tphi     \n        0           g_rr  0                   0              \n        0           0       g_thetatheta  0              \n        g_tphi  0       0                   g_phiphi\n    endmatrix right)\n\nwhere the only non-zero off axis elements are g_tphi.\n\nRequired implementations:\n\ninner_radius\nmetric_components\n\n\n\n\n\n","category":"type"},{"location":"metrics/#Catalogue-of-metrics","page":"Catalogue of metrics","title":"Catalogue of metrics","text":"","category":"section"},{"location":"metrics/","page":"Catalogue of metrics","title":"Catalogue of metrics","text":"CurrentModule = Gradus","category":"page"},{"location":"metrics/","page":"Catalogue of metrics","title":"Catalogue of metrics","text":"Gradus.jl implements a library of metrics ready to use for integrations and rendering.","category":"page"},{"location":"metrics/","page":"Catalogue of metrics","title":"Catalogue of metrics","text":"Pages = [\"metrics.md\"]\nModules = [Gradus]\nOrder = [:type]","category":"page"},{"location":"metrics/","page":"Catalogue of metrics","title":"Catalogue of metrics","text":"note: Note\nTo implement your own custom metrics, please see Implementing a new metric. If you have a complex metric, please open an issue requesting for it to be added.","category":"page"},{"location":"metrics/#Currently-available-metrics","page":"Catalogue of metrics","title":"Currently available metrics","text":"","category":"section"},{"location":"metrics/","page":"Catalogue of metrics","title":"Catalogue of metrics","text":"Modules = [Gradus]\nFilter = t -> typeof(t) === UnionAll && t <: Gradus.AbstractMetric","category":"page"},{"location":"metrics/#Gradus.AbstractMetric","page":"Catalogue of metrics","title":"Gradus.AbstractMetric","text":"abstract type AbstractMetric{T} end\n\nAbstract type used to dispatch different geodesic problems.\n\n\n\n\n\n","category":"type"},{"location":"metrics/#Gradus.DilatonAxion","page":"Catalogue of metrics","title":"Gradus.DilatonAxion","text":"struct DilatonAxion{T} <: AbstractStaticAxisSymmetric{T}\n\nEinstein-Maxwell-Dilaton-Axion metric.\n\nM = 1.0: Singularity mass.\na = 0.0: Singularity spin.\nβ = 0.0: Dilaton coupling strength.\nb = 1.0: Axion coupling strength.\n\n\n\n\n\n","category":"type"},{"location":"metrics/#Gradus.JohannsenMetric","page":"Catalogue of metrics","title":"Gradus.JohannsenMetric","text":"struct JohannsenMetric{T} <: AbstractStaticAxisSymmetric{T}\n\nThe Johannsen (20xx) metric.\n\nM = 1.0: Black hole mass.\na = 0.0: Black hole spin.\nα13 = 0.0: alpha_13 deviation parameter.\nα22 = 0.0: alpha_22 deviation parameter.\nα52 = 0.0: alpha_52 deviation parameter.\nϵ3 = 0.0: epsilon_3 deviation parameter.\n\n\n\n\n\n","category":"type"},{"location":"metrics/#Gradus.JohannsenPsaltisMetric","page":"Catalogue of metrics","title":"Gradus.JohannsenPsaltisMetric","text":"struct JohannsenPsaltisMetric{T} <: AbstractStaticAxisSymmetric{T}\n\nJohannsen and Psaltis 2011\n\nM = 1.0: Black hole mass.\na = 0.0: Black hole spin.\nϵ3 = 0.0: epsilon_3 deviation parameter.\n\n\n\n\n\n","category":"type"},{"location":"metrics/#Gradus.KerrDarkMatter","page":"Catalogue of metrics","title":"Gradus.KerrDarkMatter","text":"struct KerrDarkMatter\n\nhttps://arxiv.org/pdf/2003.06829.pdf\n\n\n\n\n\n","category":"type"},{"location":"metrics/#Gradus.KerrMetric","page":"Catalogue of metrics","title":"Gradus.KerrMetric","text":"struct KerrMetric{T} <: AbstractStaticAxisSymmetric{T}\n\nThe Kerr metric in Boyer-Lindquist coordinates, describing a black hole with mass M and angular spin a:\n\nbeginalign*\n    textds^2 =\n    - left( 1 - frac2 M rSigma right)textdt^2\n    - frac2M r a sin^2(theta)Sigma textdt textdphi\n    \n    + fracSigmaDelta textdr^2\n    + Sigma textdtheta^2\n    + left(r^2 + a^2 + frac2 M r a^2 sin^2(theta)Sigma right) sin^2(theta) textdphi^2\nendalign*\n\nwhere\n\nSigma = r^2 + a^2 cos^2 (theta)\nquad textand quad\nDelta = r^2 - 2Mr + a^2\n\nParameters\n\nM = 1: black hole mass.\na = 0: black hole spin.\n\n\n\n\n\n","category":"type"},{"location":"metrics/#Gradus.KerrNewmanMetric","page":"Catalogue of metrics","title":"Gradus.KerrNewmanMetric","text":"struct KerrNewmanMetric{T} <: AbstractStaticAxisSymmetric{T}\n\n\n\n\n\n","category":"type"},{"location":"metrics/#Gradus.KerrRefractive","page":"Catalogue of metrics","title":"Gradus.KerrRefractive","text":"struct KerrRefractive{T} <: AbstractStaticAxisSymmetric{T}\n\nKerr metric in Boyer-Lindquist coordintes with a path-length ansatz, equivalent to a refractive index n, within the coronal radius corona_radius.\n\nM = 1.0: Black hole mass.\na = 0.0: Black hole spin.\nn = 1.0: Refractive index within the corona.\ncorona_radius = 20.0: Radius of the corona.\n\n\n\n\n\n","category":"type"},{"location":"metrics/#Gradus.KerrSpacetimeFirstOrder","page":"Catalogue of metrics","title":"Gradus.KerrSpacetimeFirstOrder","text":"A first-order implementation of KerrMetric.\n\nM = 1.0: Black hole mass.\na = 0.0: Black hole spin.\nE = 1.0: Geodesic energy (a consant of motion).\n\n\n\n\n\n","category":"type"},{"location":"metrics/#Gradus.MorrisThorneWormhole","page":"Catalogue of metrics","title":"Gradus.MorrisThorneWormhole","text":"struct MorrisThorneWormhole{T} <: AbstractStaticAxisSymmetric{T}\n\nMorris-Thorne wormhole metric.\n\nb = 1.0: Throat size.\n\n\n\n\n\n","category":"type"},{"location":"metrics/#Gradus.NoZMetric","page":"Catalogue of metrics","title":"Gradus.NoZMetric","text":"struct NoZMetric\n\n\n\n\n\n","category":"type"},{"location":"accretion-geometry/#Accretion-geometry","page":"Accretion geometry","title":"Accretion geometry","text":"","category":"section"},{"location":"accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"CurrentModule = Gradus","category":"page"},{"location":"accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"Gradus.jl supports the ability to implement custom accretion geometry, or even load in mesh files in any standard format using MeshIO.jl. Geometry may be standard spherically symmetric accretion discs, or any other custom type.","category":"page"},{"location":"accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"note: Note\nCurrently geometry is optically thick always. Radiative transfer will be added soon.","category":"page"},{"location":"accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"AbstractAccretionGeometry\nGradus.in_nearby_region\nGradus.has_intersect","category":"page"},{"location":"accretion-geometry/#Gradus.AbstractAccretionGeometry","page":"Accretion geometry","title":"Gradus.AbstractAccretionGeometry","text":"abstract type AbstractAccretionGeometry{T}\n\nSupertype of all accretion geometry. Concrete sub-types must minimally implement\n\nin_nearby_region\nhas_intersect\n\nAlternativey, for more control, either intersects_geometry or geometry_collision_callback may be implemented for a given geometry type.\n\nGeometry intersection calculations are performed by strapping discrete callbacks to the integration procedure.\n\n\n\n\n\n","category":"type"},{"location":"accretion-geometry/#Gradus.in_nearby_region","page":"Accretion geometry","title":"Gradus.in_nearby_region","text":"in_nearby_region(g::AbstractAccretionGeometry{T}, line_element)::Bool\n\nReturns a boolean indicating whether the line_element is \"close\" to the geometry in question. Used to optimize when to call the intersection algorithm.\n\nContextually, \"close\" is a little arbitrary, and this function may always return True, however will suffer in performance if this is the case.\n\nline_element is a tuple of two four-position vectors, indicating the last integration position, and current integration position, i.e. (u_prev, u_curr), in integrator coordinates.\n\nNotes\n\nThis function actually depends on the step size of the integrator, but this is currently not considered in the implementation.\n\n\n\n\n\n","category":"function"},{"location":"accretion-geometry/#Gradus.has_intersect","page":"Accretion geometry","title":"Gradus.has_intersect","text":"has_intersect(g::AbstractAccretionGeometry{T}, line_element)\n\nReturns a boolean indicating whether line_element intersects the geometry g. The intersection algorithm used depends on the geometry considered. For meshes, this uses the jsf_algorithm.\n\nline_element is a tuple of two four-position vectors, indicating the last integration position, and current integration position, i.e. (u_prev, u_curr), in integrator coordinates.\n\n\n\n\n\n","category":"function"},{"location":"accretion-geometry/#Adding-new-accretion-geometry","page":"Accretion geometry","title":"Adding new accretion geometry","text":"","category":"section"},{"location":"accretion-geometry/#Accretion-discs","page":"Accretion geometry","title":"Accretion discs","text":"","category":"section"},{"location":"accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"AbstractAccretionDisc\ndistance_to_disc\nAbstractThickAccretionDisc\ncross_section","category":"page"},{"location":"accretion-geometry/#Gradus.AbstractAccretionDisc","page":"Accretion geometry","title":"Gradus.AbstractAccretionDisc","text":"abstract type AbstractAccretionDisc{T} <: AbstractAccretionGeometry{T}\n\nSupertype for axis-symmetric geometry, where certain optimizing assumptions may be made. Concrete subtypes must implement distance_to_disc.\n\n\n\n\n\n","category":"type"},{"location":"accretion-geometry/#Gradus.distance_to_disc","page":"Accretion geometry","title":"Gradus.distance_to_disc","text":"distance_to_disc(d::AbstractAccretionGeometry, u; kwargs...)\n\nCalculate distance to the closest element of the disc. The distance need not be metric or Pythagorean, but rather should be positive when the four vector u is distant, zero when u is on the surface, and negative when u is within the disc geometry.\n\nMust return a floating point number.\n\n\n\n\n\n","category":"function"},{"location":"accretion-geometry/#Gradus.AbstractThickAccretionDisc","page":"Accretion geometry","title":"Gradus.AbstractThickAccretionDisc","text":"abstract type AbstractThickAccretionDisc{T} <: AbstractAccretionDisc{T}\n\nSupertype for axis-symmetric geometry that are specified by a height cross-section function. Subtypes are required to implement cross_section.\n\n\n\n\n\n","category":"type"},{"location":"accretion-geometry/#Gradus.cross_section","page":"Accretion geometry","title":"Gradus.cross_section","text":"cross_section(d::AbstractThickAccretionDisc, u)\n\nReturn the height cross-section of a thick accretion disc at the (projected) coordinates of u. This function also incorporates bounds checking, and should return a negative value if the disc is not defined at u.\n\nExample\n\nFor a top hat disc profile with constant height between two radii\n\nstruct TopHatDisc{T} <: AbstractThickAccretionDisc{T}\n    inner_r::T\n    outer_r::T\nend\n\nfunction Gradus.cross_section(d::TopHatDisc, u)\n    # project u into equatorial plane\n    r = u[2] * sin(u[3])\n    if (r < d.inner_r) || (r > d.outer_r)\n        return -1.0\n    else\n        return 1.0\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"accretion-geometry/#Available-accretion-geometry","page":"Accretion geometry","title":"Available accretion geometry","text":"","category":"section"},{"location":"accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"GeometricThinDisc\nThickDisc\nShakuraSunyaev","category":"page"},{"location":"accretion-geometry/#Gradus.ThickDisc","page":"Accretion geometry","title":"Gradus.ThickDisc","text":"ThickDisc{T,F,P} <: AbstractThickAccretionDisc{T}\nThickDisc(f, params=nothing; T = Float64)\n\nA standard wrapper for creating custom disc profiles from height cross-section function f. This function is given the disc parameters as unpacked arguments:\n\nd.f(u, d.params...)\n\nIf no parameters are specified, none will be passed to f.\n\nExample\n\nSpecifying a toroidal disc centered on r=10 with radius 1:\n\nd = ThickDisc() do u\n    r = u[2]\n    if r < 9.0 || r > 11.0\n        return -1.0\n    else\n        x = r - 10.0\n        sqrt(1-x^2)\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"accretion-geometry/#Gradus.ShakuraSunyaev","page":"Accretion geometry","title":"Gradus.ShakuraSunyaev","text":"ShakuraSunyaev{T} <: AbstractThickAccretionDisc{T}\nShakuraSunyaev(\n    m::AbstractMetric;\n    eddington_ratio = 0.3,\n    η = nothing,\n    contra_rotating = false,\n)\n\nThe classic Shakura & Sunyaev (1973) accretion disc model, with height given by 2H, where\n\nH = frac32 frac1eta left( fracdotMdotM_textEdd right) left( 1 - sqrtfracr_textiscorho right)\n\nHere eta is the radiative efficiency, which, if unspecified, is determined by the circular orbit energy at the ISCO:\n\neta = 1 - E_textisco\n\n\n\n\n\n","category":"type"},{"location":"accretion-geometry/#Meshes","page":"Accretion geometry","title":"Meshes","text":"","category":"section"},{"location":"accretion-geometry/","page":"Accretion geometry","title":"Accretion geometry","text":"MeshAccretionGeometry","category":"page"},{"location":"accretion-geometry/#Gradus.MeshAccretionGeometry","page":"Accretion geometry","title":"Gradus.MeshAccretionGeometry","text":"MeshAccretionGeometry(mesh)\n\n\n\n\n\n","category":"type"},{"location":"geodesic-integration/#Geodesic-integration-strategies","page":"Geodesic integration","title":"Geodesic integration strategies","text":"","category":"section"},{"location":"geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"CurrentModule = Gradus","category":"page"},{"location":"geodesic-integration/#Second-Order","page":"Geodesic integration","title":"Second-Order","text":"","category":"section"},{"location":"geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"The motivation behind the second-order methods is to permit the computation of geodesics in generic spacetimes, via the geodesic equation:","category":"page"},{"location":"geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"Gradus.compute_geodesic_equation","category":"page"},{"location":"geodesic-integration/#Gradus.compute_geodesic_equation","page":"Geodesic integration","title":"Gradus.compute_geodesic_equation","text":"compute_geodesic_equation(ginv, j1, j2, v)\n\nUsing the inverse metric ginv, the Jacobian of the metric for r and theta, j1 and j2 respectively, and velocity four-vector v, calculates the four-acceleration via the geodesic equation.\n\nReturns the components of fractextd^2 u^mutextd lambda^2 via\n\nfractextd^2 u^mutextd lambda^2\n    + Gamma^mu_phantommunusigma\n    fractextdu^nutextd lambda\n    fractextdu^sigmatextd lambda\n= 0\n\nwhere x^mu is a position four-vector, Gamma^mu_phantommunusigma are the Christoffel symbols of the second kind, and lambda the affine parameter describing the curve.\n\nThe Christoffel symbols Gamma^mu_phantommunusigma are defined\n\nGamma^mu_phantommunusigma\n= frac12 g^murho left(\n    partial_nug_rho sigma\n    + partial_sigmag_rho nu\n    - partial_rhog_sigma nu\nright)\n\nLimitations:\n\ncurrenly pre-supposes static, axis-symmetric metric.\n\n\n\n\n\n","category":"function"},{"location":"geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"The above can be solved as a second-order ODE, subject to an initial position and initial velocity","category":"page"},{"location":"geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"u^mu = left(t r theta phi right)\nquad\ntextand\nquad\ndotu^mu  \n    = left( dott dotr dottheta dotphi right)","category":"page"},{"location":"geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"where the dot refers to the derivative with respect to lambda. In general, the spatial components of the initial velocity are known a priori, and the time-component is determined via the constraint:","category":"page"},{"location":"geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"Gradus.constrain_time","category":"page"},{"location":"geodesic-integration/#Gradus.constrain_time","page":"Geodesic integration","title":"Gradus.constrain_time","text":"constrain_time(g_comp, v, μ = 0.0, positive::Bool = true)\n\nConstrains the time component of the four-velocity v, given metric components g_comp and effective mass μ.\n\ng_sigmanu dotu^sigma dotu^nu = -mu^2\n\nfor v^t. The argument positive allows the sign of mu to be changed. true corresponds to time-like geodesics, false to space-like.\n\nThis function should rarely be directly called, and instead is invoked by _constrain.\n\nLimitations:\n\ncurrenly pre-supposes static, axis-symmetric metric.\n\n\n\n\n\n","category":"function"},{"location":"geodesic-integration/#Methods","page":"Geodesic integration","title":"Methods","text":"","category":"section"},{"location":"geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"TransferFunctionMethod\nBinningMethod","category":"page"},{"location":"geodesic-integration/#Gradus.TransferFunctionMethod","page":"Geodesic integration","title":"Gradus.TransferFunctionMethod","text":"TransferFunctionMethod()\n\nComputing the underlying relativistic effects using Cunningham transfer functions. This method has a number of limitations related to the assumptions:\n\nThe disc must be axis-symmetric.\nThe accretion disc must have a velocity structure that depends only on radius.\nThe domain of integration must be in or above the equatorial plane (no false images).\n\nThe transfer function approach is often faster and converges to higher numerical accuracy than the other methods. They can also be pre-computed for use in spectral models for fitting.\n\n\n\n\n\n","category":"type"},{"location":"geodesic-integration/#Gradus.BinningMethod","page":"Geodesic integration","title":"Gradus.BinningMethod","text":"BinningMethod()\n\nCompute the underlying relativistic effects by 'binning' the observer's plane into a number of regions, and tracing a single geodesic for each photon. Conceptually, this is like tracing a single photon for each pixel, however the regions need not be equi-rectangular, and may take on other shapes, see AbstractImagePlane.\n\nThis method is slow and computationally expensive, but has the benefit that it makes no assumptions about the model being computed.\n\nIt is internally used for testing conceptually more complex integration methods.\n\n\n\n\n\n","category":"type"},{"location":"geodesic-integration/#Image-planes","page":"Geodesic integration","title":"Image planes","text":"","category":"section"},{"location":"geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"AbstractImagePlane\nPolarPlane\nCartesianPlane","category":"page"},{"location":"geodesic-integration/#Gradus.AbstractImagePlane","page":"Geodesic integration","title":"Gradus.AbstractImagePlane","text":"AbstractImagePlane\n\nAn plane abstraction used to represent the observer's image plane. These are particularly relevant for BinningMethod computations.\n\nConcerete implementations include:\n\nPolarPlane\nCartesianPlane\n\nAn AbstractImagePlane must implement the following functions:\n\nimage_plane\ntrajectory_count\nunnormalized_areas\n\n\n\n\n\n","category":"type"},{"location":"geodesic-integration/#Gradus.PolarPlane","page":"Geodesic integration","title":"Gradus.PolarPlane","text":"function PolarPlane(\n    grid::AbstractImpactParameterGrid;\n    Nr = 400,\n    Nθ = 100,\n    r_min = 1.0,\n    r_max = 250.0,\n    θ_min = 0.0,\n    θ_max = 2π,\n)\n\nDivide the image plane into a polar grid centered at alpha = 0 and beta = 0.\n\n\n\n\n\n","category":"type"},{"location":"geodesic-integration/#Gradus.CartesianPlane","page":"Geodesic integration","title":"Gradus.CartesianPlane","text":"function CartesianPlane(\n    grid::AbstractImpactParameterGrid;\n    Nx = 150,\n    Ny = 150,\n    x_min = 0.0,\n    x_max = 150.0,\n    y_min = 0.0,\n    y_max = 150.0,\n)\n\nRepresent the image plane as equi-rectangular regions.\n\n\n\n\n\n","category":"type"},{"location":"geodesic-integration/","page":"Geodesic integration","title":"Geodesic integration","text":"Gradus.image_plane\nGradus.trajectory_count\nGradus.unnormalized_areas","category":"page"},{"location":"geodesic-integration/#Gradus.image_plane","page":"Geodesic integration","title":"Gradus.image_plane","text":"image_plane(plane::AbstractImagePlane)\nimage_plane(plane::AbstractImagePlane, x::SVector{4})\n\nReturn two vectors, representing the alpha and beta impact parameters that parameterise the image plane. Each pair of alpha and beta must correspond to an unnormalized_areas.\n\n\n\n\n\n","category":"function"},{"location":"geodesic-integration/#Gradus.trajectory_count","page":"Geodesic integration","title":"Gradus.trajectory_count","text":"trajectory_count(plane::AbstractImagePlane)\n\nReturn an integer that counts how many unique geodesics need to be calculated to map the plane. This should be equal to length(first(image_plane(plane))), and is used to pre-allocate buffers.\n\n\n\n\n\n","category":"function"},{"location":"geodesic-integration/#Gradus.unnormalized_areas","page":"Geodesic integration","title":"Gradus.unnormalized_areas","text":"unnormalized_areas(plane::AbstractImagePlane)\n\nReturn a vector where each element is the area (number) of a given geodesic element on the image plane. For a pixel image plane, each area will be a constant 1. These are used to weight the contributions of each region when calculating observational results.\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pages = [\"examples.md\"]\nDepth = 3","category":"page"},{"location":"examples/#Tracing-geodesic-paths","page":"Examples","title":"Tracing geodesic paths","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Gradus, Plots\n\nm = JohannsenPsaltisMetric(M=1.0, a=0.6, ϵ3=2.0)\n# observer position\nx = SVector(0.0, 10000.0, π/2, 0.0)\n\n# set up impact parameter space\nα = collect(range(-10.0, 10.0, 20))\nβ = fill(0, size(α))\n\n# build initial velocity and position vectors\nvs = map_impact_parameters(m, x, α, β)\nxs = fill(x, size(vs))\n\nsols = tracegeodesics(m, xs, vs, 20000.0)\n\nplot_paths(sols, legend = false, n_points = 2048)\nplot_horizon!(m, lw = 2.0, color = :black)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Alternatively, plotting the 3D paths from e.g. a lamp-post coronal model:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"m = KerrMetric(a = 0.0)\n\nmodel = LampPostModel()\nsols = tracegeodesics(\n    m,\n    model,\n    2000.0,\n    n_samples = 64\n)\n\nplot_paths_3d(sols, legend=false, extent = 10, t_span = 100.0)\nplot_horizon_3d!(m)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Shadow","page":"Examples","title":"Shadow","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Gradus, Plots\n\nm = KerrMetric(1.0, 0.998)\nx = SVector(0.0, 10000.0, π / 2, 0.0)\n\nα, β, img = rendergeodesics(\n    m,\n    x,\n    # max integration time\n    20_000.0,\n    image_width = 800,\n    image_height = 800,\n    αlims = (-4, 8),\n    βlims = (-6, 6),\n    verbose = true,\n    ensemble = Gradus.EnsembleEndpointThreads(),\n)\n\np = heatmap(\n    α,\n    β,\n    img,\n    color = Plots.cgrad(:thermal, rev = true),\n    xlabel = \"α\",\n    ylabel = \"β\",\n    aspect_ratio = 1,\n    minorgrid = true,\n)\ncontour!(p, α, β, img, color = :red)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Redshift-image","page":"Examples","title":"Redshift image","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Note\nThe Gradus.ConstPointFunctions.redshift function is an analytic solution for redshift, which may not be implemented for every type of metric or disc geometry. See Interpolating redshifts for a more flexible numeric alternative.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Gradus, Plots\n\n# metric and metric parameters\nm = KerrMetric(M=1.0, a=1.0)\n# observer position\nx = SVector(0.0, 1000.0, deg2rad(60), 0.0)\n# accretion disc\nd = ThinDisc(1.0, 50.0)\n\n# define point function which filters geodesics that intersected the accretion disc\n# and use those to calculate redshift\npf = ConstPointFunctions.redshift(m, x) ∘ ConstPointFunctions.filter_intersected()\n\nα, β, img = rendergeodesics(\n    m,\n    x,\n    d,\n    # maximum integration time\n    2000.0,\n    αlims = (-60, 60), \n    βlims = (-30, 35),\n    image_width = 800,\n    image_height = 400,\n    verbose = true,\n    pf = pf,\n)\n\nheatmap(α, β, img, aspect_ratio = 1)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Redshift-line-profile","page":"Examples","title":"Redshift line-profile","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Using the redshift example, we can bin a redshift line-profile using StatsBase.jl. We'll calculate the iron line redshift profile, with a delta-emission at 6.4 keV.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using StatsBase\n\n# remove nans and flatten the redshift image\nredshift_data = filter(!isnan, vec(img))\n\n# transpose to iron-line\ndata = redshift_data .* 6.4\n\nx_bins = range(0.0, 10.0, 100) \nlineprof = fit(Histogram, data, x_bins)\n\nplot(x_bins[1:end-1], lineprof.weights, seriestype = :steppre)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Line-profiles","page":"Examples","title":"Line profiles","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Line profiles may be calculated using two different methods – using image-plane binning and integrating Cunningham transfer functions – both of which are implemented in Gradus.jl. By default, the Cunningham transfer function method is used, however passing either BinnedLineProfile() or CunninghamLineProfile() as the first argument to lineprofile allows for explicit specification of the algorithm.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For a simple maximally-spinning Kerr black hole, the iron line profile (with a delta emission line at 6.4 keV) may be calculated with:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"d = ThinDisc(0.0, 400.0)\nx = SVector(0.0, 1000.0, deg2rad(40), 0.0)\nm = KerrMetric(1.0, 0.998)\n\n# maximal integration radius\nmaxrₑ = 50.0\n\n# emissivity function\nε(r) = r^(-3)\n\n# g grid to do flux integration over\ngs = range(0.0, 1.2, 500)\n_, flux = lineprofile(gs, ε, m, x, d, maxrₑ = maxrₑ, verbose = true)\n\n# plot flux as a function of energy\nplot(gs, flux, legend=false)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Reverberation-transfer-functions","page":"Examples","title":"Reverberation transfer functions","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This first example for calculating the reverberation transfer functions is a binning method. Below is another example using a faster and more efficient method that Gradus provides.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"m = KerrMetric(1.0, 0.998)\nx = SVector(0.0, 1000.0, deg2rad(60), 0.0)\nd = ThinDisc(0.0, 1000.0)\n\n# specify coronal geometry\nmodel = LampPostModel(h = 10.0)\n# gridding for the photon plane\nplane = PolarPlane(GeometricGrid(); Nr = 1800, Nθ = 1800)\n\n# integrate source to disc and observer to disc\ntf = @time lagtransfer(\n    m,\n    x,\n    d,\n    model\n    ;\n    plane = plane,\n    callback = domain_upper_hemisphere(),\n    n_samples = 100_000,\n    verbose = true,\n)\n\n# compute the continuum spectrum arrival time\nt0 = continuum_time(m, x, model)\n\n# bin into a 2d grid, returning the time and energy axis, \n# and the flux in each bin\nt, E, f = binflux(tf, N_E = 1500, N_t = 1500, t0 = t0)\n\n# take the log for visualisation purposes\nI = f .> 0\nf[I] .= log.(f[I])\n\np = heatmap(\n    t,\n    E,\n    f,\n    xlabel = \"Time (GM/c^3)\",\n    ylabel = \"Energy (keV)\",\n    xlims = [0, 150],\n    ylims = [0, 9],\n    clims = (-20, 1)\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"An alternative syntax will dispatch our novel time-dependent transfer function integration:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# currently needs an infinite disc for the root finder (patch coming soon)\nd = ThinDisc(0.0, Inf)\nradii = Gradus.Grids._inverse_grid(Gradus.isco(m), 1000.0, 100)\nitb = @time Gradus.interpolated_transfer_branches(m, x, d, radii; verbose = true)\n\n# dispatches special methods for calculating the emissivity profile if available\nprof = emissivity_profile(m, d, model; n_samples = 2000)\n\ngbins = collect(range(0.0, 1.4, 500))\ntbins = collect(range(0, 150.0, 500))\n\nflux = Gradus.integrate_lagtransfer(\n    prof, \n    itb, \n    radii, \n    gbins, \n    tbins; \n    t0 = t0,\n    Nr = 6000\n)\n\np = heatmap(\n    tbins,\n    gbins,\n    log.(abs.(flux)),\n    xlabel = \"Time (GM/c^3)\",\n    ylabel = \"Energy (keV)\",\n    xlims = [0, 150],\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Covariant-radiative-transfer","page":"Examples","title":"Covariant radiative transfer","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# metric and metric parameters\nm = KerrMetric(M = 1.0, a = 1.0)\n# observer position\nx = SVector(0.0, 1000.0, deg2rad(80), 0.0)\n# accretion disc\nd = PolishDoughnut(m)\n\n# set the emissivity\nGradus.emissivity_coefficient(::AbstractMetric, ::PolishDoughnut, x, ν) = 0.1\n\n# define point function which reads the auxiliary variable\n# which is contextually the intensity\npf = PointFunction((m, gp, t) -> gp.aux[1])\n\na, b, img = @time rendergeodesics(\n    m,\n    x,\n    d,\n    # maximum integration time\n    2000.0,\n    verbose = true,\n    pf = pf,\n    # instruct the integrator to solve the covariant radiative transfer equation\n    αlims = (-25, 25), \n    βlims = (-15, 18),\n    trace = Gradus.TraceRadiativeTransfer(I₀ = 0),\n)\n\nheatmap(a, b, img, aspect_ratio = 1, xlabel = \"α\", ylabel = \"β\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Interpolating-redshifts","page":"Examples","title":"Interpolating redshifts","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In cases where no analytic redshift solution is known, we can instead interpolate a numeric approximation. For example, interpolating the plunging region velocities and using the analytic solution for general static, axis symmetric metrics outside of the ISCO can be achieved with:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Gradus, Plots\n\n# metric and metric parameters\nm = KerrMetric(M=1.0, a=0.4)\n# observer's initial position\nx = SVector(0.0, 1000.0, deg2rad(85), 0.0)\n# accretion disc\nd = ThinDisc(1.0, 50.0)\n\npl_int = interpolate_plunging_velocities(m)\n\nredshift = interpolate_redshift(pl_int, x)\n\npf = redshift ∘ ConstPointFunctions.filter_intersected()\n\nα, β, img = rendergeodesics(\n    m,\n    x,\n    d,\n    # maximum integration time\n    2000.0,\n    image_width = 700,\n    image_height = 240,\n    verbose = true,\n    pf = pf\n)\n\nheatmap(α, β, img)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Note\nNote that this interpolation is automatically performed when using ConstPointFunctions.redshift(m, x) if no analytic implementation is given.","category":"page"},{"location":"examples/#Disc-geometries","page":"Examples","title":"Disc geometries","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Gradus makes it easy to define new height cross sections for thick discs:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Gradus, Plots\n\nm = KerrMetric(1.0, 0.0)\nx = SVector(0.0, 1000.0, deg2rad(85), 0.0)\n\n# define the disc shape -- return a negative number \n# where the disc should not be intersected, else the cross \n# sectional height\nd = ThickDisc() do ρ\n    if ρ < 9.0 || ρ > 11.0\n        return -1.0\n    else\n        h = ρ - 10.0\n        sqrt(1 - h^2)\n    end\nend\n\n# and then render as usual\nα, β, img = rendergeodesics(\n    m,\n    x,\n    d,\n    2000.0,\n    αlims = (-25, 25), \n    βlims = (-15, 18),\n    verbose = true,\n    pf = pf\n)\n\nheatmap(α, β, img, aspect_ratio=1)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For more disc on disc geometry, see AbstractAccretionDisc and associated sections.","category":"page"},{"location":"examples/#Circular-orbits","page":"Examples","title":"Circular orbits","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Simple equatorial circular orbits are straight forward to calculate with Gradus.jl:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Gradus, Plots\n\nm = KerrMetric(M=1.0, a=0.8)\n\np = plot(aspect_ratio=1)\n\nfor r in [3.0, 4.0, 5.0, 6.0]\n    v = CircularOrbits.fourvelocity(m, r)\n    # trace the circular orbit\n    path = tracegeodesics(m, @SVector([0.0, r, π/2, 0.0]), v, (0.0, 300.0), μ = 1.0)\n    plot_paths!(p, path, extent = 10, legend = false)\nend\n\np","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#ISCO","page":"Examples","title":"ISCO","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The Gradus.isco may be calculated with a simple convenience function, as may the energy associated with a given stable circular orbit.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Gradus, Plots\n\n# prepare plot\np = plot(legend=:bottomright, ylabel = \"E\", xlabel = \"r\", xscale = :log10)\n\n# choice of spin to plot energy curves for\nfor a in [0.0, 0.4, 0.6]\n    m = KerrMetric(M = 1.0, a = a)\n\n    rs = range(Gradus.isco(m), 100.0, 500)\n    energy = map(rs) do r\n        CircularOrbits.energy(m, r)\n    end\n\n    plot!(rs, energy, label = \"a=$a\")\nend\n\n# calculate the ISCO as a function of spin\ndata = map(range(-1.0, 0.8, 100)) do a\n    m = KerrMetric(M = 1.0, a = a)\n    r = Gradus.isco(m)\n    CircularOrbits.energy(m, r), r\nend\n\n# overlay onto plot\nplot!(last.(data), first.(data), color=:black, linestyle=:dash, label=\"ISCO\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Event-horizons-and-naked-singularities","page":"Examples","title":"Event horizons and naked singularities","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here is an example of how to use event_horizon to plot the shape of an event horizon in two dimensions. In the case of a naked singularity, as with the certain parameters combinations in the JohannsenPsaltisMetric metric, we see a disconnected region in the plot.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Gradus, Plots\n\nfunction draw_horizon(p, m)\n    rs, θs = event_horizon(m, resolution = 200)\n    radius = rs\n\n    x = @. radius * sin(θs)\n    y = @. radius * cos(θs)\n    plot!(p, x, y, label = \"a = $(m.a)\")\nend\n\np = plot(aspect_ratio = 1)\nfor a in [0.0, 0.5, 0.6, 0.7, 0.8]\n    m = JohannsenPsaltisMetric(M = 1.0, a = a, ϵ3 = 2.0)\n    draw_horizon(p, m)\nend\np","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can also calculate parameter combinations that lead to naked singularities, and plot the parameter space domains to show exclusion zones:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function calc_exclusion(as, ϵs)\n    regions = zeros(Float64, (length(as), length(ϵs)))\n    Threads.@threads for i in eachindex(as)\n        a = as[i]\n        for (j, ϵ) in enumerate(ϵs)\n            m = JohannsenPsaltisMetric(M = 1.0, a = a, ϵ3 = ϵ)\n            regions[i, j] = if is_naked_singularity(m)\n                NaN\n            else\n                Gradus.isco(m)\n            end\n        end\n    end\n    regions\nend\n\nas = range(0, 1.0, 100)\nϵs = range(-10, 10, 100)\n\nimg = calc_exclusion(as, ϵs)\nheatmap(\n    as, \n    ϵs, \n    img', \n    colorbar = false, \n    xlabel = \"a\", \n    ylabel = \"ϵ\"\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Cunningham-transfer-functions","page":"Examples","title":"Cunningham transfer functions","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Recreating Fig. 1 and 2 from Bambi et al. (2017) for the transfer functions of a Kerr black hole","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Gradus, Plots\n\nm = KerrMetric(M=1.0, a=0.998)\nd = ThinDisc(0.0, 100.0)\n\np = plot(legend = false)\nfor angle in [3, 35, 50, 65, 74, 85]\n    x = @SVector [0.0, 1000.0, deg2rad(angle), 0.0]\n    ctf = cunningham_transfer_function(\n        m, x, d, 4.0; N = 300\n    )\n    mask = @. (ctf.g✶ > 0.001) & (ctf.g✶ < 0.999)\n    @views plot!(p, ctf.g✶[mask], ctf.f[mask])\nend\np","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And Fig. 2:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# new position vector\nx = @SVector [0.0, 1000.0, deg2rad(30), 0.0]\n\np = plot(legend = false)\nfor a in [0.0, 0.25, 0.5, 0.75, 0.9, 0.998]\n    m = KerrMetric(1.0, a)\n    ctf = cunningham_transfer_function(\n        m, x, d, 7.0; N = 300,\n    )\n    mask = @. (ctf.g✶ > 0.001) & (ctf.g✶ < 0.999)\n    @views plot!(p, ctf.g✶[mask], ctf.f[mask])\nend\np","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Note\nFor more on transfer functions, how they are calculated and integrated, see Transfer functions.","category":"page"},{"location":"examples/#Concentric-rings","page":"Examples","title":"Concentric rings","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Recreating Figure 2 from Johannsen and Psaltis (2012, II):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Gradus, Plots\n\n# their papers has a=-a\nm = KerrMetric(M=1.0, a=-0.4)\nx = @SVector [0.0, 1000, acos(0.25), 0.0]\nd = ThinDisc(0.0, 100.0)\n\nradii = 2.6:1.0:7.6\n\np = plot(\n    aspect_ratio = 1,\n    legend = false,\n)\n\n# crosshair on origin\nhline!(p, [0.0], color = :black, linestyle=:dash)\nvline!(p, [0.0], color = :black, linestyle=:dash)\n\nfor r in radii\n    α, β = impact_parameters_for_radius(m, x, d, r, N=100)\n    plot!(p, α, β)\nend\np","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Hot-spot-on-the-disc","page":"Examples","title":"Hot spot on the disc","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Following [García et al. (2016)], without the magnetic potential, we can implement a model that uses covariant radiative transfer quite straightforwardly:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Gradus, Plots\n\nstruct HotSpot{T} <: AbstractAccretionDisc{T}\n    radius::T\n    position::SVector{3,T}\nend\n\n# convenience constructor\nHotSpot(R::T, r::T, ϕ::T) where {T} = HotSpot(R, SVector(r, π/2, ϕ))\n\n# we don't have an intersection criteria: instead, the calculations \n# are treated as if we are always within geometry\nGradus.is_finite_disc(::Type{<:HotSpot}) = false\n\n# Keplerian circular orbit fixed velocity\nfunction Gradus.fluid_velocity(\n    m::AbstractMetric, \n    hs::HotSpot, \n    x, \n    r_isco, \n    λ\n)\n    CircularOrbits.fourvelocity(m, hs.position[1])\nend\n\nfunction Gradus.fluid_absorption_emission(\n    m::AbstractMetric,\n    hs::HotSpot,\n    x,\n    ν,\n    v_disc,\n)\n    # use coordinate time, given the disc velocity, to advance the position\n    # as in the slow light regime\n    x_disc = hs.position - SVector(0, 0, v_disc[4] / v_disc[1] * x[1])\n\n    dist = cartesian_squared_distance(m, x_disc, x)\n    ε = exp(-dist / (2 * hs.radius^2))\n    # return absorption, emissivity, disc velocity\n    (zero(eltype(x)), ε)\nend\n\nm = KerrMetric(1.0, 0.5)\nx = SVector(0.0, 10_000.0, deg2rad(75), 0.0)\nhs = HotSpot(0.7, Gradus.isco(m) * 1.1, -1.0)\n\na, b, img = rendergeodesics(\n    m, \n    x, \n    hs, \n    20_000.0, \n    verbose = true, \n    αlims = (-15, 15),\n    βlims = (-10, 10),\n    trace = Gradus.TraceRadiativeTransfer(I₀ = 0.0),\n    pf = PointFunction((m, gp, t) -> gp.aux[1]),\n)\n\nheatmap(a, b, img)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the fast light regime, with an initial radial angle of -2.6 gives a very different picture","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"exports/#Exporting-data-products","page":"Exporting data products","title":"Exporting data products","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\" pa=\"0\" ma=\"0\">\n<img width=\"30%\" src=\"assets/uob-astro-grey.png\">\n</p>","category":"page"},{"location":"#Gradus.jl-Documentation","page":"Home","title":"Gradus.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Spacetime generic, general relativistic ray-tracing (GRRT) in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\"> <i> This package is in development and subject to rapid breaking changes, with documentation updates lagging behind features.</i> </p>","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Gradus.jl is a suite of tools related to tracing geodesics and calculating observational signatures. Gradus.jl requires only a specification of the non-zero metric components of a chosen spacetime in order to solve the geodesic equation and compute a wide variety of trajectories and orbits. Various algorithms for calculating physical quantities are implemented generically, so they may be used with different classes of spacetime with minimal implementation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, Gradus.jl can be used for any static, axis-symmetric spacetime to calculate:","category":"page"},{"location":"","page":"Home","title":"Home","text":"geodesic orbits and special radii (event horizon shapes, ISCO radii, etc.)\nnull / time / space like trajectories including for charged particles\nblack hole shadows\nredshift images\nCunningham transfer functions\nline profiles and spectra\nreverberation transfer functions\ntime-lags from different coronal models\nemissivity profiles on the accretion disc\ncovariant radiative transfer\nvarious toy accretion models (thin disc, alpha-discs, rotationally-supported polish doughnut, etc)\nnon-symmetric disc geometries\nmesh file geometry","category":"page"},{"location":"","page":"Home","title":"Home","text":"The library is written to make adding new features as effortless as possible. See Examples for more. Many new features are currently being developed as our research advances.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Gradus.jl uses DifferentialEquations.jl and ForwardDiff.jl as the backend for integrating and solving the geodesic equation for arbitrary metrics, and vendors the DifferentialEquations.jl solver and callback system, making Gradus.jl easy to extend for new problems. Gradus.jl currently supports multi-CPU integration and analysis, with GPU support on the horizon.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We assume you already have Julia >1.6.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All non-General dependencies for Gradus.jl are in the AstroRegistry which can be added to Julia with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia>] registry add https://github.com/astro-group-bristol/AstroRegistry","category":"page"},{"location":"","page":"Home","title":"Home","text":"NB: the Julia General Registry is required to install Gradus, however this should be configured by default with any Julia installation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Gradus.jl can then be fetched easily:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia>] add Gradus\njulia> using Gradus","category":"page"},{"location":"","page":"Home","title":"Home","text":"See GettingStarted for setting up your first traces.","category":"page"},{"location":"#See-also","page":"Home","title":"See also","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Julia programming language\nDifferentialEquations.jl\nForwardDiff.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"<hr>\n<p align=\"center\"> Astrophysics Group Bristol </p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Gradus.jl is primarily being developed by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fergus Baker (PhD Student)\nDr. Andrew Young (Associate Professor)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more University of Bristol Astrophysics Group codes, see our GitHub organisation.","category":"page"}]
}
